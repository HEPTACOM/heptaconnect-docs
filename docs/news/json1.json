{
    "version": "https://jsonfeed.org/version/1",
    "title": "HEPTAconnect feed",
    "home_page_url": "https://heptaconnect.io/",
    "description": "A newsfeed regarding changes in HEPTAconnect that are worthwhile a note",
    "icon": "https://heptaconnect.io/assets/favicon/android-chrome-512x512.png",
    "author": {
        "name": "HEPTACOM GmbH",
        "url": "https://www.heptacom.de"
    },
    "items": [
        {
            "id": "https://heptaconnect.io/news/2021-02-02-init/",
            "content_html": "<p>To react to community feedback we will start a feed to summarize every now and then interesting changes in this feed.</p>\n<p>This does not replace the <a href=\"https://heptaconnect.io/reference/adr/2020-08-10-architecture-decision-records/\">ADR</a> section at all.\nAs we have a lot of repositories and this will be a channel to summarize the news that are shared across the packages.\nThis will also be the way to get informed about new packages as we follow our <a href=\"https://heptaconnect.io/reference/general-resources/package-structure/\">flexible package structure</a>.</p>\n",
            "url": "https://heptaconnect.io/news/2021-02-02-init/",
            "title": "Initialization of a feed",
            "summary": "To react to community feedback we will start a feed to summarize every now and then interesting changes in this feed",
            "date_modified": "2021-02-02T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-02-08-shopcast/",
            "content_html": "<p>Edin Dedagic - host at the German podcast shopcast.fm - invited us to have a talk about HEPTACOM as part of the Shopware community and the guest Joshua Behrens.\nIt was inevitable to talk as well about HEPTAconnect.\nA lot about HEPTAconnect which even results in a split into two parts.</p>\n<p>Have a deep dive into two hours of HEPTAconnect knowledge and its creators:</p>\n<ul>\n<li><a href=\"https://shopcast.fm/casts/017-interview-joschua-pt-1/\">Part 1</a></li>\n<li><a href=\"https://shopcast.fm/casts/018-interview-joschua-pt-2/\">Part 2</a></li>\n</ul>\n",
            "url": "https://heptaconnect.io/news/2021-02-08-shopcast/",
            "title": "shopcast.fm appearance",
            "summary": "Joshua Behrens had the chance to talk about HEPTAconnect on shopcast.fm",
            "date_modified": "2021-02-08T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-03-23-data-flow-explorer/",
            "content_html": "<p>In the recent past we decided to allow <a href=\"https://heptaconnect.io/guides/portal-developer/explorer/\">explorers</a> behave like <a href=\"https://heptaconnect.io/guides/portal-developer/emitter/\">emitters</a> to allow easier processing of inefficient-to-read data sources.\nWe call this direct emission.\nHow to prepare your explorer for a direct emission is explained in the <a href=\"https://heptaconnect.io/guides/portal-developer/direct-emission-explorer/\">direct emission explorer</a> page.\nTo show the differences in the data flow we introduce a place where you can find multiple scenarios on the new <a href=\"https://heptaconnect.io/reference/general-resources/data-flow/\">data flow</a> overview.</p>\n<p><strong>Coming soon</strong>:\nWe are currently setting up an integration guide that holds up our integration knowledge and explains our decisions that you should consider as well.\nStay tuned to let your next project experience the full data transfer expertise.</p>\n",
            "url": "https://heptaconnect.io/news/2021-03-23-data-flow-explorer/",
            "title": "Data flows and direct emission exploration",
            "summary": "Introduction to data flows and direct emission exploration",
            "date_modified": "2021-03-23T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-05-23-playground-shopware-6-4/",
            "content_html": "<p>A wave of huge changes hit the playground and ironed some kinks.</p>\n<p><strong>The major update at Shopware from 6.3 to 6.4 has been rolled out onto the HEPTAconnect packages.</strong>\nTo experience Shopware 6.4 with HEPTAconnect you can now easily grab yourself a fresh copy of the <a href=\"https://heptaconnect.io/guides/playground/intro/\">playground</a> and dive in.\nTo allow the playground be used with your <a href=\"https://heptaconnect.io/guides/playground/first-time/with-shopware-6/\">familiar ecommerce framework</a> in a more complete manner you will now find an integrated <code>shopware/administration</code>.\nThis way you can use the playground to fiddle with HEPTAconnect within Shopware and in addition also with Shopware itself after importing your favorite data.</p>\n<p><strong>How to get your favorite data in, you might ask?</strong>\nJust use the bundled shopware platform portal.\nOn creating the shopware instance in the playground you will get a portal node for the shopware instance as well as for the artificial portal for bottles.\nRequire other portals you can already find online on GitHub under the tag <a href=\"https://github.com/topics/heptaconnect-portal\">heptaconnect-portal</a> into the shopware composer.json.\nThey are automatically discovered for you to draw your first routes between the portal nodes.</p>\n<p><strong>What is that /repos/ folder at root level?</strong>\nWe had a look at the <a href=\"https://heptaconnect.io/guides/playground/contribution/\">contribution and experimenting flow</a> we currently provide and chose to rework that.\nThe new folder contains every HEPTAconnect package as a clone from GitHub.\nThey are linked into the vendor folder.\nHaving the different packages on this directory level makes it much easier to discover and change HEPTAconnect.\nAs they are clones from GitHub it also allows a direct way to share your work on HEPTAconnect in a bleeding edge manner.</p>\n<p><strong>How can you know all of this?</strong> The documentation got a truck load of new content about:</p>\n<ul>\n<li><a href=\"https://heptaconnect.io/guides/playground/intro/\">the playground</a></li>\n<li><a href=\"https://heptaconnect.io/guides/playground/command-line/\">commands</a></li>\n</ul>\n<p>Some of these new pages are also linked within this article so have a look around.</p>\n",
            "url": "https://heptaconnect.io/news/2021-05-23-playground-shopware-6-4/",
            "title": "HEPTAconnect and playground support for Shopware 6.4",
            "summary": "The playground supports Shopware 6.4 and the docs will tell you how to use it in just a few steps",
            "date_modified": "2021-05-23T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-05-31-queue-and-job-storage/",
            "content_html": "<p>This week we completed our <a href=\"https://heptaconnect.io/reference/adr/2020-10-30-job-messages-and-payload/\">ADR about jobs</a>.\nWorking on that issue really created lots of space for further tasks in the architecture of HEPTAconnect as well as on the storage layer used for the message broker.</p>\n<p>In detail, we've been using the message broker to completely keep the data in question for each transfer.\nRead our <a href=\"https://heptaconnect.io/reference/adr/2020-10-30-job-messages-and-payload/\">ADR about jobs and their payloads</a> to follow our thoughts but here are the basic pros:</p>\n<ul>\n<li>When emptying a message queue, the messages can be reconstructed</li>\n<li>The message provider has fewer data to store</li>\n<li>It is easy to change job types and payload structures</li>\n</ul>\n<p>We were testing the storage sizes on a default Shopware 6 setup.\nIt uses php serialization to store messages on the database.\nAfter our change we only store a job reference in the message and store the payload on the database.\nOur referenced payload takes up from 40% to 95% less memory on the same database driver than in the message table.\nThe following tasks benefit from the size difference:</p>\n<ul>\n<li>database query times</li>\n<li>database backup sizes</li>\n<li>message broking on various providers</li>\n<li>restoring and duplicating systems</li>\n</ul>\n<p>Above mentioned the architecture also draws a big benefit from that change:\nAs we now have the job payloads separated from their execution scheduling, it is easier to add reference between these jobs.\nThis is especially useful for <a href=\"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem\">SAT</a> algorithms that will make their way into HEPTAconnect one day.</p>\n",
            "url": "https://heptaconnect.io/news/2021-05-31-queue-and-job-storage/",
            "title": "Queue and job memory utilization reduction up to 95%",
            "summary": "Switching to dedicated job storages reduced the memory utilization and improves job management",
            "date_modified": "2021-05-31T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-06-21-symfony-dependency-injection/",
            "content_html": "<h2>TL;DR</h2>\n<p>Write less. <br>\nAchieve more in less time. <br>\nLook at your results faster.</p>\n<p>Read more about <a href=\"https://heptaconnect.io/guides/portal-developer/dependency-injection/\">Dependency injection</a> and the new <a href=\"https://heptaconnect.io/guides/portal-developer/default-utilities/\">default utilities</a>.</p>\n<h2>Preamble</h2>\n<p>One of our main goals for HEPTAconnect is the ability to replace lots of different implementations to gain a frictionless integrability.\nWhen we were looking for the service container feature, we had an issue to solve:\nAs service container builders have not been addressed in the <a href=\"https://www.php-fig.org/psr/psr-11/\">PSR-11</a>, we had to implement service container and builder.\nThe custom implementation holds a 47 lines-of-code container implementation, a 36 lines-of-code container builder and a single entry point for portal developers in their code.</p>\n<h2>What we achieved</h2>\n<p>We were able to get yet another PSR compatibility and its benefits: build and share reusable components.\nBy now our implementation of a service container is about half a year old, and we are missing features.\nWe didn't expect our small implementation to have it all right away, but it is a bit impractical in daily usage.</p>\n<ul>\n<li>Tagged services are missing</li>\n<li>Every service had to have a service definition</li>\n<li>Service decoration was possible but very unpleasant</li>\n<li>Services could only be pulled out of the container</li>\n</ul>\n<p>It served the purpose, but it wasn't quite right.</p>\n<h2>What we were looking for</h2>\n<p>Basically we were looking for what we were missing:</p>\n<ul>\n<li>Tagged services</li>\n<li>Write no boilerplate service definitions (in the best case)</li>\n<li>Easy service decoration</li>\n<li>Dependency injection (instead of pulling)</li>\n</ul>\n<p>We were accustomed to the Symfony and Laravel worlds having all these features.\nLaravel didn't make the cut for us as it is difficult to pull Illuminate components out of their ecosystem.\nSymfony gave us similar expectations back when we noticed Bundles are part of the HttpKernel and also quite baked into the Symfony framework <code>/rant</code>.</p>\n<h2>The future is now</h2>\n<p>On our search for a good implementation for service containers with dependency injection we stumbled upon <a href=\"https://kocsismate.github.io/php-di-container-benchmarks/benchmark.html\">a benchmark</a>.\nThe Symfony implementation was most of the time in second place but had all we ever wanted.\nSo we revisited that package and were happy to see that it had barely any dependencies which is good for an almost frictionless package.\nHaving the service definition files based on xml and yml also allows portal developers to define services without knowing the exact Symfony version behind the scenes.</p>\n<p>We gave the implementation a try and got hooked right back into it.\nEnabling all the nice things and sprinkling some more educated guesses into the container builder gave us the shiny new developer experience for portal developers we always wanted to provide:</p>\n<ul>\n<li>Even in bigger scenarios there is no definition file needed as we are using the composer.json of the portal for prototyping definitions</li>\n<li>Auto-wiring allows for smart service injection guesses</li>\n<li>Auto-configuration allows for smart service kind detection</li>\n<li>Integrations are now able to alter the containers almost effortlessly</li>\n<li>Flow components (explorer, emitter, receivers) and status reporters can make use of dependency injection</li>\n<li>Portal developers are most likely from a Laravel or Symfony background and should be already quite familiar with the logic behind the scenes</li>\n</ul>\n<h2>Documentation</h2>\n<p>When you already had a deeper look into our documentation, you can notice the reduction of boilerplate code in almost every portal developer code sample.\nWe added <a href=\"https://heptaconnect.io/guides/portal-developer/dependency-injection/\">a new chapter</a> to the documentation under portal development containing everything you need to know to use dependency injection with the new service container.\nThis way we also took the chance to provide a <a href=\"https://heptaconnect.io/guides/portal-developer/default-utilities/\">complete list of utility service</a> we provide out of the box.</p>\n",
            "url": "https://heptaconnect.io/news/2021-06-21-symfony-dependency-injection/",
            "title": "Symfony dependency injection for portal developers",
            "summary": "Integrating a well known dependency injection container provides lots of cool features",
            "date_modified": "2021-06-21T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-07-12-short-notation/",
            "content_html": "<h2>TL;DR</h2>\n<p>Write less. <br>\nAchieve more in less time. <br>\nLook at your results faster.</p>\n<p>Read more about <a href=\"https://heptaconnect.io/guides/portal-developer/short-notation-for-flow-components/\">short notation for flow components</a>.</p>\n<h2>Preamble</h2>\n<p>No, the <strong>TL;DR</strong> is not a copy mistake from the <a href=\"https://heptaconnect.io/news/2021-06-21-symfony-dependency-injection/\">previous feed entry about dependency injection</a>.\nWe once more achieved to improve the developer experience by adding more tools to reduce your boilerplate code.\nSummarizing our <a href=\"https://heptaconnect.io/reference/adr/2021-06-17-flow-component-short-notation/\">ADR</a> you can now stop writing <strong>sections</strong> of code and start to write <strong>lines</strong> of code.\nPreviously you had to write:</p>\n<pre><code class=\"language-php\">&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace FooBar\\Emitter;\n\nuse FooBar\\Packer\\BottlePacker;\nuse FooBar\\Service\\ApiClient;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract;\n\nclass BottleEmitter extends EmitterContract\n{\n    private ApiClient $client;\n    \n    private BottlePacker $packer;\n    \n    public function __construct(ApiClient $client, BottlePacker $packer)\n    { \n        $this-&gt;client = $client;\n        $this-&gt;packer = $packer;\n    }\n\n    public function run(string $externalId, EmitContextInterface $context) : ?DatasetEntityContract\n    {\n        return $this-&gt;packer-&gt;pack($this-&gt;client-&gt;getBottleData($externalId));\n    }\n}\n</code></pre>\n<p>Sieve out the boilerplate lines and you have:</p>\n<pre><code class=\"language-php\">&lt;?php\n\ndeclare(strict_types=1);\n\nuse FooBar\\Packer\\BottlePacker;\nuse FooBar\\Service\\ApiClient;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\n\nFlowComponent::emitter(Bottle::class)-&gt;run(\n    fn (ApiClient $client, BottlePacker $packer, string $id) =&gt; $packer-&gt;pack($client-&gt;getBottleData($id))\n);\n</code></pre>\n<p>When this reminds you of Laravel routes and commands, you are right.\nThis is heavily inspired by Laravel's nature of quickly scribbling down some lines to get something big running.\nTo get an overview of the short notation and how to use it visit <a href=\"https://heptaconnect.io/guides/portal-developer/short-notation-for-flow-components/\">the documentation page</a>.</p>\n",
            "url": "https://heptaconnect.io/news/2021-07-12-short-notation/",
            "title": "Short notation for flow components",
            "summary": "Reduce the lines of code for connecting your API to HEPTAconnect",
            "date_modified": "2021-07-12T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-07-23-easy-batch/",
            "content_html": "<h2>TL;DR</h2>\n<p>Train in step-by-step. <br>\nRun in batches.</p>\n<p>Read more about the way how to batch in <a href=\"https://heptaconnect.io/guides/portal-developer/short-notation-for-flow-components/\">short notation for flow components</a> and flow components like <a href=\"https://heptaconnect.io/guides/portal-developer/emitter/\">emitter</a> and <a href=\"https://heptaconnect.io/guides/portal-developer/receiver/\">receiver</a>.</p>\n<h2>Batches and step by step runs</h2>\n<p>Every emitting or receiving flow component can improve on performance when data is processed in batches.\nIn general HEPTAconnect groups data into batches to allow the flow components to be able to act in reasonable batch sizes.\nThe documentation in the past only explained how to make a single step-by-step API interactions.\nRunning through a data transfer in such a sequential manner is due to its complexity better to outline its inner statements.\nThe flow component loops that unrolled the batches into single steps are now accessible for child classes to override.\nCompare the following real life examples how to receive manufacturer data to its successor within Shopware 6:</p>\n<pre><code class=\"language-php\">&lt;?php\n\nuse Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Manufacturer;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalAccess;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker;\n\nFlowComponent::receiver(Manufacturer::class)-&gt;run(static fn (\n    DalAccess $dal,\n    Manufacturer $manufacturer,\n    Unpacker\\ManufacturerUnpacker $unpacker\n) =&gt; $dal-&gt;createSyncer()-&gt;upsert('product_manufacturer', [$unpacker-&gt;unpack($manufacturer)])-&gt;flush());\n</code></pre>\n<pre><code class=\"language-php\">&lt;?php\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection;\nuse Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Manufacturer;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalAccess;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker;\n\nFlowComponent::receiver(Manufacturer::class)-&gt;batch(static fn (\n    DalAccess $dal,\n    TypedDatasetEntityCollection $manufacturers,\n    Unpacker\\ManufacturerUnpacker $unpacker\n) =&gt; $dal-&gt;createSyncer()-&gt;upsert('product_manufacturer', $manufacturers-&gt;map([$unpacker, 'unpack']))-&gt;flush());\n</code></pre>\n<p>There is basically no difference.\nYour project can make use of this today when you are in the lucky position to have a batch-ready API, and you've been following architectural patterns to use packer and unpacker services.</p>\n",
            "url": "https://heptaconnect.io/news/2021-07-23-easy-batch/",
            "title": "Easy batch just like step-by-step runs",
            "summary": "Convert your single runs into batch runs more easily and gain performance",
            "date_modified": "2021-07-23T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-08-10-new-documentation/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>New domain</li>\n<li>New style</li>\n<li>New search</li>\n<li>New diagrams</li>\n<li>New PDF export</li>\n</ul>\n<p>Maybe you already noticed it:\nWe have a beautiful new documentation website, and we think you will love it.\nOur new website is based on the material theme for MkDocs with some customizations and it's rocking a bunch of new and improved features.</p>\n<p>The HEPTAconnect documentation is now available under a new domain: <a href=\"https://heptaconnect.io/\">heptaconnect.io</a>.\nWe have moved from a subdomain under heptacom.de to a dedicated domain and we are also using the .io domain ending.</p>\n<p>Perhaps the most notable change are the stunning visuals.\nThe <a href=\"https://heptaconnect.io/\">main landing page</a> shows the HEPTAconnect logo and prominently advertises the four most important sections of the documentation.\nHave you noticed the glowing backdrop behind the cards when you hover over them?</p>\n<p>Speaking of sections:\nWe have restructured our content into different sections.\nMost of our existing content went into <a href=\"https://heptaconnect.io/guides/portal-developer/\">Portal Developer</a> and <a href=\"https://heptaconnect.io/reference/\">Reference</a>.\nThe sections Integrator and Administrator are completely new and bring different perspectives into the documentation.\nTruth be told, they are not finished yet.\nBut we have big plans to extend the documentation with new content for them, so stay tuned.</p>\n<p>And when we are already on the topic of staying tuned:\nWe noticed that most RSS readers don't update as frequently as we would like them to.\nSo starting from today we will additionally publish our blog entries on Twitter.\nSo if your RSS reader is giving you trouble, feel free to <a href=\"https://twitter.com/heptacom_gmbh\">follow us there</a>.</p>\n<p>Let's get back to the star of today's show:\nThe new documentation website has an amazing new search function.\nA big problem we had with the search on the old website was the small space where the search results would get crammed into.\nSearch results were nearly indistinguishable from one another rendering them downright useless.\nThe new search bar makes use of all the space it can get to give results that are actually helpful.</p>\n<p>If you are hyped to try it out, a good first search term would be &quot;Basic flow&quot;.\nThe first result will take you to a brand-new page with our <a href=\"https://heptaconnect.io/reference/general-resources/data-flows/basic-flow/\">new sequence diagrams</a> to visualize how data flows through HEPTAconnect.\nThose diagrams show both the perspective of a portal and the perspective of HEPTAconnect core components during an exploration, an emission and a reception in a basic flow.\nLet us know if they could help you to better grasp the big picture.</p>\n<p>And there is still more.\nMkDocs has another trick up its sleeve.\nThe entire documentation is available for download as a PDF file with a cover page and a linked table of contents.\nSo when your client demands a copy of the documentation, it's just one click away.\nTake a look on the left side of the footer.</p>\n<p>Last but not least, the switch from docsify to MkDocs means that our documentation is finally visible for Google and other search engines.\nSo hopefully you can soon find your answers even faster from your favourite search engine.</p>\n",
            "url": "https://heptaconnect.io/news/2021-08-10-new-documentation/",
            "title": "New Documentation",
            "summary": "Big changes to the docs! New domain, new search, new diagrams! Read everything you need to know here.",
            "date_modified": "2021-08-10T00:00:00.000Z",
            "author": {
                "name": "Julian Krzefski"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2021-12-07-http-handler-flow-component/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>New flow component: HTTP handler</li>\n</ul>\n<p>In the last news the new documentation structure and engine have been celebrated.\nNow we can suggest once again to read into the new pages about our new flow component: <a href=\"https://heptaconnect.io/guides/portal-developer/http-handler/\">HTTP handler</a>.\nThis new component already has some configuration which can be managed as administrator that can be read upon in the <a href=\"https://heptaconnect.io/guides/administrator/http-apis/\">HTTP APIs</a> page of the administrator section.</p>\n<h2>Underlying technology</h2>\n<p>We rely fully on <a href=\"https://www.php-fig.org/psr/psr-7/\"><code>PSR-7</code></a> and <a href=\"https://www.php-fig.org/psr/psr-17/\"><code>PSR-17</code></a>.\nUnfortunately <a href=\"https://www.php-fig.org/psr/psr-15/\"><code>PSR-15</code></a> does not fit into our just released HTTP handler structure.\nIt behaves similar to other flow components in terms of stacked processing, extensibility by portal extensions and integrations, ability to write definition in a short-notation and an object-oriented manner.</p>\n<h2>New flow options</h2>\n<p>In the past you had to be an integration to host an HTTP controller to create an event driven flow over HTTP messages.\nWith HTTP handlers at hand you can now use incoming web requests and transfer them into publications or already a direct emission.\nWe already use it in the Business Central portal to build an OAuth 2 authentication flow.\nThe following example shows how to convert an incoming request into a publication of external ids about new data that is ready to pick up.</p>\n<pre><code class=\"language-php\">use Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nFlowComponent::httpHandler('bottle')-&gt;post(static function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    PortalNodeKeyInterface $portalNodeKey\n): ResponseInterface {\n    $bottleIds = \\json_decode($request-&gt;getQueryParams()['bottle-ids']);\n\n    $bottleMappings = \\array_map(static fn (string $bottleId) =&gt; new MappingComponentStruct(\n        $portalNodeKey,\n        Bottle::class,\n        $bottleId\n    ), $bottleIds);\n\n    $this-&gt;publisher-&gt;publishBatch(new MappingComponentCollection($bottleMappings));\n\n    return $response-&gt;withStatus(201);\n});\n</code></pre>\n<p>Direct emission based flows can be created quickly when you already use <a href=\"https://heptaconnect.io/reference/glossary/#packer\">packers to pack</a> API data into HEPTAconnect entities.\nWith packers at hand you can use the request body, pass it into the packer and use the packed entity directly into the <a href=\"https://heptaconnect.io/guides/portal-developer/default-utilities/#directemissionflowcontract\">DirectEmissionFlow</a>.</p>\n",
            "url": "https://heptaconnect.io/news/2021-12-07-http-handler-flow-component/",
            "title": "HTTP handler flow component",
            "summary": "HTTP handlers for webhook, OAuth flows and hosting files",
            "date_modified": "2021-12-07T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2022-01-11-changelogs/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>Feature focussed changelogs</li>\n<li>Human-readable</li>\n<li>Machine-readable</li>\n<li>Guides for <a href=\"https://heptaconnect.io/guides/portal-developer/upgrade/\">portal developer</a> and <a href=\"https://heptaconnect.io/guides/integrator/upgrade/\">integrator</a>.</li>\n</ul>\n<p>With the release of version 0.7 we started to add changelogs.\nThese are important news and therefore reside in our <a href=\"https://heptaconnect.io/releases/\">news section</a>.\nThere you can find a human-readable and easy to browse version of the changelogs.\nSo with each upcoming release of HEPTAconnect you should check out the documentation about the new changes and get excited.</p>\n<h2>Why is that important to me?</h2>\n<p>Updating to the most recent version of HEPTAconnect is always a combination of:</p>\n<ul>\n<li>Oh, something new I want to use to write less code in the future</li>\n<li>Oh, something new I can adapt to improve performance or flexibility</li>\n<li>Oh, something broke, and I should check my tuned application as well</li>\n</ul>\n<p>So you can check your version of HEPTAconnect using <code>$ composer show heptacom/heptaconnect-\\*</code>, understand the news and compare.</p>\n<h2>How do I understand?</h2>\n<p>That is super easy as we write them in a non code-exclusive focussed view to explain the changes of the public API.\nWe are focussing on feature based logs so the generic changes of a <code>git diff</code> turns into a human understandable view on the change.\nThe <a href=\"https://keepachangelog.com/en/1.0.0/\">keep a changelog project</a> thinks alike, therefore we follow its guidelines for a good changelog.\nTo summarize: Every version has a clear title with a <a href=\"https://semver.org/spec/v2.0.0.html\">semantic version</a> and the release date.\nEach version has a section filled changes grouped by their classification of additions, changes, deprecations, removals, fixes and security fixes.</p>\n<p>Looking at the changelog lines you will see they always reveal quite technical information.\nWe add them to the messages to visualize a clear connection of features to code components.\nIt makes it easy to research for unique code components and understand why they have been changed.\nWhen we do package internal changes you won't see them as they probably won't bother you.\nDon't worry though, when we change e.g. database interactions this is often considered an internal change but still resides under the changes classification for e.g. resources usage reasons.</p>\n<h2>How do I compare?</h2>\n<p>You have to take every log and look up whether it affects your code changes as every log should contain enough technical reference.\nWhen you have a match you can understand the connected feature and apply the knowledge.</p>\n<p>The process sounds correct but tedious, right?\nWe thought so as well, so we decided to snoop around one step ahead again and had a look on how to automate this, so we all have less to do again.</p>\n<h2>How do I upgrade my code?</h2>\n<p>So we like our code a bit magical but still reasonable.\nAs we do it ourselves, we are aware how people can turn PHP into anything.\nTherefore, we can't provide an automatic upgrade yet, but we are working on a tool which either supports or fixes code automatically for you.\nWe prepared guides to do upgrades for <a href=\"https://heptaconnect.io/guides/portal-developer/upgrade/\">portal developers</a> and <a href=\"https://heptaconnect.io/guides/integrator/upgrade/\">integrators</a> as well for <a href=\"https://heptaconnect.io/guides/contributor/changelog/\">contributors</a> which we will both upgrade regularly.</p>\n",
            "url": "https://heptaconnect.io/news/2022-01-11-changelogs/",
            "title": "Changelogs for safer and understandable updating",
            "summary": "Updating your project would be a mess without proper changelogs",
            "date_modified": "2022-01-11T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2022-04-19-code-documentation/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>Easy queryable documentation within source code</li>\n<li>Documentation on interfaces and contracts</li>\n</ul>\n<p>With the release of 0.9 we started to document every interface and contract.\nThis way we ensure clear communication how to use the interface as an API consumer and as an API provider.</p>\n<p>Adding documentation on source code is a delicate discussion topic in most developer conversations.\nWe evaluated our experience with other documentations and were (and still are) really happy with the approach of the PSR composer packages.\nWhen looking at e.g. the <code>\\Psr\\Log\\LoggerInterface</code>, there is a common description at the interface and a short hint on every method.\nIn everyday usage it was nice to use a logger instance, navigate to the interface symbol or one of the methods and see right away how the intended use is.\nA similar pattern can be seen in the documentation stubs PHPStorm ships for native PHP functions.\nThis kept the developer in the IDE without losing their focus.</p>\n<p>We see the possibility that these comments may go out of date.\nTo prevent this from happening too often, we decided to only write expected usage and possible implementation hints.\nWith this rule of thumb we are not fixed to a certain implementation that may change over time.\nInstead, we use the intended use case as comment when the component was introduced so everyone shares the same expectation.</p>\n",
            "url": "https://heptaconnect.io/news/2022-04-19-code-documentation/",
            "title": "Documentation at source code level",
            "summary": "Providing documentation on a point that is quickly reached",
            "date_modified": "2022-04-19T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2022-04-26-release-0-9-0-0/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>Fast file transfers</li>\n<li>Flow component stacking re-imagined with more configuration</li>\n<li>Improved performance and stability for management storage</li>\n<li>Flexible portal node configurations by the integration environment</li>\n<li>Improved API Design\n<ul>\n<li>Feature-rich HTTP client</li>\n<li>More quality logging</li>\n<li>Reduction of technical debt</li>\n<li>Code documentation</li>\n</ul>\n</li>\n<li>Peek into the future for administrators</li>\n</ul>\n<h2>Release 0.9</h2>\n<p>Two weeks ago we released the first 0.9 version.\nTo be more specific it is 0.9.0.0 and so the first version following the new version scheme described in <a href=\"https://heptaconnect.io/reference/adr/2022-01-24-semver-with-generation-version/\">this ADR</a>.\nUpdated changelogs for your updating strategy can be found in the <a href=\"https://heptaconnect.io/releases/\">release news section</a>.\nLet's get more detailed and hydrate the TL;DR above.</p>\n<h3>File references</h3>\n<p>The file references are a new way to transfer files with the focus on availability via HTTP and reduction of I/O operations in the HEPTAconnect installation.\nThe datasets and portals have been updated accordingly to use the new performant transport.\n<a href=\"https://heptaconnect.io/guides/portal-developer/patterns/transfer-file-reference-by-public-url/\">See a sample usage here</a>.</p>\n<h3>Flow component stacks</h3>\n<p>Flow components are now loaded deferred and only grouped when used.\nThis allows portal extensions to provide as much flexibility as portals in terms of flow components.\nNew flexibilities are also given to portal extension developers and administrators as portal extension can now be deactivated on a stack and declared as optional.</p>\n<h3>Normalization of storage actions</h3>\n<p>We restructured the internal management storage handling to ensure the stability and performance it deserves.\nThis includes a new package full of test scenarios against the storage base interfaces to allow also pre-built tests for any future storage provider.\n<a href=\"https://heptaconnect.io/reference/adr/2021-09-25-optimized-storage-actions/\">Read more here</a>.</p>\n<h3>Flexible portal node configuration</h3>\n<p>New utilities for integrators are now available to build automatically assigned portal node configurations by patterns.\nThis enables various configurations sources like JSON files from hosting services or environment variables.\n<a href=\"https://heptaconnect.io/guides/integrator/portal-node-configuration/\">Read more here</a>.</p>\n<h3>HTTP client</h3>\n<p>We provide a new service for portals to make HTTP API usage a step easier.\nThe PSR-18 compatible <a href=\"https://heptaconnect.io/reference/portal-developer/service/http-client-contract/\"><code>HttpClientContract</code></a> is preconfigured to throw exceptions for 4XX and 5XX status codes, add missing headers, follow redirects and retry in case of an error or rate limit.</p>\n<h3>Logging</h3>\n<p>When a flow component is put into the log context it will be swapped out with its code origin.\nThis supports navigation to the source of an error, that is not identified by an exception.</p>\n<p>All our storage implementations start to add some form of unique identifier to the request, so it can be found more easily in the source code when found in logs.</p>\n<p>Even more log messages we write and exceptions we throw have unique identifiers for quick search in the code and in the online changelog.</p>\n<p>Jobs have a state history that can be inspected for processing and performance analysis.</p>\n<h3>Dependency updates</h3>\n<p>The dependency version range is changed to keep everything up to date.\nThis affects <code>doctrine/dbal</code>, <code>shopware/core</code>, <code>ramsey/uuid</code> and <code>dragonmantank/cron-expression</code> as library usage has been updated to match known deprecations and raised or removed.\nRead more about its details <a href=\"https://heptaconnect.io/releases/\">in the changelogs</a>.</p>\n<h3>Developer Experience</h3>\n<p>As HEPTAconnect is looking to achieve a state-of-the-art experience on using our API, we improved our API design by ensuring to <a href=\"https://heptaconnect.io/reference/adr/2022-03-02-final-classes/\">use <code>final</code> more frequently</a> without removing extensibility.\nTo ensure code documentation browsing is easy, we add it to a <a href=\"https://heptaconnect.io/reference/adr/2022-01-05-code-documentation/\">lot of places within the code</a>.\nEven small subtleties are taken into account like <code>$this</code> in short notation flow components now refers to the wrapping object-oriented flow component.</p>\n<h3>Administrators</h3>\n<p>Everyone managing an HEPTAconnect instance on setup can now use <code>--bidirectional</code> on <code>heptaconnect:router:add</code> to also create a route in the reverse direction.\nMore CLI commands are supporting JSON output for easier scripting use.\nSpoiler alert: There is a huge change coming to raise the quality bar for administrator tools in the not so distant future.</p>\n<h2>Future</h2>\n<p>Follow the news section by subscribing to the RSS feeds:</p>\n<ul>\n<li><a href=\"https://heptaconnect.io/news/rss2.xml\">RSS</a></li>\n<li><a href=\"https://heptaconnect.io/news/atom1.xml\">Atom</a></li>\n<li><a href=\"https://heptaconnect.io/news/json1.json\">JSON</a></li>\n</ul>\n<p>Or follow us on <a href=\"https://twitter.com/heptacom_gmbh\">Twitter</a> to get more insights on the briefly touched topics in here in the future.</p>\n",
            "url": "https://heptaconnect.io/news/2022-04-26-release-0-9-0-0/",
            "title": "Release 0.9.0.0",
            "summary": "Fast file transfers, storage stability, configuration by environment variables, improved API design",
            "date_modified": "2022-04-26T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2022-05-17-exception-and-log-message-codes/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>Log messages and exceptions have unique codes</li>\n<li>Documentation explains these codes</li>\n<li>These are not correlation identifiers</li>\n</ul>\n<h2>Unique codes</h2>\n<p>Since the version of 0.8 we add unique codes to exceptions and log messages.\nThe full explanation can be read in <a href=\"https://heptaconnect.io/reference/adr/2021-09-06-exception-and-log-message-codes/\">this ADR</a>.</p>\n<p>In short: these unique codes are quickly looked out for.\nEither online in our documentation or your IDE.\nThey describe a point in the source code and keeps consistent in meaning even after an update.</p>\n<h2>Documenting the codes</h2>\n<p>Although we use the unique codes for log messages and exceptions, you will likely only look them up because you are a first-responder to an issue of your system.\nSo whenever you get a code from your log message's metadata you can just look them up in the search of our documentation.\nIn general, you get a single hit within changelogs when the code has been introduced.\nThere can be more hits, when the code has been moved to a different place or removed.\nIn this scenario you can match by your installed HEPTAconnect version to find your issue.\nAs these codes are part of our public API and are in the changelogs, you will find a <a href=\"https://heptaconnect.io/news/2022-01-11-changelogs/\">technical reference and a human-readable meaning</a> to it.</p>\n<p>The real life scenario could now be something like this:</p>\n<p>When there is the exception code 123 in your logs, and you find this message in the changelogs:</p>\n<blockquote>\n<p>Add code <code>123</code> in <code>\\Heptacom\\HeptaConnect\\TechnicalReference::doSomething</code> when JSON configuration file is invalid JSON.</p>\n</blockquote>\n<p>And someone recently edited a JSON file, you can combine these hints and find a solution on your own.\nAs the changelogs are shipped with the code, you can also find this hint with a <code>grep</code> call in your installation.\nWhen you search the files, you will also find that single piece of code that triggered the exception right away.</p>\n<p>This will make first-responders more helpful and independent.</p>\n<h2>Correlation identifiers</h2>\n<p>When we talk about codes in log messages, we should point out that these are not correlation identifiers.\nCorrelation identifiers could only be queried in the HEPTAconnect installation as they identify a single situation like a specific web request or a job run.</p>\n<p>To keep posted with our news, that will definitely contain information on correlation ids once they are released, subscribe our feeds:</p>\n<ul>\n<li><a href=\"https://heptaconnect.io/news/rss2.xml\">RSS</a></li>\n<li><a href=\"https://heptaconnect.io/news/atom1.xml\">Atom</a></li>\n<li><a href=\"https://heptaconnect.io/news/json1.json\">JSON</a></li>\n</ul>\n<p>Or follow us on <a href=\"https://twitter.com/heptacom_gmbh\">Twitter</a>.</p>\n",
            "url": "https://heptaconnect.io/news/2022-05-17-exception-and-log-message-codes/",
            "title": "Exception and log messages in action",
            "summary": "First-responders looking into logging facilities will love these",
            "date_modified": "2022-05-17T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2022-06-07-file-references/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>Don't store any files to transfer publicly hosted content</li>\n<li>Tunnel FTP access (and other protocols) through HTTP for more versatile usage</li>\n<li>Avoid obsolete I/O operations whenever possible</li>\n</ul>\n<p>With the release of 0.9 we introduce a new feature for portal developers to vastly improve performances of file transfers.\nPreviously, transferring files always required to write them to an intermediate storage and later read them from this storage again.\nThe new <strong>FileReferences</strong> will respect the source of a file and choose the optimal transfer method accordingly.\nA portal developer can choose from three available file sources:</p>\n<ol>\n<li>Public URL\n<ul>\n<li>An HTTP request with the GET method will be responded with the file contents.\nNo authentication will be performed.</li>\n</ul>\n</li>\n<li>HTTP Request\n<ul>\n<li>This HTTP request will be responded with the file contents.\nEvery aspect of the request can be customized.</li>\n</ul>\n</li>\n<li>File contents\n<ul>\n<li>The raw file contents are provided directly.\nThis is the only source that leads to I/O operations in the intermediate storage.</li>\n</ul>\n</li>\n</ol>\n<p>These three strategies already cover many use cases.\nHere are some example usages for each source type:</p>\n<pre><code class=\"language-php\">use Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract;\nuse League\\Flysystem\\Filesystem;\nuse Psr\\Http\\Message\\RequestFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\n\nFlowComponent::explorer(Media::class, function (\n    FileReferenceFactoryContract $fileReferenceFactory\n): iterable {\n    $publicUrl = 'https://picsum.photos/seed/php/300/300';\n    \n    $fileReference = $fileReferenceFactory-&gt;fromPublicUrl($publicUrl);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('ad9e5b8a46364e019d9b3045b5172623');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});\n\nFlowComponent::explorer(Media::class, function (\n    FileReferenceFactoryContract $fileReferenceFactory,\n    RequestFactoryInterface $requestFactory,\n    StreamFactoryInterface $streamFactory\n): iterable {\n    $request = $requestFactory\n        -&gt;createRequest('POST', 'https://private-image-server.test/api/download-image/28664337703749c49af4bf198e94c396')\n        -&gt;withHeader('Authorization', 'Basic aGVwdGFjb25uZWN0OmlzIGNvb2w=')\n        -&gt;withBody($streamFactory-&gt;createStream(\\json_encode([\n            'foo' =&gt; 'bar'\n        ])));\n\n    $fileReference = $fileReferenceFactory-&gt;fromRequest($request);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('ad9e5b8a46364e019d9b3045b5172623');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});\n\nFlowComponent::explorer(Media::class, function (\n    FileReferenceFactoryContract $fileReferenceFactory,\n    Filesystem $filesystem\n): iterable {\n    $fileContents = $filesystem-&gt;read('data/images/a2ef9e0ef17e4b3585041ea36c4cde13/1.jpg');\n\n    $fileReference = $fileReferenceFactory-&gt;fromContents($fileContents);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('ad9e5b8a46364e019d9b3045b5172623');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});\n</code></pre>\n<p>We recommend to avoid using the source type &quot;File contents&quot;, because it leads to I/O operations and preventing those will greatly improve performance.\nIn an effort to prevent usages of &quot;File contents&quot; and therefore improve performance, you can utilize <strong>HTTP handlers</strong> to tunnel file downloads through HEPTAconnect.\nThe idea is to generate a URL to be used as &quot;Public URL&quot; file source.\nThis URL points to an HTTP handler that will perform the file download and return its contents as its response body.\nTake a look at the new article <a href=\"https://heptaconnect.io/guides/portal-developer/patterns/transfer-files-from-ftp-server/\">Send files from an FTP server</a> to learn more about this topic and see our example code.</p>\n",
            "url": "https://heptaconnect.io/news/2022-06-07-file-references/",
            "title": "File reference for direct and fast file transfer",
            "summary": "Tunnel file transfer and make best use of external APIs",
            "date_modified": "2022-06-07T00:00:00.000Z",
            "author": {
                "name": "Julian Krzefski"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2022-11-29-production-template/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>New repository: Production template</li>\n<li>Kickstart your own projects</li>\n<li>More documentation coming soonâ„¢</li>\n</ul>\n<h2>Template repository for production-ready integrations</h2>\n<p>HEPTAconnect is (at its core) completely framework-agnostic.\nThat means, it can virtually be integrated into any kind of PHP-based application.\nThis approach makes HEPTAconnect highly versatile, but it also requires integrating HEPTAconnect into an application to provide a runtime environment.</p>\n<p>We aim to make setting up HEPTAconnect projects as simple as possible, so we created a template repository to kickstart your projects.\nThis repository is designed to be forked and then adjusted to your requirements.\nHere you can check out our <a href=\"https://github.com/HEPTACOM/heptaconnect-production\">HEPTAconnect production template repository</a> on GitHub and fork it yourself.\nYou can also use <code>composer create-project</code> to start your new project.</p>\n<pre><code class=\"language-sh\">composer create-project heptaconnect/production my-project -s dev\n</code></pre>\n<p>At this point you should take a look at the <a href=\"https://github.com/HEPTACOM/heptaconnect-production/blob/master/README.md\"><code>README.md</code></a> file.\nThere you will find a quick introduction and useful first steps.</p>\n<p>This repository template is our recommendation to create new projects with HEPTAconnect.\nWe will continue to maintain it to stay up to date with the latest HEPTAconnect releases.\nWe also use this repository internally to kickstart our own HEPTAconnect integrations.</p>\n<h2>Future</h2>\n<p>Currently, the production template depends on <code>shopware/core</code> for some dev-ops utilities and uses it as runtime environment for HEPTAconnect.\nWhile this is not really a problem, we aim to be fully independent from <code>shopware/core</code> to trim down on our required composer packages.\nWe have that planned for version 0.10 of HEPTAconnect.</p>\n<p>Furthermore, we plan to release more documentation content about the production template.\nAs of now, the <code>README.md</code> file inside the repository is the only documentation for it.\nMore detailed documentation that covers more use cases will follow soonâ„¢ in the <a href=\"https://heptaconnect.io/guides/integrator/\">Integrator section on the HEPTAconnect documentation website</a>.</p>\n",
            "url": "https://heptaconnect.io/news/2022-11-29-production-template/",
            "title": "New repository: HEPTAconnect production template",
            "summary": "Kickstart your new HEPTAconnect integration projects",
            "date_modified": "2022-11-29T00:00:00.000Z",
            "author": {
                "name": "Julian Krzefski"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2023-02-14-http-middleware/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>Support for PSR-15 middlewares for HTTP handlers</li>\n<li>PSR-15 is not enough, so we add HTTP middlewares for HTTP clients as well</li>\n</ul>\n<h2>HTTP handlers</h2>\n<p>With HTTP handlers we already solved different challenges in the past:</p>\n<ul>\n<li>We built visual setup wizards, which are able to handle OAuth2 authorization flows.</li>\n<li>We built development tools, which we reuse in our own projects.</li>\n<li>We react to webhooks and we build a lot of other stuff.</li>\n</ul>\n<p>So many use cases, where we could use an abstraction layer to share common code efficiently.\nGood news: <a href=\"https://www.php-fig.org/psr/psr-15/\"><code>PSR-15</code></a> solves this problem conceptually.</p>\n<p>With 0.9.2 we added support for PSR-15 middlewares for HTTP handlers.\nThis means, you can add middlewares to your portal, which are automatically applied to all inbound HTTP requests and responses.\nUsing this very powerful concept allows you to add custom logic like authorization, logging, caching, etc. to your portal.</p>\n<h2>HTTP clients</h2>\n<p>PSR-15 is unfortunately not made for HTTP clients.\nThe PSR-7 HTTP client can already have shared common code with the use of decorators, which are very similar to PSR-15 middlewares.\nUsing these decorators is a good and known strategy but it is not as easy to use as the automatically applied PSR-15 middlewares.\nTherefore, we created our own middleware interface for HTTP clients, that is similar to PSR-15 middleware specification.</p>\n<p>These two middleware interfaces will support you to build your own helpful tools for your project.\nHave a look at the documentation pages for the <a href=\"https://heptaconnect.io/guides/portal-developer/http-handler-middleware/\">PSR-15 middleware interface</a> and the <a href=\"https://heptaconnect.io/guides/portal-developer/http-client-middleware/\">HTTP client middleware interface</a> to learn more about the interfaces and how to use them.</p>\n",
            "url": "https://heptaconnect.io/news/2023-02-14-http-middleware/",
            "title": "HTTP middlewares for clients and servers",
            "summary": "Interception points for HTTP requests and responses in every direction",
            "date_modified": "2023-02-14T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        },
        {
            "id": "https://heptaconnect.io/news/2023-08-15-code-execution-in-repl/",
            "content_html": "<h2>TL;DR</h2>\n<ul>\n<li>REPLs allow code execution without prior writing and deployment</li>\n<li><a href=\"https://psysh.org/\">psysh</a> is a ready to use REPL for PHP</li>\n<li>Once you <code>composer require psysh</code> you can use <code>heptaconnect:repl</code>, which integrates psysh into HEPTAconnect</li>\n</ul>\n<h2>What is a REPL?</h2>\n<p>REPL stands for Read-Eval-Print-Loop.\nIt is a common pattern in programming languages to provide a way to execute code without prior writing and deployment.\nYou are likely familiar with this pattern from the browser console or the <code>php -a</code>/<code>php --interactive</code> command.\nThe <code>php -a</code> command is a REPL for PHP, that is shipped with the PHP interpreter itself.\nTry it out yourself by simply typing <code>php -a</code> into your terminal and execute a command like <code>var_dump(new DateTime())</code>.\nIt will print the current date and time.\nThe execution did not stop though.\nYou can execute multiple commands in a row now by entering a new command.\nThis is where the loop comes in.\nIt will keep executing commands until you exit the REPL by typing <code>exit</code> or pressing <code>Ctrl+D</code>.</p>\n<h2>What is psysh?</h2>\n<p>The php interactive mode is a very simple REPL, that does not provide any additional features you are used to from IDEs or other development tools.\n<a href=\"https://psysh.org/\">psysh</a> is a REPL for PHP written in PHP itself and shipped as a standalone package, that can be used as a replacement for <code>php --interactive</code>.\nIn comparison, it is a very powerful REPL, that provides a lot of features, that you know from your IDE.\nYou can look up code behind classes, read documentation, autocomplete code and much more.\nIt is really versatile and that is why we integrated it into HEPTAconnect.</p>\n<h2>How to use psysh with HEPTAconnect?</h2>\n<p>Once you <code>composer require psysh</code> you can use the <code>heptaconnect:repl</code> command, which integrates psysh into HEPTAconnect.\nIt will automatically load a portal node container of your choice and provide you with a REPL, that is already configured to work with that specific portal node.</p>\n<p>As example you can paste the following code into the REPL and execute it:</p>\n<pre><code class=\"language-php\">service(\\Psr\\Log\\LoggerInterface::class)-&gt;info('Hello World');\n</code></pre>\n<p>This will log the message <code>Hello World</code> to the portal node specific logger.\nYou can access any service out of the portal node container and execute any code you want.</p>\n",
            "url": "https://heptaconnect.io/news/2023-08-15-code-execution-in-repl/",
            "title": "Code execution in REPL",
            "summary": "Development and production intervention sometimes need a REPL",
            "date_modified": "2023-08-15T00:00:00.000Z",
            "author": {
                "name": "Joshua Behrens"
            }
        }
    ]
}
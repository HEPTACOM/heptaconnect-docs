{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HEPTAconnect","text":"<p>Your framework to connect. Modular \u2713 Scalable \u2713 Open Source \u2713</p>"},{"location":"#portal-development","title":"Portal Development","text":"<p>You are developing a connector that should be plugged into HEPTAconnect? Congratulations you are a portal developer. Follow our portal developer guide to get to know the basics as well as the hot details.</p>"},{"location":"#playground","title":"Playground","text":"<p>To the previous cases you always had the thought \"I am not there yet\"? You are looking for the playground to get an overview about the overall project of HEPTAconnect.</p> <p>This software is part of HEPTACOM solutions for medium and large enterprises.</p> <p>In the past we have enabled numerous integrations of third-party systems for Shopware. Throughout various projects it has become our specialty to connect Shopware with different ERP, CRM or PIM systems used in middle class and enterprise businesses. But crafting the entire solution from scratch every time has proven to be both time consuming and to some extend repetitive. That is the reason why we wanted to create a common framework that makes connecting systems easier.</p> <p>A lot of work went into the concept of this product. We wanted this foundation to go beyond just Shopware, so we designed it to be system agnostic. This means that the core of HEPTAconnect can be run in basically any PHP application. We also provide bridges to popular systems, to reduce redundant code throughout different projects.</p>"},{"location":"#what-can-it-do","title":"What can it do?","text":"<p>Simply put, HEPTAconnect can speed up the development of your connector to external systems. By providing a normalized workflow, it lets you focus on the important part of the connector right from the start. You only need to implement the actual interaction with the external data source and configure some data routes.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>The basic idea of HEPTAconnect is to decouple adapters for different systems from each other. One adapter (we call these \"portals\") doesn't know anything about another one. This makes it possible for platform providers to develop a portal for their platform and distribute it in a modular way. If you\u2018re lucky, every system you want to bring together already has an existing portal written for them.</p> <p>Of course this can only ever work, if all the portals speak a common language. So we provide an abstraction for various types of information and group them into data sets. There are multiple data sets available for different applications and portals can choose to support them. If e.g. a portal for Shopware and a portal for Dynamics 365 Business Central both support the ecommerce data set, they are compatible and can immediately exchange some data.</p>"},{"location":"#what-if-two-portals-dont-support-the-same-data-sets","title":"What if two portals don't support the same data sets?","text":"<p>If two portals don't share a common supported data set, they are incompatible by normal means. This changes however, when you provide an intermediate portal to convert data from one type to another. These intermediate portals are called \"morphers\". Technically a morpher is no different that an ordinary portal except its unique job of morphing data from one type to another one. This makes it possible to connect any portal with any other portal simply by creating a conversion layer between them.</p>"},{"location":"#is-it-scalable","title":"Is it scalable?","text":"<p>The backbone of HEPTAconnect is a message queue. This means for any object that is transfered there is a job waiting to be executed by a worker process. Our tests show a linear scalability when adding more worker processes. Essentially it depends on the number of CPU cores you throw at it. So yes, HEPTAconnect scales really well.</p>"},{"location":"#where-can-i-sign-up","title":"Where can I sign up?","text":"<p>Drop us a mail to info@heptacom.de and ask your questions or choose one of the following news feed formats: * Twitter * RSS * Atom * JSON</p>"},{"location":"#contribution","title":"Contribution","text":"<p>You are working on a core feature? Interested in building a HEPTAconnect runtime for WordPress? You are looking to understand what happens behind the curtains and will follow the contribution guide.</p>"},{"location":"guides/administrator/","title":"Administer HEPTAconnect","text":"<p>This is the place to learn about commands and analytical methods to work with a HEPTAconnect instance.</p>"},{"location":"guides/administrator/#portal-nodes","title":"Portal nodes","text":"<p>Learn what portals and portal nodes are and how to configure them to work your way.</p>"},{"location":"guides/administrator/#data-routing","title":"Data routing","text":"<p>Learn how to connect the data routes the way the data shall flow.</p>"},{"location":"guides/administrator/#instance-status","title":"Instance status","text":"<p>Understand how well your HEPTAconnect instance performs and detect issues.</p>"},{"location":"guides/administrator/#http-apis","title":"HTTP APIs","text":"<p>Manage and investigate into hosted HTTP endpoints by portals.</p>"},{"location":"guides/administrator/#filesystem","title":"Filesystem","text":"<p>Portals can store files on disk. Learn how to integrate network storages.</p>"},{"location":"guides/administrator/#logs","title":"Logs","text":"<p>Detect where errors happen and track them down to their origin. </p>"},{"location":"guides/administrator/filesystem/","title":"Filesystem","text":"<p>Next to data moved between portal nodes, there are also files on disk, that count as transaction data. Ensure to back up and store this data to be accessible from all app servers.</p>"},{"location":"guides/administrator/filesystem/#locations","title":"Locations","text":"<p>When the development team integrated a non-standard filesystem storage there are probably setup notes about it. Otherwise, the bridge storage fallback is used, which is always a subdirectory within the project directory. See details about the bridges below.</p>"},{"location":"guides/administrator/filesystem/#sample-configurations","title":"Sample configurations","text":""},{"location":"guides/administrator/filesystem/#shopware-6-bridge","title":"Shopware 6 Bridge","text":"<p>The Shopware 6 bridge places files in <code>&lt;instance-dir&gt;/files/plugins/heptaconnect_bridge_shopware_platform/</code> with a subdirectory for each portal node.</p> <pre><code>&lt;system-root&gt;\n\u2514\u2500\u2500 \u2026\n    \u2514\u2500\u2500 &lt;instance-dir&gt;\n        \u2514\u2500\u2500 files\n            \u2514\u2500\u2500 plugins\n                \u2514\u2500\u2500 heptaconnect_bridge_shopware_platform\n                    \u251c\u2500\u2500 &lt;portal-node-1&gt;\n                    \u251c\u2500\u2500 &lt;portal-node-2&gt;\n                    \u2514\u2500\u2500 &lt;portal-node-3&gt;</code></pre> <p>If no changes are done in the integration, you can still move the data outside of this directory. You can replace a directory with a symbolic link to a directory, that suits better for storage of transaction data. When used with Docker, the directory <code>&lt;instance-dir&gt;/files/plugins/heptaconnect_bridge_shopware_platform/</code> is best a Docker volume. When a network storage shall be used, operating system tools like FUSE can be used to mount network storages like FTP and SMB.  </p>"},{"location":"guides/administrator/http-apis/","title":"HTTP APIs","text":"<p>HEPTAconnect itself and portals expose HTTP endpoints for various actions. To ensure correct hosting and exposure of these endpoints you can read everything you need in here.</p>"},{"location":"guides/administrator/http-apis/#base-url","title":"Base URL","text":"<p>The bridges define the integration of HEPTAconnect in the surrounding application it got embedded into. To see which base URL is used by HEPTAconnect you can use the command <code>heptaconnect:config:base-url:get</code>. When it does not match the expectations you can use the command <code>heptaconnect:config:base-url:set</code> to change it.</p>"},{"location":"guides/administrator/http-apis/#endpoint-listing","title":"Endpoint listing","text":"<p>Portals can resolve the absolute URLs for their registered endpoints. There is the command <code>heptaconnect:http-handler:list-handlers</code> to display the registered endpoints. The output looks like this:</p> <pre><code> \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  portal-node   path          url\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  bottle        hello-world   http://example.com/api/heptaconnect/flow/bottle/http-handler/hello-world\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014</code></pre>"},{"location":"guides/administrator/http-apis/#enabled-and-disabling-handlers","title":"Enabled and disabling handlers","text":"<p>By default, every HTTP handler is enabled. In a scenario where the web activity needs to be disabled, you can use <code>heptaconnect:http-handler:set-configuration bottle hello-world enabled false</code> to set the handler's enabled configuration on path <code>hello-world</code> for portal node <code>bottle</code> to deactivate it. In a similar way you can look up the enabled configuration: <code>heptaconnect:http-handler:get-configuration bottle hello-world enabled</code>.</p>"},{"location":"guides/administrator/http-apis/#debugging","title":"Debugging","text":"<p>For investigation purposes you can dump the HTTP requests and responses of the HTTP handlers. To do so you can use the configuration key <code>dump-sample-rate</code> to set the sampling rate. The expected value is an integer between 0 and 100. By default, the sampling rate is set to 0, which means no requests are dumped. To dump all requests you can set the sampling rate to 100. E.g. to set the configuration to 3/4 of the requests get recorded you can use the command <code>heptaconnect:http-handler:set-configuration bottle hello-world dump-sample-rate 75</code>. The dumped requests are stored on filesystem next to your log files.</p>"},{"location":"guides/administrator/logs/","title":"Logs","text":"<p>Log messages are the most detailed way to get into the actions that happen in the HEPTAconnect instance at close to real time. Only debugging into it provides more details. Watch the following sources for changes and get informed about the most detail info you can get.</p>"},{"location":"guides/administrator/logs/#locations","title":"Locations","text":"<p>When the development team integrated a non-standard logging facility there are probably setup notes about it. Otherwise, the bridge logging fallback takes action, logs into files and the following paragraphs apply.</p>"},{"location":"guides/administrator/logs/#files","title":"Files","text":"<p>File logs contain the most different message types and should be the first choice of investigation. The log file locations may vary as they depend on the integration your instance uses. Common locations to check:</p> <pre><code>&lt;system-root&gt;\n\u251c\u2500\u2500 \u2026\n\u2502   \u2514\u2500\u2500 &lt;instance-dir&gt;\n\u2502       \u251c\u2500\u2500 var\n\u2502       \u2502   \u2514\u2500\u2500 log\n\u2502       \u2502       \u2514\u2500\u2500 heptacom_heptaconnect_*.log\n\u2502       \u2514\u2500\u2500 storage\n\u2502           \u2514\u2500\u2500 logs\n\u2502               \u2514\u2500\u2500 heptacom_heptaconnect_*.log\n\u2514\u2500\u2500 var\n    \u2514\u2500\u2500 log\n        \u2514\u2500\u2500 application\n            \u2514\u2500\u2500 heptacom_heptaconnect_*.log</code></pre>"},{"location":"guides/administrator/logs/#database","title":"Database","text":"<p>HEPTAconnect provides an entity-centered database table to store entity related exceptions. You can find it in your instance database by the name <code>heptaconnect_mapping_error_message</code>. It is used to store error messages that can be connected to certain items.</p>"},{"location":"guides/administrator/logs/#contents","title":"Contents","text":""},{"location":"guides/administrator/logs/#files_1","title":"Files","text":"<p>Log files contain timestamps, log level, component names (e.g. EmitterStackBuilder, ExplorationActor), messages and unique codes. Depending on the message you have additional context like primary keys. When a log message is issued from a portal the message is prefix with the portal node key (aliases are supported). Unique log message are part of the error origin finding process. You can read more in a news entry and this ADR about it.</p>"},{"location":"guides/administrator/logs/#database_1","title":"Database","text":"<p>The database table contains timestamps, portal node keys, mapping node keys, message, exception type, exception stacktrace for a complete exception stack. As the database table only contains exceptions there is no need of a log level.</p>"},{"location":"guides/administrator/portal-node/","title":"Portal nodes","text":"<p>Portal nodes are the data turning points in an HEPTAconnect instance. This is where the magic happens. Multiple nodes of a single portal can exist next to each other and connect to different types and instances of APIs.</p>"},{"location":"guides/administrator/portal-node/#how-to-create-portal-nodes","title":"How to create portal nodes","text":"<p>Portal nodes are instances of different portals. A portal is the set of code that is used to transform common HEPTAconnect structures from and into data source specific structures. When a portal node is created it can now receive configuration to access the data source and can be used for setting up data routes. At first the list of portals should be queried using the <code>heptaconnect:portal:list</code> command to see what kind of portal nodes can be created. The output can look like this: <pre><code>Portals\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n  class                                                                    \n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n  Heptacom\\HeptaConnect\\Integration\\Filter\\Portal\n  Heptacom\\HeptaConnect\\Integration\\Morph\\Portal\n  Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Portal\n  Heptacom\\HeptaConnect\\Portal\\MayanEdms\\Portal\n  Heptacom\\HeptaConnect\\Portal\\Shopware5\\Portal\n  Heptacom\\HeptaConnect\\Portal\\Zammad\\Portal\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014</code></pre></p> <p>The command <code>heptaconnect:portal-node:add</code> is used to instantiate a node of a specific portal.</p> <pre><code>bin/console heptaconnect:portal-node:add 'Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Portal'</code></pre> <p>It also allows to create a portal node with a rememberable alias as well:</p> <pre><code>bin/console heptaconnect:portal-node:add `Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Portal` shopware_local</code></pre> <p>As output of the command you will receive the created primary key of the portal node which often looks like this <code>PortalNode:01234567890abcdef01234567890abcd</code>. The portal node key and an assigned alias can be used later on in other calls when you create data routes or inform yourself about the status of a portal node.</p>"},{"location":"guides/administrator/portal-node/#how-to-configure-portal-nodes","title":"How to configure portal nodes","text":"<p>When the development team integrated additional configuration sources there are probably setup notes about it. This might invalidate some of the following samples.</p> <p>Portal nodes often need API credentials or filenames to operate. To read the initial configuration the command <code>heptaconnect:portal-node:config:get</code> is used. Its output is json and can either be a single value or the complete configuration set:</p> <pre><code>bin/console heptaconnect:portal-node:config:get PortalNode:01234567890abcdef01234567890abcd --pretty\nbin/console heptaconnect:portal-node:config:get shopware_local --pretty</code></pre> <pre><code>{\n    \"dal_indexing_mode\": \"none\"\n}</code></pre> <p>or</p> <pre><code>bin/console heptaconnect:portal-node:config:get PortalNode:01234567890abcdef01234567890abcd dal_indexing_mode`\nbin/console heptaconnect:portal-node:config:get shopware_local dal_indexing_mode`</code></pre> <pre><code>none</code></pre> <p>This displays the information of the indexing mode of the underlying API client. A similar command can be used to change this configuration <code>heptaconnect:portal-node:config:set</code>:</p> <pre><code>bin/console heptaconnect:portal-node:config:set PortalNode:01234567890abcdef01234567890abcd dal_indexing_mode queue`\nbin/console heptaconnect:portal-node:config:set shopware_local dal_indexing_mode queue`</code></pre> <p>As we are using JSON as serialization it is convenient for automated setups.</p>"},{"location":"guides/administrator/portal-node/#further-reading","title":"Further reading","text":"<p>After you set up multiple portal nodes you can use them in data routing and setup status tracking.</p>"},{"location":"guides/administrator/routing/","title":"Routing","text":"<p>Routing is a setup once configuration step right after you created and configured a portal node. Creating routes is a crucial step to control the data flow. It defines which data is allowed to go in which direction.</p>"},{"location":"guides/administrator/routing/#structure-of-a-route","title":"Structure of a route","text":"<p>A route is the combination of a starting portal node, a targeted portal node and a data type. This is already an indicator that a data route is uni-directional.</p>"},{"location":"guides/administrator/routing/#mapping-setup","title":"Mapping setup","text":"<p>Some data needs to be mapped between two portal nodes but will not be automatically created by routed transit data. This can be due to reasons like a missing implementation as transit data or merging multiple mappings into a single mapping. Common entities affected by this are salutations, countries, currencies, payment methods and shipping methods. To administer manual mappings use the commands <code>heptaconnect:identity-redirect:add</code> and <code>heptaconnect:identity-redirect:list</code>.</p>"},{"location":"guides/administrator/routing/#how-to-use","title":"How to use","text":"<p>To create a route we want to know what data types we can connect between which portal nodes. To get insights into the available portal nodes there is the command <code>heptaconnect:portal-node:list</code>. The output can look similar to this:</p> <pre><code> \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  portal-node-key   portal-class\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  filter            Heptacom\\HeptaConnect\\Integration\\Filter\\Portal\n  mayan             Heptacom\\HeptaConnect\\Portal\\MayanEdms\\Portal\n  morph             Heptacom\\HeptaConnect\\Integration\\Morph\\Portal\n  sw5               Heptacom\\HeptaConnect\\Portal\\Shopware5\\Portal\n  sw6               Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Portal\n  zammad            Heptacom\\HeptaConnect\\Portal\\Zammad\\Portal\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014</code></pre> <p>There is a similar command for the available data types. There is the command <code>heptaconnect:data-type:list</code> that lists all data types that are supported by the installed portals. An output of the command can look like this:</p> <pre><code> \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product\n  Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media\n  Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Category\n  Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Customer\\Customer\n  Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order\n  Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Currency\\Currency\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014</code></pre> <p>With all the information above we can create routes that can resemble a scenario like the following: * Send products, cms media, customers and orders from the old shop to the new shop  * Send generated documents from the shop to the DMS * Send customers and their orders to the help desk</p> <p>To setup the described scenario we create routes with the command <code>heptaconnect:router:add-route</code>. For the first mentioned instruction the command is used as the following:</p> <pre><code>bin/console heptaconnect:router:add-route sw5 sw6 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product'</code></pre> <p>The complete scenario can be setup with just the following few lines:</p> <pre><code>bin/console heptaconnect:router:add-route sw5 sw6 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product'\nbin/console heptaconnect:router:add-route sw5 sw6 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media'\nbin/console heptaconnect:router:add-route sw5 sw6 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Customer\\Customer'\nbin/console heptaconnect:router:add-route sw5 sw6 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order'\nbin/console heptaconnect:router:add-route sw6 filter 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media'\nbin/console heptaconnect:router:add-route filter mayan 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media'\nbin/console heptaconnect:router:add-route sw6 morph 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Customer\\Customer'\nbin/console heptaconnect:router:add-route sw6 morph 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order'\nbin/console heptaconnect:router:add-route morph zammad 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Customer\\Customer'\nbin/console heptaconnect:router:add-route morph zammad 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order'\n\n# Map EUR in SW5 to EUR in SW6\nbin/console heptaconnect:identity-redirect:add 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Currency\\Currency' sw5 1 sw6 b7d2554b0ce847cd82f3ac9bd1c0dfca </code></pre> <p>The routes after this will look like this.</p> <p></p>"},{"location":"guides/administrator/status-reporting/","title":"Status reporting","text":"<p>Status reports are the tools to build your status page for your HEPTAconnect installation. They are developed by portal developers for capturing metrics.</p>"},{"location":"guides/administrator/status-reporting/#common-metrics","title":"Common metrics","text":"<p>HEPTAconnect suggests portal developers to supply status reports for the following topics:</p> <ul> <li>health: Health status reports are used to test configurations against the underlying portal data source to track availability and connectivity</li> <li>analysis: Analysis status reports are used for API usage rates or different self detected behaviour metrics</li> <li>info: A generic set of information that is helpful right after installation</li> <li>config: A set of information for configuration support like generated API endpoints</li> </ul> <p>To have a detailed look into the thoughts of status reports have a read into the corresponding ADR.</p>"},{"location":"guides/administrator/status-reporting/#how-to-use","title":"How to use","text":"<p>The fastest way in setup is a health tracker using a crontab configuration. It will use a regular check on the portal and use crontab mailing feature to inform about an unhealthy portal. A call to the status report command <code>heptaconnect:portal-node:status</code> filtered through jq with the -e exit code option easily convert the health result into something processable in a shell.</p> <pre><code>bin/console heptaconnect:portal-node:status PortalNode:123 health | jq -e .health</code></pre>"},{"location":"guides/contributor/","title":"How to be a HEPTAconnect contributor","text":"<p>This is all about setting up a development environment to work on HEPTAconnect projects.</p>"},{"location":"guides/contributor/#technical-requirements","title":"Technical requirements","text":"<ul> <li>PHP 7.4 or above</li> <li>Composer 1.8 or above</li> </ul>"},{"location":"guides/contributor/#used-tools-technologies-and-techniques","title":"Used tools, technologies and techniques","text":"<p>Adding static type hints with psalm and phpstan helps us to provide safe and more comprehensive code. Using these tools adds generics and class string functionalities that helps understanding code without an execution context.</p> <p>Developing on the maintainer side is mainly done in JetBrains PHPStorm but is not limited to it. You are free to use any IDE or text editor although the developer experience is improved on the usage of PHPStorm.</p> <p>Tests and their coverages are ensured using pest (phpunit) unit tests and code mutators to improve testing quality.</p> <p>HEPTAconnect aims to be working at bleeding edge technology and supporting the latest stable versions. To achieve this the composer requirements are only setup with a lower bound to allow the easy usage of latest releases.</p> <p>By the growth of the HEPTAconnect community and connected APIs we look out for easy ways to support developers to allow their projects run steadily and non-breaking while the core runtimes get improved and extended by time. One of these ways are fallback implementations. A fallback class always implements an interface completely in a way that makes the code at least be valid in a php code runtime. When you use these fallback classes we can support your extension without breaking it.</p> <p>Message brokers and asynchronous messaging allows HEPTAconnect to be just a little impact on the performance of the main application that provides the bridge. In addition asynchronous messaging allows for a scalable increase of reactivity and flexibility.</p>"},{"location":"guides/contributor/#licensing","title":"Licensing","text":"<p>Thank you for considering contribution! Be sure to sign the CLA after creating the pull request. </p>"},{"location":"guides/contributor/#steps-to-contribute","title":"Steps to contribute","text":"<ol> <li>Fork the repository</li> <li><code>git clone yourname/heptaconnect-framework</code></li> <li>Make your changes to a branch</li> <li><code>make coverage</code></li> <li>Create your Pull-Request</li> </ol>"},{"location":"guides/contributor/build-flow-components/","title":"Building flow components","text":""},{"location":"guides/contributor/build-flow-components/#preparation","title":"Preparation","text":"<p>This guide assumes you have been using HEPTAconnect as a portal developer or integrator before. A possible reason you are reading this is, that you are in a similar situation like the following and think of solving the issue within the HEPTAconnect framework.</p>"},{"location":"guides/contributor/build-flow-components/#situation","title":"Situation","text":"<p>An existing flow component like the receiver gets multiple receiver decorator implementations to stop following receivers on the stack to take action. You see a pattern that all these changes in the reception stack are meant to prevent writing to an API and do a lookup instead.</p> <p>The next steps are:</p> <ul> <li>to describe the pattern and locate it in its current situation</li> <li>to isolate its features</li> <li>to extract its exclusive features compared to existing flow components</li> <li>to question its introduction into the next version</li> </ul>"},{"location":"guides/contributor/build-flow-components/#pattern-detection","title":"Pattern detection","text":"<p>The above detectable pattern is a reception decoration to lookup existing entries in a reception targeted portal node. It takes place within a data flow and introduces new behaviour that is not communicated by the receiver service contract. The new behaviour prevents writing and makes a data lookup instead. It can replace a reception and therefore be a new flow component.</p>"},{"location":"guides/contributor/build-flow-components/#feature-isolation-and-exclusiveness","title":"Feature isolation and exclusiveness","text":"<p>The potential new flow component can only replace a receiver. This can also be turned into supporting readonly APIs without using a flow component that communicates writing in its description. A portal developer can use code separation to separate features and different usage. An administrator has a more flexible usage of the portal without additional configuration provided by the portal developer.</p>"},{"location":"guides/contributor/build-flow-components/#introducing-the-new-flow-component","title":"Introducing the new flow component","text":"<p>Any existing setup should not behave differently, therefore using the new flow component needs to be optional. A name has to be chosen carefully to match its features and usage. In this case the name <code>Finder</code> has been chosen as flows are entity focused, and we try to find an entity in the targeted portal node. In addition to the component name we will name the namespace <code>Find</code> and the methods will use the verb <code>find</code> as well. As this flow component is intended to take part in a data flow we can use route capabilities to configure its behaviour. New documentation on its usage for portal developer and administrator needs to be written. The new flow component should follow patterns in implementation that other flow components have in common.</p>"},{"location":"guides/contributor/build-flow-components/#common-implementation","title":"Common implementation","text":""},{"location":"guides/contributor/build-flow-components/#stack","title":"Stack","text":"<p>Flow component have certain properties, that allow to group them by. For example, receivers are grouped by their supported dataset entity and their portals and supporting portal extensions they are provided with. Based upon that, a portal and a portal extension can provide an implementation for a flow component that belong together and can influence each other. Their code origin influences their order in the stack. The order can be used to build an ordered stack out of it. This stack is used to pass a certain payload into it, pass through every layer in their respective order and allow each layer to modify a possible result that is returned at the end of the stack iteration. In the case of an emitter stack the payload is a set of identities and its return value are resolved entities. The flow components in a stack can intercept stack iteration to allow full influence of behaviour. The <code>next</code> method of the stack is the first entrypoint of a stack to start the layer iteration.</p> <p></p>"},{"location":"guides/contributor/build-flow-components/#stack-building","title":"Stack building","text":"<p>The stack order and its overall contents can differ in each usage situation. To ensure reproducible order the building process is abstracted into its own service. The stack builder is aware of a source instance, that can be provided from a portal or a portal extension. This instance is the first in the order and is used in general as last entry in the stack. Every other instance on the stack is called a decorator and provided by portal extensions.</p>"},{"location":"guides/contributor/build-flow-components/#call-decoration","title":"Call decoration","text":"<p>When the <code>next</code> method on the stack is called it has to call the <code>find</code> method of the first instance on the stack. The <code>find</code> method of the finder instance itself gets the current stack as argument and can now take over the control of the following <code>$stack-&gt;next()</code> call. This way a flow component can change the inbound payload, the result and break the execution.</p>"},{"location":"guides/contributor/build-flow-components/#context","title":"Context","text":"<p>In addition to the omnipresent stack there is also the context. Each flow component type has its own context. The different contexts barely have anything in common and are specialized to provide functionality that only makes sense in usage of this specific flow component and cannot be provided by a service in the portal node container. For example, the context in an emission has the method <code>isDirectEmission</code> to allow knowledge about its usage like a direct emission. The <code>FindContext</code> could probably get information whether it is preceding a reception.</p>"},{"location":"guides/contributor/build-flow-components/#flow-component-contract-class","title":"Flow component contract class","text":"<p>A contract class for a flow component always has at least three methods:</p> <ul> <li>supports</li> <li>find</li> <li>run</li> </ul> <p>The <code>supports</code> method represents every getter method that returns data to group a flow component instance by. It is neither aware of the context nor the stack as it will be used to prepare both of these. Every implementation of a flow component needs to provide the information about its supported topic or dataset entity.</p> <p>The <code>find</code> method has already been introduced in the stack explanation. It is named to the verb of the component and therefore varies between the different flow components. It needs to be pre-implemented to chain as described so a portal developer does not need to implement it. The portal developer still needs to be able to override its implementation as this method is controlling the processing flow through the stack.</p> <p>The <code>run</code> method has to have a signature that allows for a possible implementation with the least needed instructions to take effect. This is the first entrypoint a portal developer will look for and has to enable the developer to see effects quickly. The first entrypoint does not need to be the most efficient way but the most efficient way needs to possible and should be less complex than implementing <code>next</code> yourself. A suitable example is the <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract</code> it has a <code>run</code> and <code>batch</code> method, that allows to implement both scenarios but works out of the box independently whether <code>run</code> or <code>batch</code> is implemented.</p>"},{"location":"guides/contributor/build-flow-components/#short-notation","title":"Short notation","text":"<p>The short notation provides a different way to implement the flow component contract class. For every overridable method of the <code>FinderContract</code> except <code>find</code> the portal developer shall be able to provide a closure as implementation. The signature of these closures can have a custom rule set and must not be limited to the respective signature of the method in the contract to allow dependency injection by the portal node container.</p> <p>All closures are collected in a token. The token class <code>FinderToken</code> has no features beside storing closures.</p> <p>To provide a fluent interface for portal developers to configure the token a builder class is needed. All methods of the flow component specific builder need to be named the same as in the flow component contract class so its usage is the very similar to implementing the contract class. Each method will store the parameters in the wrapped token instance and return itself to ensure a fluent usage.</p> <p>To execute the closures in the token we need a generic implementation of the contract. It will take the token in the constructor and execute each callback in the respective duplicated methods. At this place you have to analyze the parameters of the token's closure and lookup any services from the service container. This also allows custom rules to take effect. As an example we can look into the <code>EmitterContract</code>: when you forward the <code>run</code> method to the closure you can also resolve a string parameter called <code>externalId</code> to be the previous parameter <code>$externalId</code> from the <code>run</code> method.</p> <p>To access the new builder component the <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent</code> facade needs to provide a factory method named like the new flow component, so it can be used in short notation files. It will also need to factorize the flow components.</p>"},{"location":"guides/contributor/build-flow-components/#code-origin-finder","title":"Code origin finder","text":"<p>Reasonable log messages are crucial. Therefore, whenever HEPTAconnect is aware of a flow component being part of the log message's context, the file the flow component is written in is logged as well. This feature is not possible without a <code>FinderCodeOriginFinder</code>. It can differentiate between a token based implementation of the <code>FinderContract</code> and an object-oriented implementation. The token based implementation needs to evaluate the source of the closures in the token instead of the class implementations' source file. The new code origin finder class can now be used along with the others in the <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Logger\\FlowComponentCodeOriginFinderLogger</code> to improve log messages.</p>"},{"location":"guides/contributor/build-flow-components/#portal-node-container","title":"Portal node container","text":"<p>Building the portal node container has a big impact on the usage of the newly created flow component. It loads the short notation files and detects all implementations of the new contract class to propagate their existences. This has to be implemented by scanning all implementations and pass the service references to the <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry</code>.</p>"},{"location":"guides/contributor/build-flow-components/#flow-component-registry","title":"Flow component registry","text":"<p>The flow component registry is the central place of a portal node container to supply all flow components for a portal node. Therefore, a getter method for instances of the new flow component must be added to the registry. This new getter will rely on the new parameter in the constructor and the newly found services in the portal node container.</p>"},{"location":"guides/contributor/build-flow-components/#factory","title":"Factory","text":"<p>As the context and the stack building are specialized for situations, factories are essential tooling. These factories are not accessible by portals. The <code>FinderStackBuilderFactory</code> will load a portal node container and request the finder flow component instances from the flow component registry. Now the stack builder has everything to work with later on.</p>"},{"location":"guides/contributor/build-flow-components/#actor","title":"Actor","text":"<p>Most of the previous parts are taking place in the portal base package. Everything is ready for portals and extensions to use the new flow component. The next big step is to teach the core package what to do with the new flow component. The service that will actually work with the new flow components is an actor, the <code>FindActor</code>. Its implementation precisely knows how to process a stack properly. The <code>performFind</code> method of this service looks similar to a contract class <code>find</code> as it does not create the stack and context it will work with later. An actor often validates incoming data (e.g. does not forward to the stack at all when empty), triggers different actions like follow-up flows.</p>"},{"location":"guides/contributor/build-flow-components/#service","title":"Service","text":"<p>The main entrypoint for every execution of the new flow component is its own service. <code>FindService</code> will take as few arguments as needed to build a stack, create a context and execute the <code>FindActor</code>.</p>"},{"location":"guides/contributor/build-flow-components/#jobs","title":"Jobs","text":"<p>HEPTAconnect can outsource flow component processing as jobs in different processes (commonly on different machines). To support this we need to introduce a job for the new flow component. Job classes need to be based upon <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\JobContract</code>. Instances of a job class contain all infos that is needed to process a job. In the best scenarios a job is only aware of an identity. In our scenario we want to behave similar to the reception and therefore also need the entity to lookup later. The entity will be part of the payload of the <code>Find</code> job. Instances of these job type instances can now be dispatched using the <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\JobDispatcherContract</code>. Its implementation ensures forwarding the job and its payload to be used in other process like a message queue or a child PHP process.</p>"},{"location":"guides/contributor/build-flow-components/#job-handling","title":"Job handling","text":"<p>The job has been dispatched to be handled separately from the current PHP process. When the job is ready to execute, it needs to be handled. The <code>FindJobHandler</code> will track the job processing state, read the jobs' payload and pass the job payload to the <code>FindService</code>. On finishing the <code>Find</code> job, a follow-up <code>Reception</code> job should be generated, when the route capability allows it.  </p>"},{"location":"guides/contributor/build-flow-components/#route-capability-usage","title":"Route capability usage","text":"<p>Now we are about to finish the initial task. The storages need to know about the new route capability. We designed it to be optional and name it <code>find</code>. Right before <code>Reception</code> jobs will be dispatched, we decide to ask the storage for the route capability and dispatch a <code>Find</code> job instead. There is no functionality lost as the <code>Find</code> job will be able to generate a follow-up <code>Reception</code> job.</p>"},{"location":"guides/contributor/build-flow-components/#admin-ui","title":"Admin UI","text":"<p>Often it is useful to have certain utilities for the administrator. In this scenario you only have to make sure the new route capability is available in the storage implementations, but the admin UI is already able to display the route capability. It is probably that your new flow component will be part of the admin UI.</p>"},{"location":"guides/contributor/build-flow-components/#summary","title":"Summary","text":""},{"location":"guides/contributor/build-flow-components/#portal-base","title":"Portal base","text":"<p>We need to provide contracts for the portal developer to use. You are most likely having a file structure of new files like this:</p> <pre><code>&lt;portal-base-source&gt;\n\u251c\u2500\u2500 Builder\n\u2502   \u251c\u2500\u2500 Builder\n\u2502   \u2502   \u2514\u2500\u2500 FinderBuilder.php\n\u2502   \u251c\u2500\u2500 Component\n\u2502   \u2502   \u2514\u2500\u2500 Finder.php\n\u2502   \u2514\u2500\u2500 Token\n\u2502       \u2514\u2500\u2500 FinderToken.php\n\u2514\u2500\u2500 Find\n    \u251c\u2500\u2500 Contract\n    \u2502   \u251c\u2500\u2500 FindContextInterface.php\n    \u2502   \u251c\u2500\u2500 FinderCodeOriginFinderInterface.php\n    \u2502   \u251c\u2500\u2500 FinderContract.php\n    \u2502   \u2514\u2500\u2500 FinderStackInterface.php\n    \u251c\u2500\u2500 FinderCollection.php\n    \u2514\u2500\u2500 FinderStack.php</code></pre>"},{"location":"guides/contributor/build-flow-components/#core","title":"Core","text":"<p>The actual usage of the new flow component needs to be handled within the core. You are most likely having a file structure of new files like this:</p> <pre><code>&lt;core-source&gt;\n\u251c\u2500\u2500 Find\n\u2502   \u251c\u2500\u2500 Contract\n\u2502   \u2502   \u251c\u2500\u2500 FindActorInterface.php\n\u2502   \u2502   \u251c\u2500\u2500 FindContextFactoryInterface.php\n\u2502   \u2502   \u251c\u2500\u2500 FindServiceInterface.php\n\u2502   \u2502   \u251c\u2500\u2500 FinderStackBuilderFactoryInterface.php\n\u2502   \u2502   \u2514\u2500\u2500 FinderStackBuilderInterface.php\n\u2502   \u251c\u2500\u2500 FindActor.php\n\u2502   \u251c\u2500\u2500 FindContext.php\n\u2502   \u251c\u2500\u2500 FindContextFactory.php\n\u2502   \u251c\u2500\u2500 FindService.php\n\u2502   \u251c\u2500\u2500 FinderCodeOriginFinder.php\n\u2502   \u251c\u2500\u2500 FinderStackBuilder.php\n\u2502   \u2514\u2500\u2500 FinderStackBuilderFactory.php    \n\u2514\u2500\u2500 Job\n    \u251c\u2500\u2500 Contract\n    \u2502   \u2514\u2500\u2500 FindHandlerInterface.php\n    \u251c\u2500\u2500 Handler\n    \u2502   \u2514\u2500\u2500 FindHandler.php\n    \u2514\u2500\u2500 Type\n        \u2514\u2500\u2500 Find.php    </code></pre>"},{"location":"guides/contributor/build-storage-actions/","title":"Building storage actions","text":""},{"location":"guides/contributor/build-storage-actions/#preparation","title":"Preparation","text":"<p>This guide assumes you have been using HEPTAconnect as an integrator before. A possible reason you are reading this is, that you want to introduce a new flow component and thus need to change the management storage layout to provide new interactions.</p>"},{"location":"guides/contributor/build-storage-actions/#situation","title":"Situation","text":"<p>A new flow component needs a new storage action to find out on which routes it is expected to action. Route capabilities are the way to configure flow components on routes, so we can look out for existing patterns. In case you are in a situation that is not already done in a similar way, have a look into the ADR capturing our thoughts on storage actions.</p> <p>The next steps are:</p> <ul> <li>to define the interface by<ul> <li>defining parameters</li> <li>defining result</li> </ul> </li> <li>implement new tests</li> <li>implement in storage packages</li> </ul>"},{"location":"guides/contributor/build-storage-actions/#storage-action","title":"Storage action","text":"<p>Storage actions interfaces are grouped in sub namespaces of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\</code> depending on the storage component it affects.</p> <pre><code>&lt;storage-base-source&gt;\n\u2514\u2500\u2500 Contract\n    \u2514\u2500\u2500 Action\n        \u251c\u2500\u2500 FileReference\n        \u251c\u2500\u2500 Identity\n        \u251c\u2500\u2500 IdentityError\n        \u251c\u2500\u2500 Job\n        \u251c\u2500\u2500 PortalExtension\n        \u251c\u2500\u2500 PortalNode\n        \u251c\u2500\u2500 PortalNodeAlias\n        \u251c\u2500\u2500 PortalNodeConfiguration\n        \u251c\u2500\u2500 PortalNodeStorage\n        \u251c\u2500\u2500 Route\n        \u251c\u2500\u2500 RouteCapability\n        \u2514\u2500\u2500 WebHttpHandlerConfiguration</code></pre> <p>Our situation requires to look into the route section as we want to query route data. There we have the following actions at release of version 0.9.0.0.</p> <pre><code>&lt;storage-base-source&gt;\n\u2514\u2500\u2500 Contract\n    \u2514\u2500\u2500 Action\n        \u2514\u2500\u2500 Route\n            \u251c\u2500\u2500 ReceptionRouteListActionInterface.php\n            \u251c\u2500\u2500 RouteCreateActionInterface.php\n            \u251c\u2500\u2500 RouteDeleteActionInterface.php\n            \u251c\u2500\u2500 RouteFindActionInterface.php\n            \u251c\u2500\u2500 RouteGetActionInterface.php\n            \u2514\u2500\u2500 RouteOverviewActionInterface.php</code></pre> <p><code>ReceptionRouteListActionInterface</code> is the closest one to our situation, so we can copy it, but we will look into the next steps when designing a new action.</p>"},{"location":"guides/contributor/build-storage-actions/#storage-action-parameter","title":"Storage action parameter","text":"<p>This storage action looks for routes by a certain criteria: the entity type in question and the source portal node. To allow an extendable way to add new parameters without breaking the action interface, the parameters are grouped into a DTO class implementing the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface</code>. This class is placed in a sub namespace that all DTOs share. The namespace is similarly built compared to the namespace for the action interface. For this situation it will be <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\</code> and can look like this:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentCollection;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface;\n\nfinal class FindRouteListCriteria implements AttachmentAwareInterface\n{\n    use AttachmentAwareTrait;\n\n    protected PortalNodeKeyInterface $sourcePortalNodeKey;\n\n    /**\n     * @var class-string&lt;DatasetEntityContract&gt;\n     */\n    protected string $entityType;\n\n    /**\n     * @param class-string&lt;DatasetEntityContract&gt; $entityType\n     */\n    public function __construct(PortalNodeKeyInterface $sourcePortalNodeKey, string $entityType)\n    {\n        $this-&gt;attachments = new AttachmentCollection();\n        $this-&gt;sourcePortalNodeKey = $sourcePortalNodeKey;\n        $this-&gt;entityType = $entityType;\n    }\n\n    public function getSourcePortalNodeKey(): PortalNodeKeyInterface\n    {\n        return $this-&gt;sourcePortalNodeKey;\n    }\n\n    public function setSourcePortalNodeKey(PortalNodeKeyInterface $sourcePortalNodeKey): void\n    {\n        $this-&gt;sourcePortalNodeKey = $sourcePortalNodeKey;\n    }\n\n    /**\n     * @return class-string&lt;DatasetEntityContract&gt;\n     */\n    public function getEntityType(): string\n    {\n        return $this-&gt;entityType;\n    }\n\n    /**\n     * @param class-string&lt;DatasetEntityContract&gt; $entityType\n     */\n    public function setEntityType(string $entityType): void\n    {\n        $this-&gt;entityType = $entityType;\n    }\n}</code></pre>"},{"location":"guides/contributor/build-storage-actions/#storage-result","title":"Storage result","text":"<p>As the result is a list we can either go for a collection class or an iterable of returning each row. Using iterables through generators is good as it can reduce memory usage as not all rows have to be present in memory at once. Generators in implementations are only a bad choice, when the actions are meant to perform write operations in the storage, as these methods are only executed when an iteration happens and therefore might not happen. In our situation we only load data from the storage and can go for an iterator expectation. Consequently, we only need a single class: a DTO class to hold a single result.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentCollection;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\RouteKeyInterface;\n\nfinal class FindRouteListResult implements AttachmentAwareInterface\n{\n    use AttachmentAwareTrait;\n\n    protected RouteKeyInterface $routeKey;\n\n    public function __construct(RouteKeyInterface $routeKey)\n    {\n        $this-&gt;attachments = new AttachmentCollection();\n        $this-&gt;routeKey = $routeKey;\n    }\n\n    public function getRouteKey(): RouteKeyInterface\n    {\n        return $this-&gt;routeKey;\n    }\n}</code></pre>"},{"location":"guides/contributor/build-storage-actions/#storage-action-interface","title":"Storage action interface","text":"<p>As we finished everything what goes in and goes out, we can now define the interface:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route;\n\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\FindRouteListCriteria;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\FindRouteListResult;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\UnsupportedStorageKeyException;\n\ninterface FindRouteListActionInterface\n{\n    /**\n     * List all routes for a find scenario.\n     *\n     * @throws UnsupportedStorageKeyException\n     *\n     * @return iterable&lt;FindRouteListResult&gt;\n     */\n    public function list(FindRouteListCriteria $criteria): iterable;\n}</code></pre> <p>It is important to write a comment onto the interface to define an expectation for writing the tests, using the action and implementing the action. Actions are provided by a factory implementing the <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code>. When introducing this new storage action interface, a new method has to be added to the storage facade interface to get an instance of the storage action implementation. With a modified interface, every implementation and related test needs to be adjusted as well.</p>"},{"location":"guides/contributor/build-storage-actions/#storage-test-suite","title":"Storage test suite","text":"<p>Tests for the storage are defined in the <code>heptacom/heptaconnect-test-suite-storage</code> of the framework. This set of tests can be used by all storage implementations to test against. A test in the test suite is an abstract class that expects to be run by phpunit. To provide the implementation to test, an abstract method needs to provide an instance of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code>. In general, you will find a lifecycle test in these tests. A lifecycle test is like an e2e (end to end) test, but for data. So we create data, query data, modify data, query data, delete data and query data again. It can look like this:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\TestSuite\\Storage\\Action;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\PortalNodeKeyCollection;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayload;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayloads;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreateResult;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Delete\\PortalNodeDeleteCriteria;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayload;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayloads;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Delete\\RouteDeleteCriteria;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\FindRouteListCriteria;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Enum\\RouteCapability;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\NotFoundException;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\RouteKeyCollection;\nuse Heptacom\\HeptaConnect\\TestSuite\\Storage\\Fixture\\Dataset\\EntityA;\nuse Heptacom\\HeptaConnect\\TestSuite\\Storage\\Fixture\\Portal\\PortalA\\PortalA;\nuse Heptacom\\HeptaConnect\\TestSuite\\Storage\\Fixture\\Portal\\PortalB\\PortalB;\nuse Heptacom\\HeptaConnect\\TestSuite\\Storage\\TestCase;\n\n/**\n * Test pre-implementation to test find route related storage actions. Some other storage actions e.g. PortalNodeCreate\n * are needed to set up test scenarios.\n */\nabstract class FindRouteTestContract extends TestCase\n{\n    /**\n     * Validates a complete find route \"lifecycle\" can be managed with the storage. It covers creation, usage,\n     * configuration and deletion of routes.\n     */\n    public function testLifecycle(): void\n    {\n        $facade = $this-&gt;createStorageFacade();\n        $portalNodeCreateAction = $facade-&gt;getPortalNodeCreateAction();\n        $portalNodeDeleteAction = $facade-&gt;getPortalNodeDeleteAction();\n        $routeCreateAction = $facade-&gt;getRouteCreateAction();\n        $routeFindRouteListAction = $facade-&gt;getFindRouteListAction();\n        $routeDeleteAction = $facade-&gt;getRouteDeleteAction();\n\n        $portalNodeCreateResult = $portalNodeCreateAction-&gt;create(new PortalNodeCreatePayloads([\n            new PortalNodeCreatePayload(PortalA::class),\n            new PortalNodeCreatePayload(PortalB::class),\n        ]));\n        $firstResult = $portalNodeCreateResult-&gt;first();\n        $lastResult = $portalNodeCreateResult-&gt;last();\n\n        static::assertInstanceOf(PortalNodeCreateResult::class, $firstResult);\n        static::assertInstanceOf(PortalNodeCreateResult::class, $lastResult);\n        static::assertNotSame($firstResult, $lastResult);\n\n        $portalA = $firstResult-&gt;getPortalNodeKey();\n        $portalB = $lastResult-&gt;getPortalNodeKey();\n\n        $createPayloads = new RouteCreatePayloads([        \n            new RouteCreatePayload($portalB, $portalA, EntityA::class, [RouteCapability::FIND]),\n            new RouteCreatePayload($portalA, $portalB, EntityA::class, [RouteCapability::FIND]),\n        ]);\n\n        $createResults = $routeCreateAction-&gt;create($createPayloads);\n        static::assertCount($createPayloads-&gt;count(), $createResults);\n\n        $findListResult = \\iterable_to_array($routeFindRouteListAction-&gt;find(new FindRouteListCriteria($portalA, EntityA::class)));\n\n        static::assertCount(1, $findListResult);\n\n        $routeDeleteAction-&gt;delete(new RouteDeleteCriteria($routeKeys));\n\n        $findListResult = \\iterable_to_array($routeFindRouteListAction-&gt;find(new FindRouteListCriteria($portalA, EntityA::class)));\n\n        static::assertCount(0, $findListResult);\n\n        try {\n            $this-&gt;routeDeleteAction-&gt;delete(new RouteDeleteCriteria(new RouteKeyCollection([$findListResult[0]-&gt;getRouteKey()])));\n            static::fail('This should have been throwing a not found exception');\n        } catch (NotFoundException $exception) {\n        }\n\n        $portalNodeDeleteAction-&gt;delete(new PortalNodeDeleteCriteria(new PortalNodeKeyCollection([$portalA, $portalB])));\n    }\n\n    /**\n     * Provides the storage implementation to test against.\n     */\n    abstract protected function createStorageFacade(): StorageFacadeInterface;\n}</code></pre>"},{"location":"guides/contributor/build-storage-actions/#storage-implementation","title":"Storage implementation","text":"<p>Without getting into too many details we have for tooling for performant SQL queries in our <code>doctrine/dbal</code> based storage, here some points we look out for when implementing these actions.</p> <ol> <li>To track down issues with SQL queries, we add publicly known unique query identifiers as a comment to recognise them quickly in logs and profilers</li> <li>Every write operation is wrapped in a transactional operation to ensure batch writes are either done completely or rolled back</li> <li>Every select statement is ensured to be paginated to keep package sizes in a certain level</li> <li>Every paginated query is ensured to have a proper order by statement</li> <li>Every select needs to only use indices for queries</li> <li>Implement every abstract test provided by the <code>heptacom/heptaconnect-test-suite-storage</code> package</li> </ol>"},{"location":"guides/contributor/changelog/","title":"Writing changelogs","text":""},{"location":"guides/contributor/changelog/#motivation","title":"Motivation","text":"<p>Working in the past with different frameworks and libraries we experienced it was to a certain degree easy to integrate into projects. In most cases it was much more difficult to keep the dependencies updated properly compared to introducing them. This is something we want to be different. In our fast-paced world of changes we need to also look out for these qualities.</p>"},{"location":"guides/contributor/changelog/#structure","title":"Structure","text":"<p>The changelog file in the root of the package has a preface for the rules inside the changelog file. We follow the format of the keep a changelog project with semantic versioning which formats the file in a standardized layout.</p> <p>For every version we will have changes listed. It is allowed to release a package without a change to properly release a group of interdependent packages so an empty section is fine. There is always a version entry called <code>Unreleased</code> to collect new entries up to the release of the upcoming version.</p> <p>The logs of each version are grouped into their classification of additions, changes, deprecations, removals, fixes and security fixes. To ensure a better understanding of the change the logs are focussed on features of the package written in present tense. Each log has to contain a technical reference to look up usages of the feature.</p>"},{"location":"guides/contributor/changelog/#examples","title":"Examples","text":"<p>Depending on the change we can form scenarios into changelogs. When you are unsure what to write you can find some sample texts below:</p>"},{"location":"guides/contributor/changelog/#extract-code-of-private-api-into-code-of-public-api","title":"Extract code of private API into code of public API","text":"<p>This introduces a feature, so we should write something like:</p> <pre><code>### Added\n\n- Introduce fiddling of stuff into new class `\\Heptacom\\HeptaConnect\\StuffFiddler`</code></pre> <p>As seen in version 0.8.0 of heptaconnect-core:</p> <p>Added</p> <ul> <li>Extract path building from <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer</code> into new service <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\StreamPathContract</code></li> </ul>"},{"location":"guides/contributor/changelog/#add-parameter-to-method-of-public-api","title":"Add parameter to method of public API","text":"<p>This introduces new behaviours, so we also add a new feature:</p> <pre><code>### Added\n\n- Add optional parameter `$foobar` in `\\Heptacom\\HeptaConnect\\StuffFiddler::fiddle`</code></pre> <p>As seen in version 0.7.0 of heptaconnect-core:</p> <p>Added</p> <ul> <li>Add parameter for <code>\\Psr\\Log\\LoggerInterface</code> dependency in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorageFactory::__construct</code></li> </ul>"},{"location":"guides/contributor/changelog/#specialize-component","title":"Specialize component","text":"<p>When you have a generic component, that is not well optimized for certain cases, can be replaced with a new more optimized component:</p> <pre><code>### Added\n\n- Add class `\\Heptacom\\HeptaConnect\\GizmoStuffFiddler` that can fiddle better with stuff of gizmos in terms of memory handling\n\n### Removed\n\n- Remove `\\Heptacom\\HeptaConnect\\StuffFiddler::fiddle`. Use `\\Heptacom\\HeptaConnect\\GizmoStuffFiddler::fiddleGizmos` instead</code></pre> <p>As seen in version 0.8.0 of heptaconnect-storage-base:</p> <p>Added</p> <ul> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> for reading metadata of routes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetResult</code></li> </ul> <p>Removed</p> <ul> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract::read</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface::get</code> that allows for optimizations in the storage implementation</li> </ul>"},{"location":"guides/contributor/changelog/#upgrade-composer-dependency","title":"Upgrade composer dependency","text":"<p>Pre-checking composer upgrades is important to reveal changes of further application fine-tuning, so we mention them as well:</p> <pre><code>### Changed\n\n- Upgrade composer dependency `psr/log: ^1.0` to support future versions `psr/log: ^2.0`</code></pre>"},{"location":"guides/contributor/changelog/#fix-a-bug","title":"Fix a bug","text":"<p>The difficult part here is the differentiation between a security bugfix and an unexpected behaviour:</p> <pre><code>### Fixed\n\n- When passing foobaz into `\\Heptacom\\HeptaConnect\\StuffFiddler::fiddle` did not pay respect to a GizmoStuff situation</code></pre> <p>As seen in version 0.7.0 of heptaconnect-portal-base:</p> <p>Fixed</p> <ul> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract::iterate</code> drops usage of <code>\\spl_object_hash</code> to not break on garbage collection</li> </ul>"},{"location":"guides/contributor/changelog/#add-unique-log-code-for-lookups","title":"Add unique log code for lookups","text":"<p>When anything is logged or an exception is thrown a package-unique code should be generated. Using a UNIX timestamp is handy as it is an integer and plays nicely with <code>\\Throwable::getCode</code>. These have to be documented in the changelogs as well to raise awareness and be the first contact point for persons in need of an explanation.</p> <pre><code>### Added\n\n- Add log exception code `123456789` to `\\Heptacom\\HeptaConnect\\StuffFiddler::fiddle` when fiddling with stuff that is not allowed to access gizmos</code></pre> <p>As seen in version 0.8.0 of heptaconnect-core:</p> <p>Added</p> <ul> <li>Add log exception code <code>1636503503</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job has no related route</li> </ul>"},{"location":"guides/contributor/changelog/#rename-classes-or-move-classes-between-namespaces","title":"Rename classes or move classes between namespaces","text":"<p>When a code refactoring needs moving a class a plain <code>rename</code> or <code>move</code> hint should to be added to the changelog. Additional explanation is optional but suggested as most refactoring have a good reasoning regarding functionality.</p> <pre><code>### Changed\n\n- Rename `\\Heptacom\\HeptaConnect\\StuffFiddler` to `\\Heptacom\\HeptaConnect\\StuffFiddlerHandler`</code></pre> <p>As seen in version 0.5.0 of heptaconnect-dataset-base:</p> <p>Changed</p> <ul> <li>Rename <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\GenericTranslatable</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\AbstractTranslatable</code></li> </ul>"},{"location":"guides/contributor/cla/","title":"Contributor License Agreement","text":"<p>This Contributor License Agreement (\"CLA\") documents the rights granted by Contributors to HEPTACOM GmbH. This Agreement will govern all Contributions made by the Contributor.</p> <p>This Agreement is between Heptacom GmbH, Am Tabakquartier 62, 28197 Bremen [Germany] (\"HEPTACOM\"), and the person [or entity] making a Contribution to this Software (\"Contributor\" and collectively with HEPTACOM, the \"Parties\").</p>"},{"location":"guides/contributor/cla/#1-definitions","title":"1. Definitions","text":"<p>1.1 \"Contribution\" means any intellectual creation (software and / or documentation), including any revisions or additions to existing works submitted by the Contributor to a project and in which the Contributor has the rights of use and exploitation under copyright law.</p> <p>1.2 \"Contributor\" means the copyright owner or legal entity authorized by the copyright owner that is entered into this Agreement.</p> <p>1.3 \"Submitting\" means any form of physical, electronic or written correspondence transmitted to the project using \"GitHub\".</p> <p>1.4 \"Project\" means any open source project from \"HEPTACOM\" on \"GitHub\".</p> <p>1.5 \"GitHub\" is a free web-based service, which is used by HEPTACOM as a social coding platform for software development projects.</p>"},{"location":"guides/contributor/cla/#2-contractual-object","title":"2. Contractual Object","text":"<p>The parties agree on the non-remuneration of the Contributions submitted by the Contributor. The Contributor may submit one or several Contributions to one or several projects. The logic of the CLA is that the Contributor submits Contributions, including the corresponding usage rights, to HEPTACOM.</p>"},{"location":"guides/contributor/cla/#3-license-grants","title":"3. License Grants","text":"<p>3.1 Grant of Copyright License. The Contributor hereby grants HEPTACOM the worldwide, free, irrevocable, unlimited by time and location (for the duration of the copyright), right to transfer any number of simple rights of use to third parties and the right to grant sublicenses to third parties, in particular:</p> <p>a. the right to publish the Contribution,</p> <p>b. the right to alter the Contribution, the elaboration of derivative works on the basis of the Contribution as well as derived works that contain them, and the merger of the Contribution with different software code,</p> <p>c. the right to reproduce the Contribution in an original or modified form,</p> <p>d. dissemination, public accessibility and public communication of the   Contribution in original or modified form.</p> <p>Moral rights remain unaffected as they are recognized under current law and a waiver in this regard is not permissible.  </p> <p>3.2 Grant of Patent License. According to any Contribution (reference to point 1.1) the Contributor hereby grants to HEPTACOM a perpetual, worldwide, non-exclusive, free of charge, royalty-free, irrevocable, unlimited license with the right to transfer any number of non-exclusive licenses to third parties and the right to grant sublicenses to third parties. Furthermore, the Contributor hereby grants HEPTACOM the right to produce, use, sell, import or otherwise transfer the Contribution and the Contribution in combination with the materials (as well as components of this combination). This license applies to those patent claims licensable by the Contributor that are necessarily infringed by the Contribution alone or in combination with the materials to which the Contribution were submitted.</p>"},{"location":"guides/contributor/cla/#4-rights-and-obligations-of-the-parties","title":"4. Rights and obligations of the Parties","text":"<p>4.1 Ownership. The Contributor guarantees that each Contribution is the Contributor\u00b4s original creation. The Contributor guarantees that any Contribution is free of patent or other industrial property rights or copyrights of third parties and that Contributor is legally entitled to grant the licenses above.</p> <p>4.2 Disclosure. If the Contribution contains any rights of third parties, the Contributor is obliged to provide complete details of any third-party license or other restrictions (including, but not limited to, related patents and trademarks) associated with any part of the Contribution.</p> <p>4.3 Support. The Contributor is not expected to provide support for Contributions.</p> <p>4.4 Change notice. The Contributor is obliged to inform HEPTACOM if there will be changes according to the aforesaid provisions.</p> <p>4.5 Licensing obligations of HEPTACOM. HEPTACOM undertakes to license a Contribution that is compatible with the existing licenses in the project, including all rights to acquire future license versions.</p>"},{"location":"guides/contributor/cla/#5-general-provisions","title":"5. General Provisions","text":"<p>5.1 Liability. The liability of the Contributor is limited to intent and fraudulent intent. The compensation for negligently caused consequential damages by the Contributor is excluded. The Contributor shall be liable for his representatives and vicarious agents according to \u00a7 278 of the German Civil Code (BGB).</p> <p>5.2 Term and Termination. This Agreement shall enter into force upon signature and shall be entered into for an indefinite period of time. Both parties may terminate this Agreement by giving six (6) weeks notice at the end of a calendar quarter. Upon termination of this Agreement, HEPTACOM shall no longer receive any Contribution from the Contributor.</p> <p>5.3 Survival. Upon termination or expiration of this Agreement, all terms of the Agreement, including the license grants, shall remain in full force and effect, with the exception that the Contributor will no longer make submissions to HEPTACOM.</p> <p>5.4 Governing law and legal venue. This Agreement and any disputes, claims, court proceedings or other procedures arising out of or related to it, shall be governed by the law of the Federal Republic of Germany under exclusion of the provisions concerning conflict of laws and the UN Convention of Contracts for the International Sale of Goods. Exclusive legal venue is HEPTACOM\u2019s registered place of business.</p> <p>5.5 Amendments. HEPTACOM may amend this Agreement at any time by providing notice to the Distributor or by posting the revised Agreement online where Contributions are made. By making a subsequent Contribution, the Contributor thereby agrees to the revised Agreement for all Contributions made by the Contributor. If the Contributor do not agree to the revised Agreement, the Contributor may stop making Contributions.</p>"},{"location":"guides/integrator/","title":"Integrate HEPTAconnect into your project","text":"<p>This is the place to learn how to structure your project's dependencies. Learn to decide how to decide which portals to integrate and how to optimize your hosting scenario.</p>"},{"location":"guides/integrator/#portals","title":"Portals","text":"<p>Get to know the building blocks of your integration.</p>"},{"location":"guides/integrator/#bridges","title":"Bridges","text":"<p>Compare your project to our templates and learn how to integrate your scenario into your project.</p>"},{"location":"guides/integrator/#message-broking","title":"Message broking","text":"<p>Messages are one of the main scaling factors. Learn to create high-performance message broker scenarios.</p>"},{"location":"guides/integrator/#http-handlers","title":"HTTP Handlers","text":"<p>Exposed HTTP endpoints from portals can be debugged. Also in production environments. Learn how to trace and replay requests.</p>"},{"location":"guides/integrator/#filesystem","title":"Filesystem","text":"<p>Portals can store files on disk. Learn how to integrate network storages.</p>"},{"location":"guides/integrator/#portal-node-configuration","title":"Portal node configuration","text":"<p>Learn to use environment variables and other sources for portal node configurations.</p>"},{"location":"guides/integrator/#logging","title":"Logging","text":"<p>Logging is key for understanding applications. Get enabled to prepare logged data in scaled scenarios to take action when your application most needs it.</p>"},{"location":"guides/integrator/#upgrade","title":"Upgrade","text":"<p>Master the changelogs with our tools to upgrade your integration to the next version.</p>"},{"location":"guides/integrator/bridges/","title":"Bridges","text":"<p>Bridges are solid building blocks to build connections on. HEPTAconnect bridges provide the technological ground the core shall be used on. There are ready-to-use bridges that can be used right away in your integration.</p>"},{"location":"guides/integrator/bridges/#how-to-get-a-bridge","title":"How to get a bridge?","text":"<p>There are multiple sources for bridges. Some of them are available as open source on GitHub and packagist like our Shopware 6 bridge. There are also client specific implementations we (HEPTACOM GmbH) and our HEPTAconnect partners develop as well. To get information on our previous work and our solutions for your connector project contact us by emailing us to info@heptacom.de.</p>"},{"location":"guides/integrator/bridges/#shopware-6","title":"Shopware 6","text":"<p>The first and most used bridge that ships with a data layer build on top of the Shopware 6 DAL. It is very useful and easy to integrate as it exposes itself as Shopware bundle that can be easily used as a plugin. Ship it as bundle in your project or build a self-containing plugin with it and integrate it in your environment of choice.</p>"},{"location":"guides/integrator/bridges/#laravel-8","title":"Laravel 8","text":"<p>To get information on our work on our Laravel 8 bridge contact us by emailing us to info@heptacom.de.</p>"},{"location":"guides/integrator/bridges/#symfony-5","title":"Symfony 5","text":"<p>To get information on our work on our Symfony 5 bridge contact us by emailing us to info@heptacom.de.</p>"},{"location":"guides/integrator/data-tuning/","title":"Data tuning","text":"<p>Visit this page at a later point in time to read the intended content. Subscribe to changes in this documentation.</p> <p>Follow us on Twitter or subscribe to the RSS feeds:</p> <ul> <li>RSS</li> <li>Atom</li> <li>JSON</li> </ul>"},{"location":"guides/integrator/filesystem/","title":"Filesystem","text":"<p>Portals can make use of the filesystem. Scaling to an app server cluster expects the use of a network file storage.</p>"},{"location":"guides/integrator/filesystem/#concept","title":"Concept","text":"<p>Reading and writing files can be a task for a portal. The storage is movable for better administration in different server infrastructures through an abstraction layer for portal developers. To allow administrators of your project to safely manage the files, there has to be a way to configure the used storage. By default the bridges store the portal node filesystems in a directory within the project root directory. When setting up an app server cluster, you need to enable the administrator to configure a network accessible storage. When changing the storage you should document it properly so the administrator of your project can set up accordingly with the related administration guide. Read more in the ADR about the concept.</p>"},{"location":"guides/integrator/filesystem/#sample-configurations","title":"Sample configurations","text":""},{"location":"guides/integrator/filesystem/#shopware-6-bridge","title":"Shopware 6 Bridge","text":"<p>The Shopware 6 bridge exposes itself as a Shopware bundle and makes use of the automatically provided private filesystem. In general the files are placed in <code>&lt;instance-dir&gt;/files/plugins/heptaconnect_bridge_shopware_platform/</code> with a subdirectory for each portal node.</p> <pre><code>&lt;system-root&gt;\n\u2514\u2500\u2500 \u2026\n    \u2514\u2500\u2500 &lt;instance-dir&gt;\n        \u2514\u2500\u2500 files\n            \u2514\u2500\u2500 plugins\n                \u2514\u2500\u2500 heptaconnect_bridge_shopware_platform\n                    \u251c\u2500\u2500 &lt;portal-node-1&gt;\n                    \u251c\u2500\u2500 &lt;portal-node-2&gt;\n                    \u2514\u2500\u2500 &lt;portal-node-3&gt;</code></pre> <p>We suggest to control the storage location by following the hosting guide from Shopware on the shared filesystem.</p>"},{"location":"guides/integrator/filesystem/#patterns","title":"Patterns","text":"<ul> <li>Change the filesystem for a specific portal node</li> </ul>"},{"location":"guides/integrator/http-handlers/","title":"HTTP Handlers","text":"<p>HEPTAconnect exposes HTTP endpoints by portals. Handling of these HTTP handlers can be tuned for e.g. debugging.</p>"},{"location":"guides/integrator/http-handlers/#debugging-dumps-of-http-messages","title":"Debugging dumps of HTTP messages","text":"<p>HEPTAconnect ships a request-response dump feature for HTTP handlers using request attributes defined in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface</code>. This attribute is already set by features provided by bridges e.g. using a sampling rate.</p>"},{"location":"guides/integrator/http-handlers/#dump-format","title":"Dump format","text":"<p>The dumped HTTP messages are formatted using the <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract</code> service. You can override this service definition to change the formatting of the dumped messages. Without any changes the dumped messages are in a raw HTTP format, so it could be used together with <code>nc</code> (netcat), <code>openssl</code> or <code>telnet</code> to replay the requests. As the named tools do just TCP and do not fully perform HTTP, beware that you have to provide the TCP connection information like host and port yourself.  If you want to replay messages with <code>curl</code> you can use the <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code> service instead. Read here about recording. The dumped request can be passed into the standard input using shell pipes:</p> IDEsnetcatopenssltelnet <p>The HTTP request dump can be opened and replayed in IDEs from JetBrains like WebStorm and PHPStorm and Microsoft Visual Studio (17.5+ required).</p> <pre><code>cat dump.http | netcat localhost 80 # Linux\ncat dump.http | nc localhost 80 # macOS\ncat dump.http | netcat --ssl localhost 443 # Linux to an HTTPS secured server</code></pre> <pre><code>cat dump.http | openssl s_client -connect localhost:443</code></pre> <pre><code>telnet localhost 80 # paste file content</code></pre>"},{"location":"guides/integrator/http-handlers/#trigger-dumps","title":"Trigger dumps","text":"<p>If you want to introduce a new trigger to dump HTTP messages, you can decorate the <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface</code> service. Combining triggers of other development tools like SPX or Xdebug is a helpful approach. Read about the integration of SPX here and about the integration of Xdebug here. Adjusting the trigger to your needs is a good way to reduce the amount of dumped messages. We also provide an example to show how to dump HTTP messages only on errors.</p>"},{"location":"guides/integrator/logging/","title":"Logging","text":"<p>Logging is a crucial feature to understand actions of the application's insides. Having a strategy for log inspection should be part of any project and prepared quite early as this speeds up development process.</p>"},{"location":"guides/integrator/logging/#concept","title":"Concept","text":"<p>HEPTAconnect expects to have a PSR compliant logger to send all messages to. The interface <code>\\Psr\\Log\\LoggerInterface</code> provided from PSR is the abstraction layer that expects the bridge to provide a logging implementation and allows the option to change the logger implementation by the integration. Bridges by default fallback to log files placed on the filesystem to always have a solution running out of the box. Integrations should specify a hosting-optimized logging facility that e.g. are scaling better. All our currently available bridges ship with the monolog library which allows for a quick setup for alternative logging providers. When changing the logging facility you should document it properly so the administrator of your project can set up accordingly with the related administration guide. Log messages frequently contain unique codes that point to the origin of a message or an exception. You can read more about them in a news entry and this ADR.</p>"},{"location":"guides/integrator/logging/#sample-configurations","title":"Sample configurations","text":""},{"location":"guides/integrator/logging/#graylog","title":"Graylog","text":"<p>Graylog is a service that can be setup quickly and provides log querying, dashboards and alerts over network and therefore can be used with multiple application instances. It allows a production installation but also a setup for a local/sneak-peek environment with the following docker-compose specification.</p> <pre><code>version: '3'\nservices:\n    mongo:\n        image: mongo:4.2\n        networks:\n            - graylog\n    elasticsearch:\n        image: docker.elastic.co/elasticsearch/elasticsearch-oss:7.10.2\n        environment:\n            - http.host=0.0.0.0\n            - transport.host=localhost\n            - network.host=0.0.0.0\n            - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n        ulimits:\n            memlock:\n                soft: -1\n                hard: -1\n        deploy:\n            resources:\n                limits:\n                    memory : 1g\n        networks:\n            - graylog\n    graylog:\n        image: graylog/graylog:4.1\n        environment:\n            - GRAYLOG_PASSWORD_SECRET=somepasswordpepper\n            - GRAYLOG_ROOT_PASSWORD_SHA2=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918\n            - GRAYLOG_HTTP_EXTERNAL_URI=http://127.0.0.1:9000/\n        networks:\n            - graylog\n        restart: always\n        depends_on:\n            - mongo\n            - elasticsearch\n        ports:\n            - 9000:9000\n            - 12201:12201\n            - 12201:12201/udp\nnetworks:\n    graylog:\n        driver: bridge</code></pre> <p>This will start the graylog webservice, which is hosted behind the URI of the environment variable <code>GRAYLOG_HTTP_EXTERNAL_URI</code>, and an additional port for log feeding. The default credentials for this environment is <code>admin</code> / <code>admin</code>. After starting the containers you have to define an input in graylog. For this example we use the gelf protocol over UDP with the graylog default configuration.</p> <p>The used gelf protocol expects this additional composer requirement <code>graylog2/gelf-php</code>. As integrator, you can now start to override the bridge's logger definition <code>heptacom_heptaconnect.logger</code>. This should depend on environment variables like <code>GELF_HOSTNAME</code> and <code>GELF_PORT</code> and can be implemented like this:</p> config/services.yamlconfig/services.xml (alternative).env <pre><code>heptacom_heptaconnect.logger:\n    class: Monolog\\Logger\n    arguments:\n        - 'heptacom_heptaconnect'\n        -\n            -   !service\n                class: Monolog\\Handler\\GelfHandler\n                arguments:\n                    -   !service\n                        class: Gelf\\Publisher\n                        arguments:\n                            -   !service\n                                class: Gelf\\Transport\\UdpTransport\n                                arguments:\n                                    - '%env(string:GELF_HOSTNAME)%'\n                                    - '%env(int:GELF_PORT)%'</code></pre> <pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service id=\"heptacom_heptaconnect.logger\" class=\"Monolog\\Logger\"&gt;\n            &lt;argument&gt;heptacom_heptaconnect&lt;/argument&gt;\n            &lt;argument type=\"collection\"&gt;\n                &lt;argument type=\"service\"&gt;\n                    &lt;service class=\"Monolog\\Handler\\GelfHandler\"&gt;\n                        &lt;argument type=\"service\"&gt;\n                            &lt;service class=\"Gelf\\Publisher\"&gt;\n                                &lt;argument type=\"service\"&gt;\n                                    &lt;service class=\"Gelf\\Transport\\UdpTransport\"&gt;\n                                        &lt;argument type=\"string\"&gt;%env(string:GELF_HOSTNAME)%&lt;/argument&gt;\n                                        &lt;argument type=\"string\"&gt;%env(int:GELF_PORT)%&lt;/argument&gt;\n                                    &lt;/service&gt;\n                                &lt;/argument&gt;\n                            &lt;/service&gt;\n                        &lt;/argument&gt;\n                    &lt;/service&gt;\n                &lt;/argument&gt;\n            &lt;/argument&gt;\n        &lt;/service&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre> <pre><code># Docker host ip-address\nGELF_HOSTNAME=127.0.0.1\n# same as graylog configured input port and docker port-forwarding\nGELF_PORT=12201</code></pre>"},{"location":"guides/integrator/message-brokers/","title":"Message broking","text":"<p>A message broking system has three types of participants: Sender, broker and consumer. HEPTAconnect builds upon message broking for task splitting over multiple processing units. Learn how to integrate message broking into your project.</p>"},{"location":"guides/integrator/message-brokers/#integrate-a-message-broker","title":"Integrate a message broker","text":"<p>There is no all-fit solution as this heavily depends on the development and hosting environment in your project. Nonetheless, we can provide useful tips for your project from our experience.</p>"},{"location":"guides/integrator/message-brokers/#choose-a-message-broker","title":"Choose a message broker","text":"<p>For local development it is useful to use a relational-database-driven message broker. That makes it more comprehensive as it enables quick access to the message content. The downside is that a relational-database-engine is not well optimized for message broking, so it will neither be fast nor well performing with multiple message consumers.</p> <p>For production environments you should ask your hosting provider what good services they have at hand. In the past we made good experience with Redis, RabbitMQ and Amazon SQS.</p>"},{"location":"guides/integrator/message-brokers/#bridge-support","title":"Bridge support","text":"<p>Depending on the bridge you choose the configuration differs. You will probably find your use-case below and copy the requirements. It is common to use multiple solutions in the same project to allow different environments like local development and production hosting. Changing between the solutions is best done via environment variables. Ensure to document the message broker, so you can get new persons aboard nicely.</p>"},{"location":"guides/integrator/message-brokers/#shopware-6-database","title":"Shopware 6 - Database","text":"<p>Shopware by default ships with the enqueue library and a database table called <code>enqueue</code>. This allows for no additional required work to use HEPTAconnect with a message broker. </p>"},{"location":"guides/integrator/message-brokers/#shopware-6-redis","title":"Shopware 6 - Redis","text":"<p>Shopware by default ships with the enqueue library so the following is an explanation how to configure it. This example expects a Redis service running on the local system <code>127.0.0.1</code>, is accessible on the port <code>6379</code> and use the database <code>1</code>. Configure the following files that are placed in your Shopware 6 project:</p> <pre><code>pecl install redis</code></pre> config/packages/enqueue.yamlconfig/packages/framework.yaml.env <pre><code>enqueue:\n    redis:\n        transport: '%env(MESSAGE_BROKER_REDIS_URL)%'\n        client: ~</code></pre> <pre><code>framework:\n    messenger:\n        transports:\n            default:\n                dsn: '%env(MESSAGE_BROKER_DSN)%'</code></pre> <pre><code>MESSAGE_BROKER_REDIS_URL=\"redis://127.0.0.1:6379/1\"\nMESSAGE_BROKER_DSN=\"enqueue://redis\"</code></pre>"},{"location":"guides/integrator/message-brokers/#shopware-6-rabbitmq","title":"Shopware 6 - RabbitMQ","text":"<p>Shopware by default ships with the enqueue library so the following is an explanation how to configure it. This example expects a RabbitMQ service running on the local system <code>127.0.0.1</code>, is accessible on the port <code>5672</code> with the credentials <code>guest</code> / <code>guest</code>. Configure the following files that are placed in your Shopware 6 project:</p> <pre><code>pecl install amqp</code></pre> config/packages/enqueue.yamlconfig/packages/framework.yaml.env <pre><code>enqueue:\n    rabbitmq:\n        transport:\n            dsn: '%env(MESSAGE_BROKER_RABBITMQ_URL)%'\n        client: ~</code></pre> <pre><code>framework:\n    messenger:\n        transports:\n            default:\n                dsn: '%env(MESSAGE_BROKER_DSN)%'</code></pre> <pre><code>MESSAGE_BROKER_RABBITMQ_URL=\"amqp://guest:guest@127.0.0.1:5672/%2F?connection_timeout=1000&amp;heartbeat=100\"\nMESSAGE_BROKER_DSN=\"enqueue://rabbitmq?queue[name]=heptaconnect\"</code></pre>"},{"location":"guides/integrator/portal-node-configuration/","title":"Portal node configuration","text":"<p>Portal node configuration are configured using command line commands and are persistent in the storage layer. Common strategies to create staging, testing and development systems depend on configuration by environment variables. Here you can learn how to switch portal node configuration by other configuration sources. This page is separated in four sections to explain how to these few lines can configure a portal node by environment variables:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::replace('bottle', Config::helper()-&gt;env([\n    'black' =&gt; 'PORTAL_BOTTLE_BLACK',\n]));</code></pre> <ol> <li>How to use in my project?</li> <li>How to identity a portal node to configure?</li> <li>Where to load data from?</li> <li>How to combine different sources?</li> </ol>"},{"location":"guides/integrator/portal-node-configuration/#bridge-support","title":"Bridge support","text":"<p>Depending on the bridge you choose the configuration differs. You will probably find your use-case below and copy the requirements. Ensure to document the newly integrated configuration sources, so you can get new persons aboard nicely.</p>"},{"location":"guides/integrator/portal-node-configuration/#shopware-6","title":"Shopware 6","text":"<p>The Shopware bridge by default ships with a services that collects configuration source services by tagged services. This allows for a few changes to introduce new configuration sources. The following example shows what you need to add portal node configuration by a short-notation configuration script.</p> config/services.yamlconfig/services.xml (alternative) <pre><code>Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\InstructionFileLoader:\n    tags:\n        - { name: heptaconnect_core.portal_node_configuration.instruction_file_loader }\n    arguments:\n        - '%kernel.project_dir%/config/portal-node-config.php'</code></pre> <pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service id=\"Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\InstructionFileLoader\"&gt;\n            &lt;tag name=\"heptaconnect_core.portal_node_configuration.instruction_file_loader\"/&gt;\n            &lt;argument&gt;%kernel.project_dir%/config/portal-node-config.php&lt;/argument&gt;\n        &lt;/service&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#configportal-node-configphp","title":"config/portal-node-config.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\n// TODO enter your Config:: instructions</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#portal-node-query","title":"Portal node query","text":"<p>Portal nodes that shall be affected by the configuration instructions can be matched against different queries. The query to match against is the first parameter in every configuration instruction.</p>"},{"location":"guides/integrator/portal-node-configuration/#portal-class","title":"Portal class","text":"<p>You can identify a portal node by its class. This query will match every portal node of the same type and can be used to change configuration for multiple portal nodes at once. The referenced class does not need to be the portal class itself but can be anything extended class name or interface that is related to the portal class of the portal node.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\nuse Heptacom\\HeptaConnect\\Playground\\Portal\\BottlePortal;\n\nConfig::replace(BottlePortal::class, [\n    'black' =&gt; '#111111',\n]);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#portal-extension-class","title":"Portal extension class","text":"<p>You can identify a portal node by its active portal extensions. This query will match every portal node that has a certain activated portal extension attached to it and can be used to change configuration for multiple portal nodes at once. The referenced class does not need to be the portal extension class itself but can be anything extended class name or interface that is related to the portal extension class of the portal node.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\nuse Heptacom\\HeptaConnect\\Playground\\PortalExtension\\BottleContent;\n\nConfig::replace(BottleContent::class, [\n    'contentFactor' =&gt; 1.0,\n]);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#portal-node-key","title":"Portal node key","text":"<p>You can identify a portal node by its key given in the storage layer. This key can be seen when creating a portal node or listing the portal nodes. Using the portal node key is the most specific way to configure a portal node. Therefore, this only works with an existing database.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::replace('PortalNode:1234567890', [\n    'black' =&gt; '#111111',\n]);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#portal-node-alias","title":"Portal node alias","text":"<p>You can identify a portal node by its alias. The portal node alias points to a portal node key and is unique as well. This key can be defined when creating a portal node or seen when listing the portal nodes.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::replace('bottle', [\n    'black' =&gt; '#111111',\n]);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#configuration-sources","title":"Configuration sources","text":"<p>As seen in the initial configuration for the support of your integration, configuration happens on PHP level. PHP as configuration source is the most versatile. To simplify usage of other sources you have the following tooling available:</p>"},{"location":"guides/integrator/portal-node-configuration/#environment-variables","title":"Environment variables","text":"<p>Environment variables are the most common alternative configuration source.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\n$mapping = [\n    'username' =&gt; 'PORTAL_A_USERNAME',\n    'password' =&gt; 'PORTAL_A_PASSWORD',\n];\n$source = Config::helper()-&gt;env($mapping);</code></pre> <p>With the mapping array you can provide a reusable pattern, where to fetch data from. It is equivalent to:</p> <pre><code>&lt;?php\n\n$source = [\n    'username' =&gt; getenv('PORTAL_A_USERNAME'),\n    'password' =&gt; getenv('PORTAL_A_PASSWORD'),\n];</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#array","title":"Array","text":"<p>Restructuring arrays is a flexible way to introduce various configuration sources. In the example is a statically provided <code>$data</code> variable. This can be loaded on different ways.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\n$data = [\n    'list' =&gt; [1, 2, 3],\n    'assoc' =&gt; [\n        'key' =&gt; 'value',\n        'secret' =&gt; 'letmein',\n    ],\n    'not' =&gt; 'needed',\n];\n$mapping = [\n    'username' =&gt; 'assoc.key',\n    'password' =&gt; 'assoc.secret',\n    'logging' =&gt; [\n        'levels' =&gt; 'list',\n    ],\n];\n$source = Config::helper()-&gt;array($data, $mapping);</code></pre> <p>With the mapping array you can provide a reusable pattern, where to fetch data from. It is equivalent to:</p> <pre><code>&lt;?php\n\n$data = [\n    'list' =&gt; [1, 2, 3],\n    'assoc' =&gt; [\n        'key' =&gt; 'value',\n        'secret' =&gt; 'letmein',\n    ],\n    'not' =&gt; 'needed',\n];\n$source = [\n    'username' =&gt; $data['assoc']['key'] ?? null,\n    'password' =&gt; $data['assoc']['secret'] ?? null,\n    'logging' =&gt; [\n        'levels' =&gt; $data['list'] ?? null,\n    ],\n];</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#json","title":"JSON","text":"<p>JSON files are handled very similar compared to arrays as source. The source only refers to a file instead of static data.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\n$mapping = [\n    'username' =&gt; 'assoc.key',\n    'password' =&gt; 'assoc.secret',\n    'logging' =&gt; [\n        'levels' =&gt; 'list',\n    ],\n];\n$source = Config::helper()-&gt;json(__DIR__ . '/config.json', $mapping);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#ini","title":"INI","text":"<p>INI files are handled very similar compared to arrays as source. The source only refers to a file instead of static data.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\n$mapping = [\n    'username' =&gt; 'assoc.key',\n    'password' =&gt; 'assoc.secret',\n    'logging' =&gt; [\n        'levels' =&gt; 'list',\n    ],\n];\n$source = Config::helper()-&gt;ini(__DIR__ . '/config.ini', $mapping);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#configuration-chain","title":"Configuration chain","text":"<p>Every instruction you make in the short-notation is processed in order of definition. The very first source is the cached access of reading the storage layer. After that every manipulation that matches the portal node query is applied in a decoration chain. Each data source referenced in the instruction can be:</p> <ul> <li>either a <code>Closure</code> to reference data pulled from a data store that must not be queried on definition</li> <li>or an <code>array</code> of statically provided data</li> </ul>"},{"location":"guides/integrator/portal-node-configuration/#set-configuration","title":"Set configuration","text":"<p>The <code>set</code> instruction is the most versatile instruction. With great versatility comes great responsibility. This set instruction will break the configuration chain when used with static data or a closure that does not call the next step:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::set('bottle', [\n    'black' =&gt; '#111111',\n]);</code></pre> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::set('bottle', static fn (Closure $next) =&gt; [\n    'black' =&gt; '#111111',\n]);</code></pre> <p>This means that you can prevent loading from the storage layer entirely.</p>"},{"location":"guides/integrator/portal-node-configuration/#merge-configurations","title":"Merge configurations","text":"<p>The <code>merge</code> instruction is a short-notation for a chaining set instruction with <code>array_merge</code> and <code>array_merge_recursive</code>. If not configured differently <code>array_merge_recursive</code> is used.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::set('bottle', static fn (Closure $next) =&gt; \\array_merge_recursive(\n    $next(),\n    [\n        'black' =&gt; '#111111',\n    ]\n));\nConfig::merge('bottle', [\n    'black' =&gt; '#111111',\n]);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#replace-configurations","title":"Replace configurations","text":"<p>The <code>replace</code> instruction is a short-notation for a chaining set instruction with <code>array_replace</code> and <code>array_replace_recursive</code>. If not configured differently <code>array_replace_recursive</code> is used.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::set('bottle', static fn (Closure $next) =&gt; \\array_replace_recursive(\n    $next(),\n    [\n        'black' =&gt; '#111111',\n    ]\n));\nConfig::replace('bottle', [\n    'black' =&gt; '#111111',\n]);</code></pre>"},{"location":"guides/integrator/portal-node-configuration/#reset-configurations","title":"Reset configurations","text":"<p>The <code>reset</code> instruction is a short-notation for a chaining set instruction with a mapped calls of unset to remove data from the previous configuration.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config;\n\nConfig::reset('bottle', static function (Closure $next) {\n    $previous = $next();\n    unset($previous['black']);\n    return $previous;\n});\nConfig::reset('bottle', ['black']);</code></pre>"},{"location":"guides/integrator/portals/","title":"Portals","text":"<p>Portals are the pieces of code to connect your HEPTAconnect instance to other APIs for data transfer. They are most likely installed via composer or as a plugin in your integration (e.g. Shopware 6).</p>"},{"location":"guides/integrator/portals/#how-to-get-a-portal","title":"How to get a portal?","text":"<p>There are multiple sources for portals. Some of them are available as open source on GitHub and packagist like our Shopware 6 portal. There are many client specific implementations for known and custom APIs we (HEPTACOM GmbH) and our HEPTAconnect partners developed in the past. To get information on our previous work and our solutions for your connector project contact us by emailing us to info@heptacom.de.</p>"},{"location":"guides/integrator/portals/#develop-your-own","title":"Develop your own","text":"<p>When you want to develop your portal you can move over from this integrator section over to the portal developer section. There you can find an extensive explanation of all the tools at hand that you need.</p>"},{"location":"guides/integrator/portals/#usage","title":"Usage","text":"<p>When you got access to your portal of choice you can now use composer to install it in your integration. To check whether it got recognized correctly you can check <code>heptaconnect:portal:list</code> to list all your installed portals. Following by that you can create portal nodes from this portal and assign a rememberable name with the command <code>heptaconnect:portal-node:add $FQCN nice_alias</code>. Learn more about administering portal nodes in the administrator section.</p> <p>There are good reasons to alter the behaviour of an existing portal. For this task you use portal extensions. They allow you to completely change the behaviour of any portal and can be mixed with other portal extensions as well. Learn more about decorated flow components like explorers, emitters and receivers in the portal developer section. Learn more about the reasons why and when it is useful to create portal extensions for data tuning.</p>"},{"location":"guides/integrator/upgrade/","title":"Upgrade integrations","text":"<p>Planning an integration does not just take now into consideration but also the future. This guide will show you how to upgrade your integration into future versions of HEPTAconnect.</p>"},{"location":"guides/integrator/upgrade/#changelogs","title":"Changelogs","text":"<p>Like every good software we provide publicly the changelogs for our open source packages as CHANGELOG.md next to the source code. They are also included in this documentation. See them in our release overview. They are written to be understood by human and machines and follow the principles of the keep a changelog proejct.</p>"},{"location":"guides/integrator/upgrade/#applying-the-changelogs","title":"Applying the changelogs","text":"<p>Your integration makes use of multiple HEPTAconnect packages at the same time, so you have to read and understand multiple changelogs. This is a big task to overview the changes and apply them. We can help you to upgrade your integration on multiple ways:</p> <ul> <li>You probably have a running project that has been made by us (HEPTACOM GmbH) or our partners.   In that case we probably planned the update for your project already.</li> <li>Each entry in the change contains a technical information like a class name and a reason for the change.   This way you can relate the technical information to your code and think about the change reason and apply it to your code.</li> <li>The technical information as previously mentioned is also written to be understood by a machine.   You can save a lot of time using the <code>check:upgrade</code> command in the upcoming HEPTAconnect SDK.   It will skim through your code and our changelogs to supply hints to you about the upcoming upgrade. </li> </ul>"},{"location":"guides/integrator/patterns/filesystem-change-for-specific-portal-node/","title":"Change the filesystem for a specific portal node","text":"<p>This pattern shows how to:</p> <ul> <li>Use Flysystem v1 to connect to an FTP server. Learn more in the Flysystem documentation.</li> <li>Decorate a service to return an FTP connection as storage for a specific portal node</li> <li>Identify portal nodes within an integration</li> </ul>"},{"location":"guides/integrator/patterns/filesystem-change-for-specific-portal-node/#integration","title":"Integration","text":""},{"location":"guides/integrator/patterns/filesystem-change-for-specific-portal-node/#srccoreportalnodefilesystemstoragefactoryphp","title":"src/Core/PortalNodeFilesystemStorageFactory.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Production\\Core;\n\nuse Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\FilesystemFactory;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface;\nuse Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\StorageKeyGeneratorContract;\nuse League\\Flysystem\\Adapter\\Ftp;\nuse League\\Flysystem\\Filesystem;\n\nclass PortalNodeFilesystemStorageFactory extends FilesystemFactory\n{\n    private StorageKeyGeneratorContract $storageKeyGenerator;\n\n    private FilesystemFactory $decorated;\n\n    private string $ftpDsn;\n\n    public function __construct(\n        StorageKeyGeneratorContract $storageKeyGenerator,\n        FilesystemInterface $filesystem,\n        FilesystemFactory $decorated,\n        string $ftpDsn\n    ) {\n        parent::__construct($storageKeyGenerator, $filesystem);\n\n        $this-&gt;storageKeyGenerator = $storageKeyGenerator;\n        $this-&gt;decorated = $decorated;\n        $this-&gt;ftpDsn = $ftpDsn;\n    }\n\n    public function factory(PortalNodeKeyInterface $portalNodeKey): FilesystemInterface\n    {\n        $portalNodeAlias = $this-&gt;storageKeyGenerator-&gt;serialize($portalNodeKey-&gt;withAlias());\n\n        if ($portalNodeAlias !== 'portal-node-a') {\n            return $this-&gt;decorated-&gt;factory($portalNodeKey);\n        }\n\n        if ($this-&gt;ftpDsn === '') {\n            return $this-&gt;decorated-&gt;factory($portalNodeKey);\n        }\n\n        $dsnParts = parse_url($this-&gt;ftpDsn);\n\n        return new Filesystem(new Ftp([\n            'host' =&gt; $dsnParts['host'],\n            'username' =&gt; $dsnParts['user'],\n            'password' =&gt; $dsnParts['pass'],\n            'port' =&gt; $dsnParts['port'] ?? 21,\n            'root' =&gt; $dsnParts['path'] ?? null,\n            'passive' =&gt; true,\n            'ssl' =&gt; true,\n        ]));\n    }\n}</code></pre>"},{"location":"guides/integrator/patterns/filesystem-change-for-specific-portal-node/#srcresourcesconfigservicesxml","title":"src/Resources/config/services.xml","text":"<pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service\n            decorates=\"Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\FilesystemFactory\"\n            id=\"Heptacom\\HeptaConnect\\Production\\Core\\PortalNodeFilesystemStorageFactory\"\n            parent=\"Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\FilesystemFactory\"\n        &gt;\n            &lt;argument type=\"service\" id=\"Heptacom\\HeptaConnect\\Production\\Core\\PortalNodeFilesystemStorageFactory.inner\"/&gt;\n            &lt;argument type=\"string\"&gt;%env(string:PORTAL_NODE_A_FTP_DSN)%&lt;/argument&gt;\n        &lt;/service&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre>"},{"location":"guides/integrator/patterns/filesystem-change-for-specific-portal-node/#env","title":".env","text":"<pre><code>PORTAL_NODE_A_FTP_DSN=ftp://user:pass@other-server/subdir</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-format-to-curl-shell-scripts/","title":"Change the dump format for HTTP handler communication to cURL shell","text":"<p>This pattern shows how to:</p> <ul> <li>Change a service alias to set format of HTTP message dumping to <code>curl</code> shell scripts</li> </ul>"},{"location":"guides/integrator/patterns/http-handler-dump-format-to-curl-shell-scripts/#integration","title":"Integration","text":""},{"location":"guides/integrator/patterns/http-handler-dump-format-to-curl-shell-scripts/#configservices","title":"config/services.?","text":"config/services.xmlconfig/services.yaml <pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service\n            id=\"Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract\"\n            alias=\"Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract\"\n        /&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre> <pre><code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract:\n    alias: Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-only-on-errors/","title":"Decorate HTTP handler dump checker to only dump on errors","text":"<p>This pattern shows how to:</p> <ul> <li>Replace the <code>ServerRequestCycleDumpCheckerInterface</code> service to conditionally trigger dumps of HTTP requests</li> <li>Identify whether a response contains an error</li> </ul>"},{"location":"guides/integrator/patterns/http-handler-dump-only-on-errors/#integration","title":"Integration","text":""},{"location":"guides/integrator/patterns/http-handler-dump-only-on-errors/#srccoreerroronlywebhttpdumpcheckerphp","title":"src/Core/ErrorOnlyWebHttpDumpChecker.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Production\\Core;\n\nuse Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\ServerRequestCycle;\n\nfinal class ErrorOnlyWebHttpDumpChecker implements ServerRequestCycleDumpCheckerInterface\n{\n    private ServerRequestCycleDumpCheckerInterface $decorated;\n\n    public function __construct(ServerRequestCycleDumpCheckerInterface $decorated)\n    {\n        $this-&gt;decorated = $decorated;\n    }\n\n    public function shallDump(HttpHandlerStackIdentifier $httpHandler, ServerRequestCycle $requestCycle): bool\n    {\n        if ($requestCycle-&gt;getResponse()-&gt;getStatusCode() &lt; 400) {\n            return false;\n        }\n\n        return $this-&gt;decorated-&gt;shallDump($httpHandler, $requestCycle);\n    }\n}</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-only-on-errors/#configservices","title":"config/services.?","text":"config/services.xmlconfig/services.yaml <pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service\n            id=\"Heptacom\\HeptaConnect\\Production\\Core\\ErrorOnlyWebHttpDumpChecker\"\n            decorates=\"Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\"\n        &gt;\n            &lt;argument type=\"service\" id=\"Heptacom\\HeptaConnect\\Production\\Core\\ErrorOnlyWebHttpDumpChecker.inner\"/&gt;\n        &lt;/service&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre> <pre><code>Heptacom\\HeptaConnect\\Production\\Core\\ErrorOnlyWebHttpDumpChecker\n    decorates: Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\n    arguments:\n        - '@Heptacom\\HeptaConnect\\Production\\Core\\ErrorOnlyWebHttpDumpChecker.inner'</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-with-spx-trigger/","title":"Use SPX extension as trigger for HTTP handler dumps","text":"<p>This pattern shows how to:</p> <ul> <li>Replace the <code>ServerRequestCycleDumpCheckerInterface</code> service to conditionally trigger dumps of HTTP requests</li> <li>Identify whether SPX is used for tracing to set the dump request attribute accordingly</li> </ul>"},{"location":"guides/integrator/patterns/http-handler-dump-with-spx-trigger/#integration","title":"Integration","text":""},{"location":"guides/integrator/patterns/http-handler-dump-with-spx-trigger/#srccorespxwebhttpdumpcheckerphp","title":"src/Core/SpxWebHttpDumpChecker.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Production\\Core;\n\nuse Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\ServerRequestCycle;\n\nfinal class SpxWebHttpDumpChecker implements ServerRequestCycleDumpCheckerInterface\n{\n    private bool $spxEnabled;\n\n    private bool $spxAutoStart;\n\n    public function __construct(bool $spxEnabled, bool $spxAutoStart)\n    {\n        $this-&gt;spxEnabled = $spxEnabled;\n        $this-&gt;spxAutoStart = $spxAutoStart;\n    }\n\n    public function shallDump(HttpHandlerStackIdentifier $httpHandler, ServerRequestCycle $requestCycle): bool\n    {\n        return $this-&gt;isSpxActive();\n    }\n\n    private function isSpxActive(): bool\n    {\n        if (!\\extension_loaded('spx')) {\n            return false;\n        }\n\n        return $this-&gt;spxEnabled &amp;&amp; $this-&gt;spxAutoStart;\n    }\n}</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-with-spx-trigger/#configservices","title":"config/services.?","text":"config/services.xmlconfig/services.yaml <pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service\n            id=\"Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\"\n            class=\"Heptacom\\HeptaConnect\\Production\\Core\\SpxWebHttpDumpChecker\"\n        &gt;\n            &lt;argument&gt;%env(bool:SPX_ENABLED)%&lt;/argument&gt;\n            &lt;argument&gt;%env(bool:SPX_AUTO_START)%&lt;/argument&gt;\n        &lt;/service&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre> <pre><code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface:\n    class: Heptacom\\HeptaConnect\\Production\\Core\\SpxWebHttpDumpChecker\n    arguments:\n        - '%env(bool:SPX_ENABLED)%'\n        - '%env(bool:SPX_AUTO_START)%'</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-with-xdebug-trigger/","title":"Use Xdebug extension as trigger for HTTP handler dumps","text":"<p>This pattern shows how to:</p> <ul> <li>Replace the <code>ServerRequestCycleDumpCheckerInterface</code> service to conditionally trigger dumps of HTTP requests</li> <li>Identify whether Xdebug is used for debugging to set the dump request attribute accordingly</li> </ul>"},{"location":"guides/integrator/patterns/http-handler-dump-with-xdebug-trigger/#integration","title":"Integration","text":""},{"location":"guides/integrator/patterns/http-handler-dump-with-xdebug-trigger/#srccorexdebugwebhttpdumpcheckerphp","title":"src/Core/XdebugWebHttpDumpChecker.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Production\\Core;\n\nuse Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\ServerRequestCycle;\n\nfinal class XdebugWebHttpDumpChecker implements ServerRequestCycleDumpCheckerInterface\n{\n    public function shallDump(HttpHandlerStackIdentifier $httpHandler, ServerRequestCycle $requestCycle): bool\n    {\n        return $this-&gt;isXdebugEnabled();\n    }\n\n    private function isXdebugEnabled(): bool\n    {\n        if (!\\extension_loaded('xdebug')) {\n            return false;\n        }\n\n        if (!\\function_exists('xdebug_info')) {\n            return false;\n        }\n\n        $xdebugMode = \\xdebug_info('mode');\n\n        return !empty($xdebugMode);\n    }\n}</code></pre>"},{"location":"guides/integrator/patterns/http-handler-dump-with-xdebug-trigger/#configservices","title":"config/services.?","text":"config/services.xmlconfig/services.yaml <pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service\n            id=\"Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface\"\n            class=\"Heptacom\\HeptaConnect\\Production\\Core\\XdebugWebHttpDumpChecker\"\n        /&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre> <pre><code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface:\n    class: Heptacom\\HeptaConnect\\Production\\Core\\XdebugWebHttpDumpChecker</code></pre>"},{"location":"guides/playground/","title":"Playground","text":"<p>You can take your first steps with HEPTAconnect by installing the Playground and inspecting its code. The Playground is our demo-project to showcase various features of HEPTAconnect and explain our approach to customization.</p>"},{"location":"guides/playground/#requirements","title":"Requirements","text":"<ul> <li>PHP: 8.2 or higher</li> <li>MySQL: 5.7 or 8.x<ul> <li>MariaDB is known to have issues</li> </ul> </li> <li>Composer: 2.0 or higher</li> <li>Any web server that is able to serve Symfony applications<ul> <li>Learn more about Configuring a Web Server from the official Symfony documentation.</li> <li>For local environments, we recommend Laravel Herd (which is based on PHP-FPM and Nginx).</li> </ul> </li> </ul>"},{"location":"guides/playground/#installation","title":"Installation","text":"<pre><code>composer create-project heptaconnect/playground</code></pre> <p>This command will execute these steps:</p> <ol> <li>Download the Playground project</li> <li>Download the project's dependencies</li> <li>Ask you some questions during the setup process<ul> <li>Environment (dev / prod)</li> <li>URL (for user interface)</li> <li>Database information</li> </ul> </li> <li>Create the database and run all migrations</li> </ol> <p>Alternatively, you can do it manually using these steps. This way, you have more control over the installation process.</p> <pre><code># Download the Playground project\ncomposer create-project heptaconnect/playground --no-install --no-scripts\n\n# Move into Playground directory\ncd playground\n\n# Download the project's dependencies\ncomposer install\n\n# Ask you some questions during the setup process\nbin/console system:setup\n\n# Create the database and run all migrations\nbin/console system:install</code></pre> <p>Now the last step is to configure your web server to serve the Playground project. Set <code>&lt;project-dir&gt;/public</code> as the document root directory.</p> <p>Success</p> <p>That's it. The system installation is complete.</p>"},{"location":"guides/playground/#user-interface","title":"User Interface","text":"<p>By default, HEPTAconnect does not come with a user interface. However, we did create a minimalistic interface to demonstrate, how you could build such interfaces in your own project.</p> <p>Open the URL that you provided during the setup process. You should be greeted by this page.</p> <p></p>"},{"location":"guides/playground/#pre-installed-portals","title":"Pre-Installed Portals","text":"<p>The Playground showcases a basic transfer of product data without an actual real-life data source for products. Instead, we use the portal <code>niemand-online/heptaconnect-portal-amiibo</code> which uses amiiboapi.com to fetch structured data about Amiibo toys. This data is then transformed into product entities and emitted into HEPTAconnect.</p> <p>The target portal for this transfer is a generic dumper implementation. This portal receives any data entities you throw at it and stores it in the HEPTAconnect database. It also provides a page for the user interface to display the products in its storage.</p>"},{"location":"guides/playground/#transfer-data","title":"Transfer Data","text":"<p>HEPTAconnect uses Symfony Messenger to process data transfers asynchronously. To start a worker process, you can run this command.</p> <pre><code>bin/console messenger:consume</code></pre> <p>This is a long-running process. The command will not exit, unless it receives a stop-signal (e.g. <code>SIGINT</code> or <code>SIGTERM</code>).</p> <p>To initiate the transfer, you have to trigger an exploration. The easiest way to do that is by clicking the button <code>Start exploration</code> in the user interface. Alternatively, you could also run this command.</p> <pre><code>bin/console heptaconnect:explore amiibo 'Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product'</code></pre> <p>The exploration will fetch data from the data source and transform it into entity objects. These entities are then emitted to HEPTAconnect. That means, jobs for data receptions are dispatched to the message queue. These jobs are then picked up by the worker process and executed. This sends the entities to the receiver of the target portal.</p> <p>Once you have started an exploration and the worker has processed all subsequent jobs, you can view the received products in the user interface by clicking the button <code>List of dumped products</code>.</p> <p>Success</p> <p>Well done! You just transferred your first entities via HEPTAconnect.</p> <p>Now you can work your way through the source code and learn how we build this demo. Most of the interesting files are located in the <code>&lt;project-dir&gt;/src</code> directory.</p>"},{"location":"guides/playground/add-portals/","title":"Add more portals","text":"<p>To discover what other portals you can try out you can query different package and code distributing platforms for the tag <code>heptaconnect-portal</code>.</p>"},{"location":"guides/playground/add-portals/#add-portals-from-github","title":"Add portals from GitHub","text":"<p>Let's take a look at the results at Packagist. You can use composer to install new portals into your integration.</p> <pre><code>composer require niemand-online/heptaconnect-portal-nasa-apod</code></pre>"},{"location":"guides/playground/add-portals/#see-the-new-portals","title":"See the new portals","text":"<p>The best commands to discover the changes within your HEPTAconnect integrated application are:</p> <ul> <li><code>heptaconnect:portal:list</code> to see your new portal</li> <li><code>heptaconnect:portal-node:add 'NiemandOnline\\HeptaConnect\\Portal\\NasaApod\\NasaApodPortal' nasa</code> to create a new portal node with the alias <code>nasa</code></li> <li><code>heptaconnect:portal-node:config:set nasa api_key \u2026</code> to set a portal node configuration e.g. <code>api_key</code></li> </ul>"},{"location":"guides/playground/contribution/","title":"Contribute to HEPTAconnect packages","text":"<p>If you want to contribute to HEPTAconnect, you can use the Playground as a starting point. Start by running these commands.</p> <pre><code>composer config 'preferred-install.heptacom/heptaconnect-*' source\ncomposer require 'heptacom/heptaconnect-framework:^0.9'</code></pre> <p>Composer will now install the Framework into <code>&lt;project-dir&gt;/vendor/heptacom/heptaconnect-framework</code>. Additionally, composer will use git to clone the dependency from source. This means, you can modify the source code directly in your <code>vendor</code> directory and try it in your integration. When you are done, you can commit directly in this directory and prepare a pull request for us.</p>"},{"location":"guides/portal-developer/","title":"Portal Developer","text":""},{"location":"guides/portal-developer/#how-to-be-a-heptaconnect-portal-developer","title":"How to be a HEPTAconnect portal developer","text":"<p>This is all about the guidelines to structure a portal or portal extensions.</p> <p>Be sure to know the general thoughts and requirements to be a HEPTAconnect developer and have a basic understanding what a dataset is and what it means to develop one.</p>"},{"location":"guides/portal-developer/#composer","title":"Composer","text":"<p>It is mandatory to add the keyword <code>heptaconnect-portal</code> to the composer package that provides one or more portals. This way HEPTAconnect can find your portal and register portal nodes for it. Also more people can easily find your portal on packagist. A common <code>composer.json</code> for a portal providing package may look like this:</p> <pre><code>{\n    \"name\": \"acme/heptaconnect-portal-bottle\",\n    \"description\": \"HEPTAconnect portal to provide bottles\",\n    \"type\": \"library\",\n    \"keywords\": [\n        \"heptaconnect-portal\"\n    ],\n    \"require\": {\n        \"php\": \"&gt;=7.4\",\n        \"acme/heptaconnect-dataset-bottle\": \"&gt;=1\",\n        \"heptacom/heptaconnect-portal-base\": \"&gt;=1\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Acme\\\\Portal\\\\Bottle\\\\\": \"src/\"\n        }\n    },\n    \"extra\": {\n        \"heptaconnect\": {\n            \"portals\": [\n                \"Acme\\\\Portal\\\\Bottle\\\\BottlePortal\"\n            ]\n        }\n    }\n}</code></pre>"},{"location":"guides/portal-developer/#structure","title":"Structure","text":"<p>The entry point of your portal is an implementation of the <code>PortalContract</code>. It can implement a method to provide a configuration template or some custom methods to use in your flow components. None of these methods are mandatory, therefore the minimum valid portal class would look like this:</p> <pre><code>namespace Acme\\Portal\\Bottle;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract;\n\nclass BottlePortal extends PortalContract\n{\n}</code></pre> <p>A receiver that gets data from HEPTAconnect is to be told to communicate towards the API it wraps. A common implementation is to use a custom API client and let the receiver do the translation work from dataset structures to API structures:</p> <pre><code>namespace Acme\\Portal\\Bottle\\Receiver;\n\nuse Acme\\Portal\\Bottle\\Http\\ApiClient;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiveContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract;\nuse Ramsey\\Uuid\\Uuid;\n\nclass BottleReceiver extends ReceiverContract\n{\n    /**\n     * @param Bottle $entity  \n     */\n    protected function run(DatasetEntityContract $entity, ReceiveContextInterface $context): void\n    {\n        // get API client to send the data to\n        $apiClient = new ApiClient();\n\n        // either the entity already has an ID or we create a new one\n        $id = $entity-&gt;getPrimaryKey() ?? Uuid::uuid4()-&gt;toString();\n\n        // translate entity to arbitrary structure and send it to the API\n        $apiClient-&gt;upsert([\n            'id' =&gt; $id,\n            'cap' =&gt; $entity-&gt;getCap()-&gt;getType(),\n            'volume' =&gt; $entity-&gt;getCapacity()-&gt;getAmount(),\n        ]);\n\n        // save the primary key, so a mapping is created\n        $entity-&gt;setPrimaryKey($id);\n    }\n\n    public function supports(): string\n    {\n        // tells HEPTAconnect to use this receiver for bottles\n        return Bottle::class;\n    }\n}</code></pre> <p>As we just read how a receiver is reduced to the case of communication we can compare it to an emitter that loads data from an API and feeds it into HEPTAconnect.</p> <pre><code>namespace Acme\\Portal\\Bottle\\Emitter;\n\nuse Acme\\Portal\\Bottle\\Http\\ApiClient;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Cap;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Volume;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract;\n\nclass BottleEmitter extends EmitterContract\n{\n    protected function run(string $externalId, EmitContextInterface $context): ?DatasetEntityContract\n    {\n        // get API client to read the data from\n        $apiClient = new ApiClient();\n\n        // read data from API client\n        $data = $apiClient-&gt;select($externalId);\n\n        if (\\count($data) === 0) {\n            return null;\n        }           \n\n        // translate arbitrary data structure to entity\n        return (new Bottle())\n            -&gt;setCap((new Cap())-&gt;setType($data['cap']))\n            -&gt;setCapacity((new Volume())\n                -&gt;setAmount($data['volume'])\n                -&gt;setUnit(Volume::UNIT_LITER)\n            )\n        ;\n    }\n\n    public function supports(): string\n    {\n        // tells HEPTAconnect to use this emitter for bottles\n        return Bottle::class;\n    }\n}</code></pre>"},{"location":"guides/portal-developer/#expose-status-for-administration","title":"Expose status for administration","text":"<p>As the portal node is about to get setup or is in usage an administrator needs to find out about its status regarding a correct configuration or the connectivity state of the underlying data source. A status reporter is meant to get information about a certain topic. Every portal should expose a health status reporter when a data source is used that depends on I/O operations like file or network access.</p> <pre><code>namespace Acme\\Portal\\Bottle\\StatusReporter;\n\nuse Acme\\Portal\\Bottle\\Http\\ApiClient;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass BottleHealthStatusReporter extends StatusReporterContract\n{\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    public function run(StatusReportingContextInterface $context): array\n    {\n        // get API client\n        $apiClient = new ApiClient();\n\n        return [\n            $this-&gt;supportsTopic() =&gt; true,\n            'bottleCount' =&gt; $apiClient-&gt;count(),\n        ];\n    }\n}</code></pre>"},{"location":"guides/portal-developer/#extend-portals-via-attachments","title":"Extend portals via attachments","text":"<p>A dataset sometimes is not able to hold data that is needed for an integration to work. The dataset author might have not thought of this case or evaluated it as an edge case. In these situations you are about to create an emitter decorator via a portal extension. A portal extension is published similar to a portal via the extra section in a composer package.</p> <pre><code>{\n    \"name\": \"acme/heptaconnect-portal-bottles-with-content\",\n    \"description\": \"HEPTAconnect portal extension to provide content for bottles\",\n    \"type\": \"library\",\n    \"keywords\": [\n        \"heptaconnect-portal-extension\"\n    ],\n    \"require\": {\n        \"php\": \"&gt;=7.4\",\n        \"acme/heptaconnect-portal-bottle\": \"&gt;=1\",\n        \"acme/heptaconnect-dataset-bottle\": \"&gt;=1\",\n        \"heptacom/heptaconnect-portal-base\": \"&gt;=1\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Acme\\\\PortalExtension\\\\Bottle\\\\\": \"src/\"\n        }\n    },\n    \"extra\": {\n        \"heptaconnect\": {\n            \"portalExtensions\": [\n                \"Acme\\\\PortalExtension\\\\Bottle\\\\BottlesWithContentPortal\"\n            ]\n        }\n    }\n}</code></pre> <p>The portal extension has to specify which portal it extends:</p> <pre><code>namespace Acme\\PortalExtension\\Bottle;\n\nuse Acme\\Portal\\Bottle\\BottlePortal;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract;\n\nclass BottlesWithContentPortal extends PortalExtensionContract\n{\n    public function supports(): string\n    {\n        return BottlePortal::class;\n    }\n}</code></pre> <p>The emitter decorator will be injected into the call chain and can now alter the mappings to be read from the original and add new data.</p> <pre><code>namespace Acme\\PortalExtension\\Bottle\\Emitter;\n\nuse Acme\\Portal\\Bottle\\Http\\ApiClient;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Volume;\nuse Heptacom\\HeptaConnect\\Playground\\PortalExtension\\Dataset\\BottleContent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract;\n\nclass BottleWithContentEmitter extends EmitterContract\n{\n    protected function extend(\n        DatasetEntityContract $entity,\n        EmitContextInterface $context\n    ) : DatasetEntityContract {\n        // get API client\n        $apiClient = new ApiClient();\n\n        // read extra data from the API client\n        $data = $apiClient-&gt;selectContentData($entity-&gt;getPrimaryKey());\n\n        if (\\count($data) &gt; 0) {\n            // assign extra data to the already emitted entity\n            $content = (new BottleContent())\n                -&gt;setContent(\n                    (new Volume)\n                        -&gt;setAmount($data['content'])\n                        -&gt;setUnit(Volume::UNIT_LITER)\n                );\n            $entity-&gt;attach($content);\n        }\n\n        return $entity;\n    }\n\n    public function supports(): string\n    {\n        // tells HEPTAconnect to use this emitter for bottles\n        return Bottle::class;\n    }\n}</code></pre>"},{"location":"guides/portal-developer/dataset/","title":"Datasets","text":"<p>This is all about the guidelines to structure a dataset. Be sure to know then general thoughts and requirements to be a HEPTAconnect developer.</p>"},{"location":"guides/portal-developer/dataset/#composer","title":"Composer","text":"<p>It is recommended to add the keyword <code>heptaconnect-dataset</code> to the composer package that provides a dataset. This way more people can easily find your dataset on packagist. A common <code>composer.json</code> for a dataset providing package may look like this:</p> <pre><code>{\n    \"name\": \"acme/heptaconnect-dataset-bottle\",\n    \"description\": \"HEPTAconnect dataset package to provide bottles\",\n    \"type\": \"library\",\n    \"keywords\": [\n        \"heptaconnect-dataset\"\n    ],\n    \"require\": {\n        \"php\": \"&gt;=7.4\",\n        \"heptacom/heptaconnect-dataset-base\": \"&gt;=1\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Acme\\\\Dataset\\\\Bottle\\\\\": \"src/\"\n        }\n    }\n}</code></pre>"},{"location":"guides/portal-developer/dataset/#structure","title":"Structure","text":"<p>Datasets describe a collection of structures that express common properties of familiar complex structures. These are the building blocks for portals. A dataset should be as common as possible. You don't have to include all possibilities at once.</p> <p>In case of describing data about bottles a single bottle can be described as the following:</p> <pre><code>namespace Acme\\Dataset\\Bottle;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\n\nclass Bottle extends DatasetEntityContract\n{\n    protected Volume $capacity;\n\n    protected LabelCollection $labels;\n\n    protected Cap $cap;\n\n    protected BottleShape $shape;\n\n    /* getters and setters */\n}</code></pre> <p>It is important to use the base class <code>DatasetEntity</code> and use <code>protected</code> fields for internal processing in HEPTAconnect to work.</p> <p>There are supporting classes to build up structures to use throughout any dataset. As internationalization (i18n) faces everyone during a data transport we offer helpful types to make translatable fields easier to handle.</p> <pre><code>namespace Acme\\Dataset\\Bottle;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableString;\n\nclass Label extends DatasetEntityContract\n{\n    protected TranslatableString $text;\n\n    protected string $color;\n}</code></pre> <p>As php does not offer generics every collection is missing the information about the types managed within the list of data. To ensure correct data in arrays and add type hinting for IDEs we provide tooling around typed collections. They contain psalm hints about types and just have to know the contents type to work. Types like <code>StringCollection</code>, <code>IntegerCollection</code> and <code>DateTimeCollection</code> are already shipped in the dataset base to help building up a custom dataset very quickly.</p> <pre><code>namespace Acme\\Dataset\\Bottle;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\DatasetEntityCollection;\n\nclass LabelCollection extends DatasetEntityCollection\n{\n    protected function getT(): string\n    {\n        return Label::class;\n    }\n}</code></pre> <p>The usage of typed enumerations is discouraged as these are very difficult to impossible to extend. We prefer to use constant strings. In best case it is just a UUID as value. This way the string value can receive new values if anyone needs to extend your dataset later on.</p>"},{"location":"guides/portal-developer/dataset/#extend-datasets-with-attachments","title":"Extend datasets with attachments","text":"<p>A dataset is sometimes not able to hold data that is needed for an integration to work. The dataset author might have not thought of this case or evaluated it as an edge case. In these situations you are able to extend dataset entities. To provide additional data for the bottle entity you have to create a custom structure that holds the additional data you need. A data extension can be any class that implements the <code>AttachableInterface</code>. They can be attached to an existing entity using the <code>attach</code> method. The <code>DatasetEntityContract</code> already implements this interface, so existing entities can be plugged into another entity with just a few actions.</p> <pre><code>namespace Acme\\Dataset\\Bottle;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachableInterface;\n\nclass BottleContent implements AttachableInterface\n{\n    protected Volume $capacity;\n}\n\n$bottle = new Bottle();\n$bottle-&gt;attach(new BottleContent());</code></pre>"},{"location":"guides/portal-developer/default-utilities/","title":"List of default utility services","text":"<p>You can use dependency injection to get access to various services. This is a list with brief descriptions for every default service available in the container.</p>"},{"location":"guides/portal-developer/default-utilities/#psr","title":"PSR","text":""},{"location":"guides/portal-developer/default-utilities/#clientinterface","title":"ClientInterface","text":"<p>Psr\\Http\\Client\\ClientInterface</p> <p>A PSR-18 HTTP client whose implementation is based upon the choice of the bridge. Reliable service to do HTTP requests with.</p>"},{"location":"guides/portal-developer/default-utilities/#requestfactoryinterface","title":"RequestFactoryInterface","text":"<p>Psr\\Http\\Message\\RequestFactoryInterface</p> <p>A PSR-17 compliant factory that builds PSR-7 HTTP requests for the <code>Psr\\Http\\Client\\ClientInterface</code> service.</p>"},{"location":"guides/portal-developer/default-utilities/#urifactoryinterface","title":"UriFactoryInterface","text":"<p>Psr\\Http\\Message\\UriFactoryInterface</p> <p>A PSR-17 compliant factory that builds PSR-7 URIs for the <code>Psr\\Http\\Message\\RequestFactoryInterface</code> service.</p>"},{"location":"guides/portal-developer/default-utilities/#loggerinterface","title":"LoggerInterface","text":"<p>Psr\\Log\\LoggerInterface</p> <p>A PSR-3 compliant logging service that logs your messages accordingly to your runtime setup.</p>"},{"location":"guides/portal-developer/default-utilities/#heptaconnect-portal-utilities","title":"HEPTAconnect portal utilities","text":""},{"location":"guides/portal-developer/default-utilities/#normalizationregistrycontract","title":"NormalizationRegistryContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\NormalizationRegistryContract</p> <p>Service to allow different normalization strategies. Useful to serialize objects and streams.</p>"},{"location":"guides/portal-developer/default-utilities/#deepclonecontract","title":"DeepCloneContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepCloneContract</p> <p>Service to clone objects.</p>"},{"location":"guides/portal-developer/default-utilities/#deepobjectiteratorcontract","title":"DeepObjectIteratorContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract</p> <p>Service to iterate objects like trees.</p>"},{"location":"guides/portal-developer/default-utilities/#profilercontract","title":"ProfilerContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Profiling\\ProfilerContract</p> <p>Service to access the profiling component to provide further detailed profiling info.</p>"},{"location":"guides/portal-developer/default-utilities/#publisherinterface","title":"PublisherInterface","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface</p> <p>A service to inform HEPTAconnect about the existence of entities. A publication will trigger an emission of an entity via an event driven flow.</p>"},{"location":"guides/portal-developer/default-utilities/#directemissionflowcontract","title":"DirectEmissionFlowContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionFlowContract</p> <p>A service to directly emit entities. This will skip the source emitter in a regular emission stack while the decorators will still be executed.</p>"},{"location":"guides/portal-developer/default-utilities/#psr7messagerawhttpformattercontract","title":"Psr7MessageRawHttpFormatterContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatterContract</p> <p>Aliased as</p> <p>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract</p> <p>A service to format a PSR-7 HTTP message into a file format, that is similar to HTTP raw communication. It can be used to replay recorded requests using <code>nc</code> (netcat), <code>telnet</code> and with IDEs by Microsoft and JetBrains. See its usage in this pattern.</p>"},{"location":"guides/portal-developer/default-utilities/#psr7messagecurlshellformattercontract","title":"Psr7MessageCurlShellFormatterContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</p> <p>A service to format a PSR-7 HTTP message into a shell script, that executes <code>curl</code> to send the request. It can be used to replay recorded requests by executing the script.</p>"},{"location":"guides/portal-developer/default-utilities/#heptaconnect-portal-node-stack-specific-services","title":"HEPTAconnect portal node stack specific services","text":""},{"location":"guides/portal-developer/default-utilities/#portalcontract","title":"PortalContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract</p> <p>The current portal instance. It is also aliased with the real class so it works with auto-wiring.</p>"},{"location":"guides/portal-developer/default-utilities/#portalextensioncollection","title":"PortalExtensionCollection","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionCollection</p> <p>The list of active portal extensions within this container.</p>"},{"location":"guides/portal-developer/default-utilities/#portalnodekeyinterface","title":"PortalNodeKeyInterface","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface</p> <p>The portal's portal node key instance. This can be used with multiple HEPTAconnect services and is a dependency for the following services.</p>"},{"location":"guides/portal-developer/default-utilities/#portalstorageinterface","title":"PortalStorageInterface","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface</p> <p>A service to store data in a key-value manner. Supports time-to-live attributes on entries to allow caching functionality.</p>"},{"location":"guides/portal-developer/default-utilities/#resourcelockfacade","title":"ResourceLockFacade","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Parallelization\\Support\\ResourceLockFacade </p> <p>A service that allows resource locking functionality to better interrupt between parallel steps.</p>"},{"location":"guides/portal-developer/default-utilities/#httpclientcontract","title":"HttpClientContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientContract</p> <p>A PSR-18 based HTTP client with configuration around the original PSR-18 HTTP client. It supports following redirects, header modifications, status code based exceptions, retries on errors and response information. See reference here.</p>"},{"location":"guides/portal-developer/default-utilities/#httphandlerurlproviderinterface","title":"HttpHandlerUrlProviderInterface","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerUrlProviderInterface</p> <p>A service that resolves HTTP handler path names into absolute URLs.</p>"},{"location":"guides/portal-developer/default-utilities/#filereferencefactorycontract","title":"FileReferenceFactoryContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract</p> <p>A service that stores HTTP requests to get files, raw content of a file and public URLs to files into a file reference to process for a receiving portal. See usage here.</p>"},{"location":"guides/portal-developer/default-utilities/#filereferenceresolvercontract","title":"FileReferenceResolverContract","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract</p> <p>A service that resolves a file reference created by <code>Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract</code> into an accessor to the underlying referenced file content or a public URL to access this file content. See usage here.</p>"},{"location":"guides/portal-developer/default-utilities/#filesysteminterface","title":"FilesystemInterface","text":"<p>Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</p> <p>A service, that provides methods to convert paths and URIs into each other. The URIs point to the provided portal node file system and MUST be used to access the file system, when these files are considered transaction data. See reference here.</p>"},{"location":"guides/portal-developer/dependency-injection/","title":"Dependency injection","text":"<p>As commonly used in the PHP community we provide a dependency injection system that allows easy reuse of utilities and services. We decided to use the Symfony dependency injection package. Read more in the ADR section about our thoughts for our decisions. The following sections require you to know basic knowledge about the Symfony package which are documented very well here.</p>"},{"location":"guides/portal-developer/dependency-injection/#zero-configuration-setup","title":"Zero-configuration setup","text":"<p>Every service container is using a zero-configuration to allow a seamless entry into portal development. This means auto-configuration, auto-wiring, auto-binding and automatic PSR-4 resource loading is active by default. These features enable dependency injection without any setup steps for the developer.</p>"},{"location":"guides/portal-developer/dependency-injection/#how-to-get-a-service","title":"How to get a service?","text":"<p>There are multiple utility services available for every portal node service container. Checkout the next page for a complete overview of all utility services. The examples in this section work with the PSR-3 <code>LoggerInterface</code>.</p>"},{"location":"guides/portal-developer/dependency-injection/#auto-wiring","title":"Auto-wiring","text":"<p>The following small status reporter implementation shows how to get an instance of a logger into the status reporter by auto-wiring:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass HealthStatusReporter extends StatusReporterContract\n{\n    private LoggerInterface $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this-&gt;logger = $logger;\n    }\n\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        $this-&gt;logger-&gt;warning('The status reporter has been called.');\n\n        return [$this-&gt;supportsTopic() =&gt; true];\n    }\n}</code></pre> <p>Auto-wiring detected the <code>\\Psr\\Log\\LoggerInterface</code> in the constructor and automatically decided to go for the logger implementation that is already available for every portal node.</p>"},{"location":"guides/portal-developer/dependency-injection/#auto-configuration","title":"Auto-configuration","text":"<p>The following small status reporter implementation shows how to get an instance of a logger into the status reporter by auto-configuration:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\n\nclass HealthStatusReporter extends StatusReporterContract implements LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        $this-&gt;logger-&gt;warning('The status reporter has been called.');\n\n        return [$this-&gt;supportsTopic() =&gt; true];\n    }\n}</code></pre> <p>There is an auto-configuration rule for the <code>\\Psr\\Log\\LoggerAwareInterface</code> interface which will later call the <code>setLogger</code> method on the instance of this class. In the snippet above there is no visible <code>setLogger</code> implementation. The missing implementation is covered by the <code>\\Psr\\Log\\LoggerAwareTrait</code>. Eventually it is a similar way to the constructor as the logger is set right after the constructor has been called.</p>"},{"location":"guides/portal-developer/dependency-injection/#auto-binding","title":"Auto-binding","text":"<p>The following is an example about accessing files. For this scenario an instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> is needed to access the files of the portal node and a configuration entry for the filename to be read from.</p> <p>At first the portal definition states the <code>filename</code> as configuration:</p> <pre><code>namespace FooBar;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass Portal extends PortalContract\n{\n    public function getConfigurationTemplate() : OptionsResolver\n    {\n        return parent::getConfigurationTemplate()\n            -&gt;setDefault('filename', 'foobar.json')\n            -&gt;setAllowedTypes('filename', 'string');\n    }\n}</code></pre> <p>The next snippet shows a service that will act as a centralized component to access the underlying data source; a JSON file:</p> <pre><code>namespace FooBar\\Service;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\n\nclass File\n{\n    private string $filename;\n\n    public function __construct(FilesystemInterface $filesystem, string $configFilename)\n    {\n        $this-&gt;filename = $filesystem-&gt;toStoragePath($configFilename);\n    }\n\n    public function readAll(): array\n    {\n        return (array) json_decode(file_get_contents($this-&gt;filename) ?: '[]');\n    }\n}</code></pre> <p>This service uses auto-binding to read the values from the portal node configuration and inject it as variable into the service. The variable naming follows the pattern to add <code>config</code> as prefix and the configuration name in camelCase.</p>"},{"location":"guides/portal-developer/dependency-injection/#service-container","title":"Service container","text":"<p>Any flow component context allows you direct access to the PSR-11 service container.</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass HealthStatusReporter extends StatusReporterContract\n{\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        $context-&gt;getLogger()-&gt;warning('The status reporter has been called.');\n\n        return [$this-&gt;supportsTopic() =&gt; true];\n    }\n}</code></pre> <p>Add special attention to the implementation as it uses a <code>has</code> check before the service is acquired. This way you can have a running flow component as it adds the existence check of the service and still stays in a zero-configuration code setup. Be aware that this hides the dependency onto the logger service within the implementation of the class above.</p>"},{"location":"guides/portal-developer/dependency-injection/#define-custom-services","title":"Define custom services","text":""},{"location":"guides/portal-developer/dependency-injection/#zero-configuration","title":"Zero-configuration","text":"<p>The portal node containers make use of the PSR-4 definitions within the composer.json of the portal and portal extensions. That way any class within the referenced folders are automatically available as services:</p> <pre><code>&lt;portal-dir&gt;\n\u251c\u2500\u2500 composer.json\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 AcmeApi\n    \u2502   \u2514\u2500\u2500 ApiClient.php\n    \u251c\u2500\u2500 StatusReporter\n    \u2502   \u2514\u2500\u2500 HealthStatusReporter.php\n    \u2514\u2500\u2500 Portal.php</code></pre> <p>The portal now has three services available:</p> <ul> <li><code>FooBar\\Portal</code></li> <li><code>FooBar\\AcmeApi\\ApiClient</code></li> <li><code>FooBar\\StatusReporter\\HealthStatusReporter</code></li> </ul> <p>Auto-wiring can now automatically inject an <code>ApiClient</code> instance into the <code>HealthStatusReporter</code>.</p> <pre><code>namespace FooBar\\AcmeApi;\n\nclass ApiClient\n{\n    public function ping(): bool\n    {\n        return true;\n    }\n}</code></pre> <pre><code>namespace FooBar\\StatusReporter;\n\nuse FooBar\\AcmeApi\\ApiClient;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass HealthStatusReporter extends StatusReporterContract\n{\n    private ApiClient $client;\n\n    public function __construct(ApiClient $client)\n    {\n        $this-&gt;client = $client;\n    }\n\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        return [$this-&gt;supportsTopic() =&gt; $this-&gt;client-&gt;ping()];\n    }\n}</code></pre>"},{"location":"guides/portal-developer/dependency-injection/#service-argument-aliases","title":"Service argument aliases","text":"<p>A common pattern is to have repositories for each API resources. In the following scenario they all share the same interface <code>ApiResourceInterface</code>. When you have multiple services with the same interface, auto-wiring can't decide properly which service is the right one. In these situations it is handy to use argument aliases, so the argument names can help out. This is the very first moment you need a custom service container definition.</p> <p>To load your service definition file it must be named <code>services.{xml,yml,yaml,php}</code> and it must be located inside the directory <code>src/Resources/config</code>.</p> <p>The file structure should look similar to this:</p> <pre><code>&lt;portal-dir&gt;\n\u251c\u2500\u2500 composer.json\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 AcmeApi\n    \u2502   \u251c\u2500\u2500 ApiClient.php\n    \u2502   \u2514\u2500\u2500 ApiResourceInterface.php\n    \u2502   \u251c\u2500\u2500 AppleRepository.php\n    \u2502   \u2514\u2500\u2500 OrangeRepository.php\n    \u251c\u2500\u2500 Resources\n    \u2502   \u2514\u2500\u2500 config\n    \u2502       \u2514\u2500\u2500 services.xml\n    \u251c\u2500\u2500 StatusReporter\n    \u2502   \u2514\u2500\u2500 HealthStatusReporter.php\n    \u2514\u2500\u2500 Portal.php</code></pre> <p>The two repositories look quite similar and are interchangeable with each other.</p> <pre><code>namespace FooBar\\AcmeApi;\n\nclass AppleRepository implements ApiResourceInterface\n{\n    private ApiClient $client;\n\n    public function __construct(ApiClient $client)\n    {\n        $this-&gt;client = $client;\n    }\n\n    public function findAll(): array\n    {\n        return $this-&gt;client-&gt;findAll('apple');\n    }\n}</code></pre> <pre><code>namespace FooBar\\AcmeApi;\n\nclass OrangeRepository implements ApiResourceInterface\n{\n    private ApiClient $client;\n\n    public function __construct(ApiClient $client)\n    {\n        $this-&gt;client = $client;\n    }\n\n    public function findAll(): array\n    {\n        return $this-&gt;client-&gt;findAll('orange');\n    }\n}</code></pre> <p>Now the <code>HealthStatusReporter</code> requires both repositories and will render the auto-wiring invalid:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse FooBar\\AcmeApi\\ApiClient;\nuse FooBar\\AcmeApi\\ApiResourceInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass HealthStatusReporter extends StatusReporterContract\n{\n    private ApiClient $client;\n\n    private ApiResourceInterface $apples;\n\n    private ApiResourceInterface $oranges;\n\n    public function __construct(ApiClient $client, ApiResourceInterface $apples, ApiResourceInterface $oranges)\n    {\n        $this-&gt;client = $client;\n        $this-&gt;apples = $apples;\n        $this-&gt;oranges = $oranges;\n    }\n\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        return [\n            $this-&gt;supportsTopic() =&gt; $this-&gt;client-&gt;ping(),\n            'apple-count' =&gt; count($this-&gt;apples-&gt;findAll()),\n            'orange-count' =&gt; count($this-&gt;oranges-&gt;findAll()),\n        ];\n    }\n}</code></pre> <p>Having the following service definition it is possible to determine the difference for both services.</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;container\n    xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\"\n&gt;\n    &lt;services&gt;\n        &lt;service alias=\"AcmeApi\\AppleRepository\" id=\"FooBar\\AcmeApi\\ApiResourceInterface $apples\"/&gt;\n        &lt;service alias=\"AcmeApi\\OrangeRepository\" id=\"FooBar\\AcmeApi\\ApiResourceInterface $oranges\"/&gt;\n    &lt;/services&gt;\n&lt;/container&gt;</code></pre>"},{"location":"guides/portal-developer/direct-emission-explorer/","title":"Direct Emission Explorer","text":"<p>A portal connects to a data source for read and write operations. To let HEPTAconnect know about objects in the data source, an explorer has to publish these objects' primary keys. This can be an issue when data sources are read-once or difficult to navigate to certain data points so emitters can't act on it properly. To solve this we allow explorers to emit as well.</p>"},{"location":"guides/portal-developer/direct-emission-explorer/#intention","title":"Intention","text":"<p>Beside the intentions of a regular explorer this can be used for rather static data or difficult/inefficient to access data sources as this is also allowed to do an emission.</p>"},{"location":"guides/portal-developer/direct-emission-explorer/#usage","title":"Usage","text":"<p>Explorers must implement the <code>ExplorerContract</code>. Every explorer must define which data type it supports. In the following example we see an explorer that supports the data type <code>Bottle</code>.</p> <pre><code>public function supports(): string\n{\n    return Bottle::class;\n}</code></pre> <p>The <code>run</code> method iterates over objects in your data source and return them as dataset entities. It is crucial to set the primary key of these entities.</p> <pre><code>protected function run(ExploreContextInterface $context): iterable\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    foreach ($client-&gt;getBottles() as $bottle)\n    {\n        $entity = new Bottle();\n        $entity-&gt;setPrimaryKey((string) $bottle['id']);\n        $entity-&gt;setCapacity(new Liter($bottle['volume']));\n\n        yield $entity;\n    }\n}</code></pre> <p>The explorer will iterate over the result of <code>$client-&gt;getBottles()</code> and construct a data set entity for every item. The primary key is set and the entity is then yielded and passed into an emission.</p>"},{"location":"guides/portal-developer/emitter-decoration/","title":"Emitter decoration","text":"<p>A portal extension allows further customizations in behaviour. This includes changing the emission of data on elements.</p>"},{"location":"guides/portal-developer/emitter-decoration/#intention","title":"Intention","text":"<p>A decorating emitter can change values of existing scalar values and add further attachments to an entity for further complex data structures to be transferred.</p>"},{"location":"guides/portal-developer/emitter-decoration/#usage","title":"Usage","text":"<p>Decorating emitters must follow the same basics as normal emitters so be sure to read the emitter explanation page first.</p> <p>Implementing <code>run</code> in an emitter decorator like a normal emitter will add further elements to the emission process. This is useful when more entities are explored first otherwise we run into confusion for the further processing as for the same primary key there will be two different filled values emitted. To prevent duplicate emission you can add a check whether this is the right entity to process and otherwise return <code>null</code>.</p> <pre><code>protected function run(string $externalId, EmitContextInterface $context): ?DatasetEntityContract\n{\n    // get portal specific API client to communicate the data from the contexts configuration\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    if (!$client-&gt;isOtherBottle($externalId)) {\n        return null;\n    }\n\n    $data = $client-&gt;select($externalId);\n\n    if (\\count($data) === 0) {\n        return null;\n    }\n\n    return (new Bottle())\n        -&gt;setCap((new Cap())-&gt;setName($data['cap']))\n        -&gt;setCapacity(new Liter($data['volume']));\n}</code></pre> <p>The emitter will check if this is an other bottle that has been explored by the explorer decorator first and load it. Otherwise skip it by returning <code>null</code>.</p>"},{"location":"guides/portal-developer/emitter/","title":"Emitter","text":"<p>An emitter is a flow component that has the job to read data from its portal's data source, convert it into a data set entity and hand that entity over to HEPTAconnect.</p>"},{"location":"guides/portal-developer/emitter/#intention","title":"Intention","text":"<p>When an object from a data source is published to HEPTAconnect, a mapping will be created (if it doesn't exist yet). A publication also sends a message to the job queue telling HEPTAconnect to emit the object. This approach has the benefit (as opposed to direct transfer) that publications can be done quickly and don't take up a lot of computing time. This enables publications during time critical processes like e.g. a web request.</p> <p>The actual reading of data is handled by a consumer process of the job queue, while the publication can have various origins.</p>"},{"location":"guides/portal-developer/emitter/#usage","title":"Usage","text":"<p>Emitters must implement the <code>EmitterContract</code>. Every emitter must define which data type it supports. In the following example we see an emitter that supports the data type <code>Bottle</code>.</p> <pre><code>public function supports(): string\n{\n    return Bottle::class;\n}</code></pre> <p>The <code>run</code> method receives a single id and should return a completely filled entity.</p> <pre><code>protected function run(string $externalId, EmitContextInterface $context): ?DatasetEntityContract\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    $result = new Bottle();\n    $result-&gt;setPrimaryKey($externalId);\n    $result-&gt;setCapacity($client-&gt;readBottleCapacity($externalId));\n    $result-&gt;setShape($client-&gt;readBottleShape($externalId));\n    $result-&gt;getLabels()-&gt;push($client-&gt;readBottleLabels($externalId));\n\n    return $result;\n}</code></pre> <p>To run the process in a batch pattern you can also implement <code>batch</code> instead.</p> <pre><code>protected function batch(iterable $externalIds, EmitContextInterface $context): iterable\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    $capacities = $client-&gt;readBottlesCapacity($externalIds);\n    $shapes = $client-&gt;readBottlesShape($externalIds);\n    $labels = $client-&gt;readBottlesLabels($externalIds);\n\n    foreach ($externalIds as $externalId) {\n        $result = new Bottle();\n        $result-&gt;setPrimaryKey($externalId);\n        $result-&gt;setCapacity($capacities[$externalId]);\n        $result-&gt;setShape($shapes[$externalId]);\n        $result-&gt;getLabels()-&gt;push($labels[$externalId]);\n\n        yield $result;\n    }\n}</code></pre>"},{"location":"guides/portal-developer/explorer-decoration/","title":"Explorer decoration","text":"<p>A portal extension allows further customizations in behaviour. This includes changing the discovery of elements.</p>"},{"location":"guides/portal-developer/explorer-decoration/#intention","title":"Intention","text":"<p>A decorating explorer can list additional entries and skip unwanted entries.</p>"},{"location":"guides/portal-developer/explorer-decoration/#usage","title":"Usage","text":"<p>Decorating explorers must follow the same basics as normal explorers so be sure to read the explorer explanation page first. The main difference is in their registration.</p> <p>Implementing <code>run</code> in an explorer decorator like this will add further elements to the exploration process.</p> <pre><code>protected function run(ExploreContextInterface $context): iterable\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    foreach ($client-&gt;getOtherBottles() as $bottle)\n    {\n        $entity = new Bottle();\n        $entity-&gt;setPrimaryKey((string) $bottle['id']);\n\n        yield $entity;\n    }\n}</code></pre> <p>The explorer will iterate over the result of <code>$client-&gt;getOtherBottles()</code> and construct a data set entity for every item. The primary key is set and the entity is then yielded.</p> <p>For a scenario to skip elements that should not be discovered anymore by the extended portal you have to implement <code>isAllowed</code> instead of <code>run</code>. Any explored item will be passed to the allowance check through every decorator. In the following example we only allow bottles that contain caffeinated beverages.</p> <pre><code>protected function isAllowed(string $externalId, ?DatasetEntityContract $entity, ExploreContextInterface $context): bool\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    return $client-&gt;getBottleAdditives($externalId)-&gt;contains('caffeine');\n}</code></pre>"},{"location":"guides/portal-developer/explorer/","title":"Explorer","text":"<p>A portal connects to a data source for read and write operations. To let HEPTAconnect know about objects in the data source, an explorer has to publish these objects' primary keys. Publishing a primary key means to check whether a mapping for it already exists and to create one if it doesn't.</p>"},{"location":"guides/portal-developer/explorer/#intention","title":"Intention","text":"<p>An explorer is a flow component that is primarily used after a new portal node has been created. At this moment there are no mappings in HEPTAconnect (for that portal node) but objects are already present in the data source. To get all these objects into the system, an explorer iterates over all of their identifiers and publishes them.</p>"},{"location":"guides/portal-developer/explorer/#usage","title":"Usage","text":"<p>Explorers must implement the <code>ExplorerContract</code>. Every explorer must define which data type it supports. In the following example we see an explorer that supports the data type <code>Bottle</code>.</p> <pre><code>public function supports(): string\n{\n    return Bottle::class;\n}</code></pre> <p>The <code>run</code> method iterates over primary keys in your data source and yield them.</p> <pre><code>protected function run(ExploreContextInterface $context): iterable\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    yield from $client-&gt;getBottleIds();\n}</code></pre> <p>The explorer will iterate over the result of <code>$client-&gt;getBottleIds()</code> and yield the ids.</p>"},{"location":"guides/portal-developer/file-reference/","title":"File Reference","text":"<p>File references are a way to store information how to access files instead of transferring their content directly. They are useful to reduce the size of payloads in the management storage when transferring BLOBs.</p>"},{"location":"guides/portal-developer/file-reference/#strategies","title":"Strategies","text":"<p>There are two portal node services to handle file references: <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract</code> to create a reference and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract</code> to resolve a reference. All resolved file references expose a public URL and the file content, so it can either be consumed by HTTP clients or the data can be read directly and passed to the next storage. Any access is only done, when used and therefore can throw exceptions. Currently, there are three strategies available.</p>"},{"location":"guides/portal-developer/file-reference/#public-url-http","title":"Public URL (HTTP)","text":"<p>A lightweight way to transfer files as a resource is already publicly available. The reference will only be stored within the payload as there is no need to download it, just to transfer the URL. To create a file reference by HTTP URL, this method has to be used: <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract::fromPublicUrl</code></p>"},{"location":"guides/portal-developer/file-reference/#http-request","title":"HTTP Request","text":"<p>A way to transfer files as a resource that e.g. are locked behind a login. The request will be stored serialized in the HEPTAconnect management storage, so it can be read again. When the data is fetched from the resolved file reference it will be tunneled through HEPTAconnect and the portal node service <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientContract</code>. It is likely that a stored request is cleaned up, so a resolved reference should be processed in a way, that it does not rely on the public URL for a longer period of time. To create a file reference by PSR-7 request, this method has to be used: <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract::fromRequest</code></p>"},{"location":"guides/portal-developer/file-reference/#raw-content","title":"Raw content","text":"<p>The last resort, that can cover any file transfer. It will store the content in the HEPTAconnect management storage, so it can be read again. It is likely that stored raw files are cleaned up, so a resolved reference should be processed in a way that it does not rely on the public URL for a longer period of time. To create a file reference by content, this method has to be used: <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract::fromContents</code></p>"},{"location":"guides/portal-developer/file-reference/#patterns","title":"Patterns","text":"<ul> <li>Transfer file reference by public URLs</li> <li>Send files from an FTP server</li> </ul>"},{"location":"guides/portal-developer/filesystem/","title":"Filesystem","text":"<p>PHP can already access the filesystem, the open question is: where to place files? Each portal node has a designated location and here is how to access it.</p>"},{"location":"guides/portal-developer/filesystem/#concept","title":"Concept","text":"<p>Reading and writing files can be a task for a portal. The storage is not only used by portal developers but the files need also be movable for better administration in different server infrastructures. To allow integrators and administrators to safely manage the files, there has to be a way to configure the storage and keep ease of use when accessing files.  There are different reasons for this directory to be movable e.g. when using a network storage across multiple HEPTAconnect app servers, so we can't just provide access to directory on disk. To accomplish this portals have the <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> service. Read more in the ADR about the concept.</p>"},{"location":"guides/portal-developer/filesystem/#protocol","title":"Protocol","text":"<p>The filesystem is wrapped by a stream wrapper to make it interchangeable in terms of the used storage and portal node. You likely used stream wrappers in PHP, when downloading a file via https e.g. when installing composer:</p> <pre><code>copy('https://getcomposer.org/installer', 'composer-setup.php');</code></pre> <p>This is using a stream wrapper registered on <code>https</code> to read remote files. To get your portal node specific protocol we provide <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> as a service with two methods to convert between paths and PHP compatible URIs.</p>"},{"location":"guides/portal-developer/filesystem/#location","title":"Location","text":"<p>The location can vary between different integrations. See the filesystem integrator guide to understand how to change and find the used location.</p>"},{"location":"guides/portal-developer/filesystem/#patterns","title":"Patterns","text":"<ul> <li>List files from filesystem</li> <li>Serve a file from filesystem using HTTP handler</li> </ul>"},{"location":"guides/portal-developer/http-client-middleware/","title":"HTTP Client Middleware","text":"<p>Since heptacom/heptaconnect-portal-base: 0.9.2</p> <p>A portal, that connects to an HTTP API regularly needs to add headers, session handling or customized response handling, for every request/response. To provide features like this for multiple HTTP requests, you can use these middlewares.</p>"},{"location":"guides/portal-developer/http-client-middleware/#intention","title":"Intention","text":"<p>Shared code will occur with more and more different API calls an HTTP Client is used for. Authenticated session handling is a common case, that can be solved by wrapping each sending of a request and ensure to use an authenticated session identifier. This is where the HTTP Client Middlewares come into play.</p> <p>Intercepting outbound HTTP requests is already simplified, when using the shipped HTTP Client, or defining a decorator for the <code>PSR-18</code> HTTP Client. With this HTTP Client Middleware it is simpler to build decorations around the HTTP Client as only a single file is needed with less potential to do it wrong. The underlying interface is similar to the <code>PSR-15</code> middleware interface but for outbound HTTP requests.</p>"},{"location":"guides/portal-developer/http-client-middleware/#usage","title":"Usage","text":"<p>Services of type <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface</code> will automatically get the service tag <code>heptaconnect.http.client.middleware</code>. All services with the tag <code>heptaconnect.http.client.middleware</code> will be executed for each request, that is sent by the <code>Psr\\Http\\Client\\ClientInterface</code> service. Adding a single file to your code will be sufficient for reoccurring tasks of your HTTP client. See this pattern for dumping message or like the following example for profiling:</p> <pre><code>use Heptacom\\HeptaConnect\\Portal\\Base\\Profiling\\ProfilerContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nfinal class ProfilerMiddleware implements HttpClientMiddlewareInterface\n{\n    private ProfilerContract $profiler;\n\n    private bool $profilingEnabled;\n\n    public function __construct(ProfilerContract $profiler, bool $configProfilingEnabled)\n    {\n        $this-&gt;profiler = $profiler;\n        $this-&gt;profilingEnabled = $configProfilingEnabled;\n    }\n\n    public function process(RequestInterface $request, ClientInterface $handler): ResponseInterface\n    {\n        if (!$this-&gt;profilingEnabled) {\n            return $handler-&gt;sendRequest($request);\n        }\n\n        $this-&gt;profiler-&gt;start(\\sprintf('http client %s %s', $request-&gt;getMethod(), $request-&gt;getUri()));\n\n        try {\n            $response = $handler-&gt;sendRequest($request);\n        } catch (\\Throwable $exception) {\n            $this-&gt;profiler-&gt;stop($exception);\n\n            throw $exception;\n        }\n\n        $this-&gt;profiler-&gt;stop();\n\n        return $response;\n    }\n}</code></pre>"},{"location":"guides/portal-developer/http-handler-middleware/","title":"HTTP Handler Middleware","text":"<p>Since heptacom/heptaconnect-portal-base: 0.9.2</p> <p>A portal can respond to an HTTP request using HTTP Handlers. To provide features for multiple HTTP handlers, you can use these middlewares.</p>"},{"location":"guides/portal-developer/http-handler-middleware/#intention","title":"Intention","text":"<p>With more and more implementations of HTTP handlers, shared code will occur e.g. authentication check, logging and profiling. To share this code you can either copy code snippets or use extracted services over and over again. With HTTP middlewares known from <code>PSR-15</code> you can also write code that intercept every inbound HTTP request for your HTTP handlers. </p>"},{"location":"guides/portal-developer/http-handler-middleware/#usage","title":"Usage","text":"<p>Services of type <code>\\Psr\\Http\\Server\\MiddlewareInterface</code> will automatically get the service tag <code>heptaconnect.http.handler.middleware</code>. All services with the tag <code>heptaconnect.http.handler.middleware</code> will be executed before an HTTP Handler will receive the request. Adding a single file to your code will be sufficient for reoccurring tasks of your HTTP handlers like the following example for profiling:</p> <pre><code>use Heptacom\\HeptaConnect\\Portal\\Base\\Profiling\\ProfilerContract;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nfinal class ProfilerMiddleware implements MiddlewareInterface\n{\n    private ProfilerContract $profiler;\n\n    private bool $profilingEnabled;\n\n    public function __construct(ProfilerContract $profiler, bool $configProfilingEnabled)\n    {\n        $this-&gt;profiler = $profiler;\n        $this-&gt;profilingEnabled = $configProfilingEnabled;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n    {\n        if (!$this-&gt;profilingEnabled) {\n            return $handler-&gt;handle($request);\n        }\n\n        $this-&gt;profiler-&gt;start(\\sprintf('http handler %s %s', $request-&gt;getMethod(), $request-&gt;getUri()));\n\n        try {\n            $response = $handler-&gt;handle($request);\n        } catch (\\Throwable $exception) {\n            $this-&gt;profiler-&gt;stop($exception);\n\n            throw $exception;\n        }\n\n        $this-&gt;profiler-&gt;stop();\n\n        return $response;\n    }\n}</code></pre>"},{"location":"guides/portal-developer/http-handler/","title":"HTTP Handler","text":"<p>A portal can respond to an HTTP request using HTTP handlers. This can be useful for implementing webhooks or web browser interaction (e.g. interactive OAuth 2.0 setup).</p>"},{"location":"guides/portal-developer/http-handler/#intention","title":"Intention","text":"<p>Many external systems support notifications for changes via webhooks. Some systems only send identifiers of affected entities while others send the entire entity or only the change set. Portals can process these notifications by implementing an HTTP handler. For maximum flexibility, handlers are provided with the entire HTTP request object and a prepared HTTP response object that should be modified. The HTTP message objects implement <code>\\Psr\\Http\\Message\\ServerRequestInterface</code> and <code>\\Psr\\Http\\Message\\ResponseInterface</code> defined in <code>PSR-7</code>.</p> <p>It is recommended to keep the operations in HTTP handlers as lightweight as possible, because these components will run in a web context where arbitrary memory limits and time limits can apply. For webhook notifications containing only identities, the handler should use the <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface</code> to offload further I/O into an emitter. Webhooks that receive entire entity payloads can use a packer and dispatch entities immediately to the <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionFlowContract</code>.</p>"},{"location":"guides/portal-developer/http-handler/#usage","title":"Usage","text":"object-oriented notationshort notation <pre><code>use Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandleContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass BottleHttpHandler extends HttpHandlerContract\n{\n    private PublisherInterface $publisher;\n\n    public function __construct(PublisherInterface $publisher)\n    {\n        $this-&gt;publisher = $publisher;\n    }\n\n    protected function supports(): string\n    {\n        return 'bottle';\n    }\n\n    protected function post(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        HttpHandleContextInterface $context\n    ): ResponseInterface {\n        $bottleIds = \\json_decode($request-&gt;getQueryParams()['bottle-ids']);\n\n        $bottleMappings = \\array_map(static fn (string $bottleId) =&gt; new MappingComponentStruct(\n            $context-&gt;getPortalNodeKey(),\n            Bottle::class,\n            $bottleId\n        ), $bottleIds);\n\n        $this-&gt;publisher-&gt;publishBatch(new MappingComponentCollection($bottleMappings));\n\n        return $response-&gt;withStatus(201);\n    }\n}</code></pre> <pre><code>use Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nFlowComponent::httpHandler('bottle')-&gt;post(static function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    PortalNodeKeyInterface $portalNodeKey\n): ResponseInterface {\n    $bottleIds = \\json_decode($request-&gt;getQueryParams()['bottle-ids']);\n\n    $bottleMappings = \\array_map(static fn (string $bottleId) =&gt; new MappingComponentStruct(\n        $portalNodeKey,\n        Bottle::class,\n        $bottleId\n    ), $bottleIds);\n\n    $this-&gt;publisher-&gt;publishBatch(new MappingComponentCollection($bottleMappings));\n\n    return $response-&gt;withStatus(201);\n});</code></pre>"},{"location":"guides/portal-developer/http-handler/#sharing-urls","title":"Sharing URLs","text":"<p>There are several ways how to access the HTTP handlers endpoint. One set of tools are available on the commandline and are explained in the administrator section for HTTP APIs.  Within the utility services there is <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerUrlProviderInterface</code> that can resolve an HTTP handler name into an absolute URL. There is also an HTTP client that implements <code>\\Psr\\Http\\Client\\ClientInterface</code> defined in <code>PSR-18</code> which can be used to post the resolved URL to an external API to register the HTTP handler e.g. as webhook for events.</p>"},{"location":"guides/portal-developer/http-handler/#sharing-code-between-handlers","title":"Sharing code between handlers","text":"<p>With more and more implementations of HTTP handlers, shared code will occur. To use same code for multiple HTTP handlers you can use HTTP Handler Middlewares. </p>"},{"location":"guides/portal-developer/http-handler/#dump-requests-and-responses","title":"Dump requests and responses","text":"<p>The bridges trigger dumping requests and responses and provide a storage for the dumps. See the administrator section on HTTP API debugging how to use that to debug the HTTP traffic.</p>"},{"location":"guides/portal-developer/http-handler/#patterns","title":"Patterns","text":"<ul> <li>Serve a file from filesystem using HTTP handler</li> </ul>"},{"location":"guides/portal-developer/key-value-storage/","title":"Key-Value-Storage","text":"<p>The Key-Value-Storage is a storage component designed for portals to have a simple storage mechanism restricted to a specific portal node. The intention is to provide a storage abstraction for morphers to store intermediate object data. However, a regular portal may utilize the Key-Value-Storage as well.</p>"},{"location":"guides/portal-developer/key-value-storage/#intention","title":"Intention","text":"<p>The intended way to use the Key-Value-Storage is for a morpher to persist intermediate object data for later useage. The contract exposes a getter and a setter method and the and keys are unique for a portal node. A key can be any string of up to 255 characters.</p> <p>A morpher's receiver could receive an object and store it in the Key-Value-Storage. The same morpher's emitter could later retrieve the object from the Key-Value-Storage and combine it with some other data. However, since a morpher is just a portal with a certain role to it, every regular portal may utilize the Key-Value-Storage as well.</p>"},{"location":"guides/portal-developer/key-value-storage/#usage","title":"Usage","text":"<p>Because the Key-Value-Storage is restricted to a portal node, it is contextual to a run. That is why it can be retrieved from the context of an explorer, an emitter or a receiver.</p> <p>A portal can get or set any data to the Key-Value-Storage. Depending on the capabilities of the storage it is even possible to store files in it by wrapping the file contents in the corresponding struct class.</p>"},{"location":"guides/portal-developer/key-value-storage/#error-handling","title":"Error handling","text":"<p>In theory an implementation of the Key-Value-Storage should be able to handle any kind of data. In practise though, whether a certain set of data can be stored depends on the available storage strategies. Providing these strategies is the responsibility of the storage, so a portal cannot influence these. If a portal tries to store a value that cannot be handled by any available strategy, the Key-Value-Storage will throw an exception. Similarly, if a portal tried to read a value that cannot be handled by any strategy (maybe the corresponding denormalizer has been removed with a recent update), the Key-Value-Storage will throw an exception as well.</p>"},{"location":"guides/portal-developer/morphers/","title":"Morpher","text":"<p>A morpher is basically an implementation of a portal that does not directly interact with an external data source but instead acts as a conversion or aggregation mechanism. Its purpose is to receive data from one or multiple portals and emit them in some other form for another portal.</p>"},{"location":"guides/portal-developer/morphers/#intention","title":"Intention","text":"<p>Morphers are multi-purpose-utilities when it comes to moving data from one portal to another while modifying it on the fly. A simple example could be the following use-case:</p> <p>Say you have an ecommerce portal that emits orders and customers. You also have a customer support portal that can receive support tickets. The goal is to convert orders and their respective customers into support tickets. You cannot configure a route from your ecommerce portal directly to your customer support portal, because they do not support the same data types and also you have to combine an order with a customer to have enough information for a support ticket.</p> <p>Your morpher would have two receivers. One for orders and one for customers. Both of them store their received objects in the Key-Value-Storage. The order receiver will publish a support ticket object whenever it saves an order to the Key-Value-Storage.</p> <p>The morpher also has an emitter supporting those support ticket objects. It will load an order from the Key-Value-Storage and (using the customer-id from said order object) it will then try to load a customer from the Key-Value-Storage. If a customer is found, all the necessary informations are present and can be converted to a new support ticket object which is then emitted. If the customer cannot be found, the order is re-published, so the emitter can try again later.</p>"},{"location":"guides/portal-developer/morphers/#usage","title":"Usage","text":"<p>While the example above is the most common way to use a morpher, it is by far not the only way. A morpher is technically indistinguishable from an ordinary portal. It is its unique role as an intermediate portal that makes it a morpher. Because of that, there are numerous possibilities for what a morpher can do and it almost certainly comes down to an individual use-case.</p> <p>Here are some examples for what a morpher could potentially do.</p> <ul> <li>Convert one data type to another one.</li> <li>Combine multiple objects into a single new one, even when the original objects are emitted at different times.</li> <li>Measure the throughput between two portals by logging every transfer.</li> <li>Throttling the throughput between two portals to comply with API rate limits.</li> </ul>"},{"location":"guides/portal-developer/portal/","title":"Portal","text":"<p>HEPTAconnect is focused on modularity. Different packages can be bundled together to adapt it to your needs. That is why a single adapter to an external system is organized in a dedicated package. These packages are called portals. A portal consists of three main components to comply with the HEPTAconnect ecosystem: Explorers, emitters and receivers.</p>"},{"location":"guides/portal-developer/portal/#intention","title":"Intention","text":"<p>Those three component types are explained in more detail on their respective documentation pages. Here is a brief explanation of the flow of data through HEPTAconnect:</p> <p>All of these components connect to their respective portal's data source. The explorer publishes every object to HEPTAconnect (creating a mapping for each of them). In the next step HEPTAconnect will pass these mappings to an emitter for it to read the entire object and construct a data set entity. This object is then passed to the receiver of another portal where it is then written to the data source.</p>"},{"location":"guides/portal-developer/portal/#usage","title":"Usage","text":"<p>A portals job is to register its components and to provide services that are unique for it. Those services e.g. can be a custom API client or a service that can access data inside a static file. You can create a portal by implementing PortalContract and referencing your portal class in the extra section of your packages composer.json like this:</p> <pre><code>\"extra\": {\n    \"heptaconnect\": {\n        \"portals\": [\n            \"Foo\\\\Bar\\\\Portal\"\n        ]\n    }\n},</code></pre> <p>It is required for your package's composer.json to include the keyword <code>heptaconnect-portal</code>. This is the way to let HEPTAconnect know it should take a look at the extra section of your package.</p> <p>HEPTAconnect is split into different packages to provide great modularity. As a result your portal package only needs a single composer dependency to be functional: <code>heptacom/heptaconnect-portal-base</code>. This package provides you with all the contracts, structs and services that are relevant for portals while maintaining full system agnosticism.</p>"},{"location":"guides/portal-developer/receiver-decoration/","title":"Receiver decoration","text":"<p>A portal extension allows further customizations in behaviour. This includes adding further writes when receiving data from elements.</p>"},{"location":"guides/portal-developer/receiver-decoration/#intention","title":"Intention","text":"<p>A decorating receiver can:</p> <ul> <li>change values of existing scalar values and add further attachments to an entity for further complex data structures to be received by the decorated receiver</li> <li>replace the complete receive process of the decorated receiver</li> <li>use the received and mapped entities of the decorated receiver and do further actions on them</li> </ul>"},{"location":"guides/portal-developer/receiver-decoration/#usage","title":"Usage","text":"<p>Decorating receiver must follow the same basics as normal receivers so be sure to read the receiver explanation page first.</p> <p>Implementing <code>run</code> in a receiver decorator like a normal receiver will receive first all elements before the decorated receiver.</p> <p>For a scenario to read further data to already received elements by the extended receiver you have to implement <code>receive</code> and <code>run</code>. <code>receive</code> has to be adjusted to not execute the <code>run</code> method with data before the decorated receiver but after the decorated receiver has run.</p> <pre><code>public function receive(\n    MappedDatasetEntityCollection $mappedDatasetEntities,\n    ReceiveContextInterface $context,\n    ReceiverStackInterface $stack\n): iterable {\n    return $this-&gt;receiveNextForExtends($stack, $mappedDatasetEntities, $context);\n}\n\n/**\n * @param Bottle $entity  \n */\nprotected function run(DatasetEntityContract $entity, ReceiveContextInterface $context): void\n{\n    if ($entity-&gt;getPrimaryKey() === null) {\n        return;\n    }\n\n    $additives = $entity-&gt;getAttachment(AdditiveCollection::class);\n\n    if (!$additives instanceof AdditiveCollection) {\n        return;\n    }\n\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n    // get portal specific API client to communicate the data from the contexts configuration\n    $client-&gt;upsert(\n        $additives-&gt;map(static fn (Additive $a): array =&gt; [        \n            'additiveName' =&gt; $a-&gt;getName(),\n            'bottleId' =&gt; $entity-&gt;getPrimaryKey(),\n        ])\n    );\n}</code></pre> <p>The receiver will check if this entity has been received by the receiver decorator first and save additional data.</p>"},{"location":"guides/portal-developer/receiver/","title":"Receiver","text":"<p>A receiver is a flow component that has the job to take incoming entities from HEPTAconnect, convert them into API specific structures and write the API payload into its portal's data source.</p>"},{"location":"guides/portal-developer/receiver/#usage","title":"Usage","text":"<p>Receivers must implement the <code>ReceiverContract</code>. Every receiver must define which data type it supports. In the following example we see a receiver that supports the data type <code>Bottle</code>.</p> <pre><code>public function supports(): string\n{\n    return Bottle::class;\n}</code></pre> <p>The <code>run</code> method receives a completely filled entity and must set a primary key to the entity after successful writing it to the portal's data source.</p> <pre><code>protected function run(DatasetEntityContract $entity, ReceiveContextInterface $context): void\n{\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n\n    if ($entity-&gt;getPrimaryKey()) {\n        $client-&gt;updateBottle($entity-&gt;getPrimaryKey(), [\n            'capacity' =&gt; $entity-&gt;getCapactity()-&gt;getAmount(),\n            'shape' =&gt; $entity-&gt;getShape()-&gt;getType(),\n            'labels' =&gt; $entity-&gt;getLabels()-&gt;column('getText'),\n        ]);\n    } else {\n        $id = $client-&gt;createBottle([\n            'capacity' =&gt; $entity-&gt;getCapactity()-&gt;getAmount(),\n            'shape' =&gt; $entity-&gt;getShape()-&gt;getType(),\n            'labels' =&gt; $entity-&gt;getLabels()-&gt;column('getText'),\n        ]);\n        $entity-&gt;setPrimaryKey($id);\n    }\n}</code></pre> <p>To run the process in a batch pattern you can also implement <code>batch</code> instead.</p> <pre><code>protected function batch(TypedDatasetEntityCollection $entities, ReceiveContextInterface $context): void\n{\n    $commands = $entities-&gt;map(static fn (Bottle $b): array =&gt; [\n        'id' =&gt; $b-&gt;getPrimaryKey(),\n        'capacity' =&gt; $entity-&gt;getCapactity()-&gt;getAmount(),\n        'shape' =&gt; $entity-&gt;getShape()-&gt;getType(),\n        'labels' =&gt; $entity-&gt;getLabels()-&gt;column('getText'),\n    ]);\n\n    $credentials = $context-&gt;getConfig()['credentials'];\n    $client = new ApiClient($credentials);\n    $results = $client-&gt;upsertBottles($commands);\n\n    foreach ($entities as $step =&gt; $bottle) {\n        $bottle-&gt;setPrimaryKey($results[$step]);\n    }\n}</code></pre>"},{"location":"guides/portal-developer/short-notation-for-flow-components/","title":"Short notation for flow components","text":"<p>Flow components that have been described in the previous pages can also be written in a callback registration pattern. This is very useful short notation to reduce boilerplate code that is only needed to \"wire\" the API connecting services to the flow components. To learn more about the decisions behind this feature have a look at the related ADR.</p>"},{"location":"guides/portal-developer/short-notation-for-flow-components/#how-to-use","title":"How to use","text":"<p>For this feature a plain php file within the folder <code>src/Resources/flow-component/</code> is expected:</p> <pre><code>&lt;portal-dir&gt;\n\u251c\u2500\u2500 composer.json\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 Resources\n        \u2514\u2500\u2500 flow-component\n            \u2514\u2500\u2500 foobar.php</code></pre> <p><code>foobar.php</code> will be loaded and uses a newly introduced <code>FlowComponent</code> building utility. Every callback that is given into that builder can make use of every dependency injection feature. As the callbacks are executed by a wrapper based on the object-oriented notation, there is <code>$this</code> available pointing to the wrapping flow component instance. With this at hand, you can call other methods like <code>supports</code> or <code>run</code> from within a callback. The following section will show how to use each flow component with a file accessing scenario. </p>"},{"location":"guides/portal-developer/short-notation-for-flow-components/#explorer","title":"Explorer","text":"<p>Click here to see the object-oriented notation.</p> <pre><code>&lt;?php\n\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\n\nFlowComponent::explorer(Bottle::class)-&gt;run(\n    fn (FilesystemInterface $fs): iterable =&gt; scandir($fs-&gt;toStoragePath('/'))\n);\n\nFlowComponent::explorer(Bottle::class)-&gt;isAllowed(\n    fn (FilesystemInterface $fs, string $id): bool =&gt; filesize($id) &gt; 0\n);</code></pre>"},{"location":"guides/portal-developer/short-notation-for-flow-components/#emitter","title":"Emitter","text":"<p>Click here to see the object-oriented notation.</p> <pre><code>&lt;?php\n\nuse FooBar\\Packer\\BottlePacker;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Volume;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\n\nFlowComponent::emitter(Bottle::class)-&gt;run(\n    fn (FilesystemInterface $fs, BottlePacker $packer, string $id): ?Bottle =&gt; $packer-&gt;pack(\n        file_get_contents($fs-&gt;toStoragePath($id)) ?: null\n    )\n);\n\nFlowComponent::emitter(Bottle::class)-&gt;batch(\n    fn (FilesystemInterface $fs, BottlePacker $packer, iterable $externalIds): iterable =&gt; \\iterable_map(\n        $externalIds,\n        fn (string $id) =&gt; $packer-&gt;pack(file_get_contents($fs-&gt;toStoragePath($id)) ?: null)        \n    ) \n);\n\nFlowComponent::emitter(Bottle::class)-&gt;extend(\n    fn (FilesystemInterface $fs, Bottle $bottle): ?Bottle =&gt; $bottle-&gt;setCapacity(\n        (new Volume())\n            -&gt;setAmount(filesize($fs-&gt;toStoragePath($bottle-&gt;getPrimaryKey())))\n            -&gt;setUnit('byte')\n    )\n);</code></pre>"},{"location":"guides/portal-developer/short-notation-for-flow-components/#receiver","title":"Receiver","text":"<p>Click here to see the object-oriented notation.</p> <pre><code>&lt;?php\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection;\nuse FooBar\\Unpacker\\BottleUnpacker;\nuse Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\n\nFlowComponent::receiver(Bottle::class)-&gt;run(\n    function (FilesystemInterface $fs, BottleUnpacker $unpacker, Bottle $bottle): void {    \n        ['id' =&gt; $id, 'payload' =&gt; $payload] = $unpacker-&gt;unpack($bottle);\n        file_put_contents($fs-&gt;toStoragePath($id), $payload);\n    }\n);\n\nFlowComponent::receiver(Bottle::class)-&gt;batch(\n    function (FilesystemInterface $fs, BottleUnpacker $unpacker, TypedDatasetEntityCollection $bottles): void {\n        $bottleData = array_column(iterable_to_array($bottles-&gt;map([$unpacker, 'unpack'])), 'payload', 'id');\n\n        foreach ($bottleData as $id =&gt; $bottle) {\n            file_put_contents($fs-&gt;toStoragePath($id), $bottle);\n        }\n    }\n);</code></pre>"},{"location":"guides/portal-developer/short-notation-for-flow-components/#status-reporter","title":"Status reporter","text":"<p>Click here to see the object-oriented notation.</p> <pre><code>&lt;?php\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\n\nFlowComponent::statusReporter('health')-&gt;run(\n    fn (FilesystemInterface $fs): bool =&gt; scandir($fs-&gt;toStoragePath('/')) !== false\n);\n\nFlowComponent::statusReporter('info')-&gt;run(\n    fn (FilesystemInterface $fs): array =&gt; [\n        'count' =&gt; count(scandir($fs-&gt;toStoragePath('/'))),\n    ]\n);</code></pre>"},{"location":"guides/portal-developer/status-reporting/","title":"Status Reporting","text":"<p>Status reporting provides JSON serializable data, so it can be processed easily by many services. It is divided into multiple topics. There are four core topics to define a common set that probably every portal needs:</p> <ul> <li>health Provide hints about I/O connectivity</li> <li>config Provide hints about configuration choices</li> <li>analysis Provide hints about usage statistics</li> <li>info Provide static data that does not fit into a composer package structure</li> </ul> <p>Any portal and portal extension provides status reporters for any topic they want to.</p>"},{"location":"guides/portal-developer/status-reporting/#intention","title":"Intention","text":"<p>Status reporters are intended for the usage of the four core reportings. It is fine to add new topics, but some tooling might not support it out of the box.</p> <p>This way a portal can communicate how to configure a portal node in a multi-step configuration setup or inform about the health status of the connected datasource for monitoring in everyday usage.</p>"},{"location":"guides/portal-developer/status-reporting/#usage","title":"Usage","text":"<p>A status reporter must extend the <code>StatusReporterContract</code> and should implement the <code>run</code> method.</p>"},{"location":"guides/portal-developer/status-reporting/#health","title":"Health","text":"<p>A health status reporter can look like this:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse FooBar\\AcmeApi\\ApiClient;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass HealthStatusReporter extends StatusReporterContract\n{\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_HEALTH;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        $result = [$this-&gt;supportsTopic() =&gt; true];\n\n        try {\n            $apiClient = new ApiClient($context-&gt;getConfig()['credentials']);\n            $apiClient-&gt;commonReadonlyEndpoint();\n        } catch (\\Throwable $exception) {\n            $result[$this-&gt;supportsTopic()] = false;\n            $result['message'] = $exception-&gt;getMessage();\n        }\n\n        return $result;\n    }\n}</code></pre> <p>This status reporter uses the topic key to communicate the evaluation of the portal node topics' well-being. It also uses a common endpoint on the data source to validate the configuration is usable in a production scenario and therefore validates the health state of the underlying API of the datasource.</p>"},{"location":"guides/portal-developer/status-reporting/#configuration","title":"Configuration","text":"<p>A configuration status reporter can look like this:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse FooBar\\AcmeApi\\ApiClient;\nuse FooBar\\AcmeApi\\Node;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass ConfigurationStatusReporter extends StatusReporterContract\n{\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_CONFIG;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        $result = [$this-&gt;supportsTopic() =&gt; true];\n\n        try {\n            $apiClient = new ApiClient($context-&gt;getConfig()['credentials']);\n            $nodes = $apiClient-&gt;getSubnodes();\n            $result['nodes'] = array_map(static fn (Node $node): string =&gt; $node-&gt;getId(), $nodes);\n        } catch (\\Throwable $exception) {\n            $result[$this-&gt;supportsTopic()] = false;\n            $result['message'] = $exception-&gt;getMessage();\n        }\n\n        return $result;\n    }\n}</code></pre> <p>It requests with the already existing configuration further resources (e.g. nodes) that needs to be referred to in upcoming configurations as well.</p>"},{"location":"guides/portal-developer/status-reporting/#analysis","title":"Analysis","text":"<p>An analysis status reporter can look like this:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass AnalysisStatusReporter extends StatusReporterContract\n{\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_ANALYSIS;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        return [\n            $this-&gt;supportsTopic() =&gt; true,\n            'lastClientUsageTimestamp' =&gt; $context-&gt;getStorage()-&gt;get('apiClientLastUsage'),\n        ];\n    }\n}</code></pre> <p>This status reporter relies on a feature the API client needs to implement as well: writing the last unix timestamp into the portal node storage. This way you can track the API clients behaviour.</p>"},{"location":"guides/portal-developer/status-reporting/#information","title":"Information","text":"<p>An information status reporter can look like this:</p> <pre><code>namespace FooBar\\StatusReporter;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReportingContextInterface;\n\nclass InformationStatusReporter extends StatusReporterContract\n{\n    public function supportsTopic(): string\n    {\n        return self::TOPIC_INFO;\n    }\n\n    protected function run(StatusReportingContextInterface $context): array\n    {\n        return [\n            $this-&gt;supportsTopic() =&gt; true,\n            'demo' =&gt; [\n                'username' =&gt; 'root',\n                'password' =&gt; 'password',\n            ],\n        ];\n    }\n}</code></pre> <p>The status reporter provides static information about possible debug configuration that does not need to be calculated. This can contain various of different types of information that suits the portal needs.</p>"},{"location":"guides/portal-developer/upgrade/","title":"Upgrade portals","text":"<p>When starting development of a portal it is always useful when using the latest version of the portal base package.  This guide will show you how to keep your portal up to the latest changes so you can profit from the new features.</p>"},{"location":"guides/portal-developer/upgrade/#changelogs","title":"Changelogs","text":"<p>Like every good software we provide publicly the changelogs for our open source packages as CHANGELOG.md next to the source code. They are also included in this documentation. See them in our release overview. They are written to be understood by human and machines and follow the principles of the keep a changelog proejct.</p>"},{"location":"guides/portal-developer/upgrade/#applying-the-changelogs","title":"Applying the changelogs","text":"<p>Your portal makes use of a few HEPTAconnect packages at the same time, so you have to read and understand multiple changelogs. This is a big task to overview the changes and apply them. We can help you to upgrade on multiple ways:</p> <ul> <li>Each entry in the change contains a technical information like a class name and a reason for the change.   This way you can relate the technical information to your code and think about the change reason and apply it to your code.</li> <li>The technical information as previously mentioned is also written to be understood by a machine.   You can save a lot of time using the <code>check:upgrade</code> command in the upcoming HEPTAconnect SDK.   It will skim through your code and our changelogs to supply hints to you about the upcoming upgrade. </li> </ul>"},{"location":"guides/portal-developer/patterns/http-client-middleware-dumping-on-bad-request/","title":"HttpClientMiddleware dumping HTTP messages on a \"bad request\" response","text":"<p>This pattern shows how to:</p> <ul> <li>access portal node specific filesystem using the FilesystemInterface</li> <li>record outbound request-response pairs using a HttpClientMiddlewareInterface</li> <li>dump HTTP messages using Psr7MessageFormatterContract</li> </ul>"},{"location":"guides/portal-developer/patterns/http-client-middleware-dumping-on-bad-request/#portal","title":"Portal","text":""},{"location":"guides/portal-developer/patterns/http-client-middleware-dumping-on-bad-request/#srchttpclientmiddlewarebadrequestsdumpingmiddlewarephp","title":"src/Http/Client/Middleware/BadRequestsDumpingMiddleware.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Portal\\Http\\Client\\Middleware;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nfinal class BadRequestsDumpingMiddleware implements HttpClientMiddlewareInterface\n{\n    private Psr7MessageFormatterContract $formatter;\n\n    private FilesystemInterface $filesystem;\n\n    public function __construct(Psr7MessageFormatterContract $formatter, FilesystemInterface $filesystem)\n    {\n        $this-&gt;formatter = $formatter;\n        $this-&gt;filesystem = $filesystem;\n    }\n\n    public function process(RequestInterface $request, ClientInterface $handler): ResponseInterface\n    {\n        $response = $handler-&gt;sendRequest($request);\n\n        if (400 &lt;= $response-&gt;getStatusCode() &amp;&amp; $response-&gt;getStatusCode() &lt; 500) {\n            $dumpDir = $this-&gt;filesystem-&gt;toStoragePath(sprintf('bad-requests/%s-%s-', time(), uniqid()));\n            $message = $this-&gt;formatter-&gt;formatMessage($request);\n            $extension = $this-&gt;formatter-&gt;getFileExtension($request);\n\n            file_put_contents($dumpDir . 'request.' . $extension, $message);\n\n            $message = $this-&gt;formatter-&gt;formatMessage($response);\n            $extension = $this-&gt;formatter-&gt;getFileExtension($response);\n\n            file_put_contents($dumpDir . 'response.' . $extension, $message);\n        }\n\n        return $response;\n    }\n}</code></pre>"},{"location":"guides/portal-developer/patterns/list-files-from-filesystem/","title":"List files from filesystem","text":"<p>This pattern shows how to:</p> <ul> <li>To access portal node specific filesystem using the FilesystemInterface</li> </ul>"},{"location":"guides/portal-developer/patterns/list-files-from-filesystem/#portal","title":"Portal","text":""},{"location":"guides/portal-developer/patterns/list-files-from-filesystem/#srcresourcesflow-componentlist-filesphp","title":"src/Resources/flow-component/list-files.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract;\n\nFlowComponent::statusReporter(StatusReporterContract::TOPIC_INFO)\n    -&gt;run(static function (FilesystemInterface $fs): array {\n        $files = new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($fs-&gt;toStoragePath('/')));\n        $paths = [];\n\n        /** @var \\SplFileInfo $file */\n        foreach ($files as $file) {\n            $paths[] = $file-&gt;getPath();        \n        }\n\n        return [\n            StatusReporterContract::TOPIC_INFO =&gt; true,\n            'files' =&gt; $paths,\n        ];\n    });</code></pre>"},{"location":"guides/portal-developer/patterns/serve-file-from-filesystem-using-http-handler/","title":"Serve a file from filesystem using HTTP handler","text":"<p>This pattern shows how to:</p> <ul> <li>To access portal node specific filesystem using the FilesystemInterface</li> <li>To response with a binary file using an HTTP handler</li> </ul>"},{"location":"guides/portal-developer/patterns/serve-file-from-filesystem-using-http-handler/#portal","title":"Portal","text":""},{"location":"guides/portal-developer/patterns/serve-file-from-filesystem-using-http-handler/#srcresourcesflow-componentlist-filesphp","title":"src/Resources/flow-component/list-files.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\n\nFlowComponent::httpHandler('logo.png')\n    -&gt;get(static function (\n        FilesystemInterface $fs,\n        ResponseInterface $response,\n        StreamFactoryInterface $streamFactory\n    ): ResponseInterface {\n        $path = $fs-&gt;toStoragePath('logo.png');\n\n        if (!is_file($path)) {\n            return $response-&gt;withStatus(404);\n        }\n\n        return $response\n            -&gt;withStatus(200)\n            -&gt;withHeader('Content-Type', 'image/png')\n            -&gt;withBody($streamFactory-&gt;createStreamFromFile($path));\n    });</code></pre>"},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/","title":"File reference with public URLs","text":"<p>This pattern shows how to:</p> <ul> <li>Let two portals transfer a file via file references</li> <li>Add configuration to a portal to toggle behaviour</li> <li>Separate API usage from entity processing</li> </ul>"},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/#portal-a","title":"Portal A","text":""},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/#srcresourcesflow-componentmedia-emitphp","title":"src/Resources/flow-component/media-emit.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract;\n\nFlowComponent::explorer(Media::class)\n    -&gt;run(static fn (): iterable =&gt; [\n        'https://picsum.photos/seed/php/300/300',\n        'https://picsum.photos/seed/is/300/300',\n        'https://picsum.photos/seed/nice/300/300',\n    ]);\n\nFlowComponent::emitter(Media::class)\n    -&gt;run(static function (string $externalId, FileReferenceFactoryContract $fileReferenceFactory): Media {\n        $result = new Media();\n        $result-&gt;setPrimaryKey($externalId);\n        // externalId is a URL as used in the explorer a few lines above\n        $result-&gt;setFile($fileReferenceFactory-&gt;fromPublicUrl($externalId));\n        return $result;\n    });</code></pre>"},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/#portal-b","title":"Portal B","text":""},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/#srcresourcesflow-componentmedia-receivephp","title":"src/Resources/flow-component/media-receive.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse Heptacom\\HeptaConnect\\Documentation\\PortalB\\Api\\Client;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract;\nuse Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract;\n\nFlowComponent::receiver(Media::class)\n    -&gt;run(static function (Media $entity, FileReferenceResolverContract $fileReferenceResolver, Client $client, bool $configUpload): void {\n        $resolvedFile = $fileReferenceResolver-&gt;resolve($entity-&gt;getFile());\n\n        if ($configUpload) {\n            $mediaLocation = $client-&gt;uploadBlob($resolvedFile);\n        } else {\n            $mediaLocation = $client-&gt;importBlob($resolvedFile);\n        }        \n\n        $entity-&gt;setPrimaryKey($mediaLocation);\n    });</code></pre>"},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/#srcportalphp","title":"src/Portal.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Documentation\\PortalB;\n\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass Portal extends PortalContract\n{\n    public function getConfigurationTemplate(): OptionsResolver\n    {\n        return parent::getConfigurationTemplate()\n            -&gt;addAllowedTypes('upload', 'bool')\n            -&gt;setDefault('upload', false);\n    }\n}\n</code></pre>"},{"location":"guides/portal-developer/patterns/transfer-file-reference-by-public-url/#srcapiclientphp","title":"src/Api/Client.php","text":"<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Heptacom\\HeptaConnect\\Documentation\\PortalB\\Api;\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientContract;\nuse Psr\\Http\\Client\\ClientInterface;\nuse Psr\\Http\\Message\\RequestFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\n\nclass Client\n{\n    private ClientInterface $client;\n\n    private RequestFactoryInterface $requestFactory;\n\n    private StreamFactoryInterface $streamFactory;\n\n    public function __construct(\n        HttpClientContract $client,\n        RequestFactoryInterface $requestFactory,\n        StreamFactoryInterface $streamFactory\n    ) {\n        $this-&gt;client = $client;\n        $this-&gt;requestFactory = $requestFactory;\n        $this-&gt;streamFactory = $streamFactory;\n    }\n\n    public function uploadBlob(FileReferenceContract $file): string\n    {\n        $request = $this-&gt;requestFactory-&gt;createRequest('POST', 'https://onlineshop.test/api/media/upload');\n        $request = $request-&gt;withHeader('Content-Type', 'application/octet-stream');\n        $request = $request-&gt;withBody($this-&gt;streamFactory-&gt;createStream(\n            $file-&gt;getContents()\n        ));\n        $response = $this-&gt;client-&gt;sendRequest($request);\n\n        return $response-&gt;getHeaderLine('Location');\n    }\n\n    public function importBlob(FileReferenceContract $file): string\n    {\n        $request = $this-&gt;requestFactory-&gt;createRequest('POST', 'https://onlineshop.test/api/media/import');\n        $request = $request-&gt;withHeader('Content-Type', 'application/json');\n        $request = $request-&gt;withBody($this-&gt;streamFactory-&gt;createStream(\\json_encode([\n            'url' =&gt; $file-&gt;getPublicUrl(),\n        ])));\n        $response = $this-&gt;client-&gt;sendRequest($request);\n\n        return $response-&gt;getHeaderLine('Location');\n    }\n}</code></pre>"},{"location":"guides/portal-developer/patterns/transfer-files-from-ftp-server/","title":"Send files from an FTP server","text":"<p>This pattern will focus on files from an FTP server, but your file source can really be anything. Let's assume the following problem:</p> <p>A PIM system acts as your data source for products and this PIM also holds product images. These product images are stored on an FTP server and the PIM only provides you with their file paths on this FTP server.</p> <p>Files on an FTP server are not accessible via HTTP, so we cannot use the source types \"Public URL\" or \"HTTP request\". So it seems, this leaves us with \"File contents\" as our last resort. But this would mean that files are downloaded from the FTP server to an intermediate storage and are later loaded from this intermediate storage to be sent to some destination.</p> <p>In an effort to eliminate obsolete I/O operations we can utilize HTTP handlers to tunnel the FTP access through HTTP. Instead of downloading the file during exploration, we can instead generate a presigned URL to an HTTP handler that will perform the download later. We can then use the presigned URL as \"Public URL\" source. Here is all you need to make it happen.</p> <pre><code>use Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerUrlProviderInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\n\nFlowComponent::explorer(Media::class, function (\n    PortalStorageInterface $portalStorage,\n    HttpHandlerUrlProviderInterface $urlProvider,\n    FileReferenceFactoryContract $fileReferenceFactory\n): iterable {\n    // Let's assume you query your data source for product media files.\n    // Your data source stores media files on a FTP server and this is the file path you get.\n    $filePath = 'product-data/images/12890437256/cover.jpg';\n\n    // The plan is to generate a URL that will return the contents of your media file.\n    // But the data on the FTP server must still be protected, so we add a secret token to the URL.\n    // The URL will only return the image, if the query parameters contain a valid token.\n    $secretToken = \\bin2hex(\\random_bytes(32));\n\n    // We store the token in the portal-storage for 4 hours.\n    // After this time the token is automatically invalidated.\n    $portalStorage-&gt;set(\n        $secretToken,\n        $filePath,\n        new \\DateInterval('PT4H')\n    );\n\n    // Using the url-provider, we can generate a URL for an HTTP handler called \"tunnel/ftp\".\n    // We pass the token and the file path as query parameters, so the HTTP handler can work with them.\n    $presignedUrl = (string) $urlProvider-&gt;resolve('tunnel/ftp')-&gt;withQuery(\\http_build_query([\n        'token' =&gt; $secretToken,\n        'filePath' =&gt; $filePath,\n    ]));\n\n    // Now we use the file-reference-factory to create a file-reference from our newly generated URL.\n    $fileReference = $fileReferenceFactory-&gt;fromPublicUrl($presignedUrl);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('12890437256_cover');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});\n\nFlowComponent::httpHandler('tunnel/ftp', function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    PortalStorageInterface $portalStorage,\n    StreamFactoryInterface $streamFactory,\n    FtpDownloader $ftpDownloader\n): ResponseInterface {\n    // This HTTP handler is supposed to validate a given token and respond with the contents of the requested file path.\n\n    $secretToken = $request-&gt;getQueryParams()['token'];\n    $filePath = $request-&gt;getQueryParams()['filePath'];\n\n    if ($portalStorage-&gt;get($secretToken) !== $filePath) {\n        // The token is either not valid for the requested file path or has already expired.\n        // In this case we do not send any contents but use HTTP code 401 \"Unauthorized\".\n        return $response-&gt;withStatus(401);\n    }\n\n    // The token is valid for the requested file path.\n    // We delete the token now, so the presigned URL is \"read-once\".\n    $portalStorage-&gt;delete($secretToken);\n\n    try {\n        // Download the file using a ftp-downloader class.\n        // The downloader class is not part of HEPTAconnect and must be provided by your portal.\n        // Its purpose is to provide a simplified and authenticated FTP client.\n        // The implementation is not shown here, because that is not the focus of this example.\n        $fileContents = $ftpDownloader-&gt;downloadFile($filePath);\n        $fileMimeType = $ftpDownloader-&gt;getMimeType($filePath);\n    } catch (NotFoundException $exception) {\n        // The file was not found on the FTP server.\n        // We send no contents but use HTTP code 404 \"Not Found\".\n        return $response-&gt;withStatus(404);\n    }\n\n    // We have successfully downloaded the file from the FTP server.\n    // Now we send its contents and mime-type and use HTTP code 200 \"OK\".\n    return $response\n        -&gt;withStatus(200)\n        -&gt;withHeader('Content-Type', $fileMimeType)\n        -&gt;withBody($streamFactory-&gt;createStream($fileContents));\n});</code></pre>"},{"location":"news/","title":"HEPTAconnect News","text":"<p>Our latest news articles.</p> Code execution in REPL <p>Development and production intervention sometimes need a REPL</p> Joshua Behrens on 2023-08-15 HTTP middlewares for clients and servers <p>Interception points for HTTP requests and responses in every direction</p> Joshua Behrens on 2023-02-14 New repository: HEPTAconnect production template <p>Kickstart your new HEPTAconnect integration projects</p> Julian Krzefski on 2022-11-29 File reference for direct and fast file transfer <p>Tunnel file transfer and make best use of external APIs</p> Julian Krzefski on 2022-06-07"},{"location":"news/#release-changelogs","title":"Release changelogs","text":"<p>See our releases on our changelog overview.</p>"},{"location":"news/#get-changes-right-into-your-notification-feed","title":"Get changes right into your notification feed","text":"<p>Subscribe to the RSS feeds:</p> <ul> <li>RSS</li> <li>Atom</li> <li>JSON</li> </ul> <p>Or follow us on Twitter.</p> <p>See all our news.</p> <ul> <li>Initialization of a feed</li> <li>shopcast.fm appearance</li> <li>Data flows and direct emission exploration</li> <li>HEPTAconnect and playground support for Shopware 6.4</li> <li>Queue and job memory utilization reduction up to 95%</li> <li>Symfony dependency injection for portal developers</li> <li>Short notation for flow components</li> <li>Easy batch just like step-by-step runs</li> <li>New Documentation</li> <li>HTTP handler flow component</li> <li>Changelogs for safer and understandable updating</li> <li>Documentation at source code level</li> <li>Release 0.9.0.0</li> <li>Exception and log messages in action</li> <li>File reference for direct and fast file transfer</li> <li>New repository: HEPTAconnect production template</li> <li>HTTP middlewares for clients and servers</li> <li>Code execution in REPL</li> </ul>"},{"location":"news/2021-02-02-init/","title":"Initialization of a feed","text":"<p>To react to community feedback we will start a feed to summarize every now and then interesting changes in this feed.</p> <p>This does not replace the ADR section at all. As we have a lot of repositories and this will be a channel to summarize the news that are shared across the packages. This will also be the way to get informed about new packages as we follow our flexible package structure.</p>"},{"location":"news/2021-02-08-shopcast/","title":"shopcast.fm appearance","text":"<p>Edin Dedagic - host at the German podcast shopcast.fm - invited us to have a talk about HEPTACOM as part of the Shopware community and the guest Joshua Behrens. It was inevitable to talk as well about HEPTAconnect. A lot about HEPTAconnect which even results in a split into two parts.</p> <p>Have a deep dive into two hours of HEPTAconnect knowledge and its creators: </p> <ul> <li>Part 1</li> <li>Part 2</li> </ul>"},{"location":"news/2021-03-23-data-flow-explorer/","title":"Data flows and direct emission exploration","text":"<p>In the recent past we decided to allow explorers behave like emitters to allow easier processing of inefficient-to-read data sources. We call this direct emission. How to prepare your explorer for a direct emission is explained in the direct emission explorer page. To show the differences in the data flow we introduce a place where you can find multiple scenarios on the new data flow overview.</p> <p>Coming soon: We are currently setting up an integration guide that holds up our integration knowledge and explains our decisions that you should consider as well. Stay tuned to let your next project experience the full data transfer expertise.</p>"},{"location":"news/2021-05-23-playground-shopware-6-4/","title":"HEPTAconnect and playground support for Shopware 6.4","text":"<p>A wave of huge changes hit the playground and ironed some kinks.</p> <p>The major update at Shopware from 6.3 to 6.4 has been rolled out onto the HEPTAconnect packages. To experience Shopware 6.4 with HEPTAconnect you can now easily grab yourself a fresh copy of the playground and dive in.  To allow the playground be used with your familiar ecommerce framework in a more complete manner you will now find an integrated <code>shopware/administration</code>. This way you can use the playground to fiddle with HEPTAconnect within Shopware and in addition also with Shopware itself after importing your favorite data.</p> <p>How to get your favorite data in, you might ask? Just use the bundled shopware platform portal. On creating the shopware instance in the playground you will get a portal node for the shopware instance as well as for the artificial portal for bottles. Require other portals you can already find online on GitHub under the tag heptaconnect-portal into the shopware composer.json. They are automatically discovered for you to draw your first routes between the portal nodes.</p> <p>What is that /repos/ folder at root level? We had a look at the contribution and experimenting flow we currently provide and chose to rework that. The new folder contains every HEPTAconnect package as a clone from GitHub. They are linked into the vendor folder. Having the different packages on this directory level makes it much easier to discover and change HEPTAconnect. As they are clones from GitHub it also allows a direct way to share your work on HEPTAconnect in a bleeding edge manner.</p> <p>How can you know all of this? The documentation got a truck load of new content about: * the playground * commands</p> <p>Some of these new pages are also linked within this article so have a look around.</p>"},{"location":"news/2021-05-31-queue-and-job-storage/","title":"Queue and job memory utilization reduction up to 95%","text":"<p>This week we completed our ADR about jobs. Working on that issue really created lots of space for further tasks in the architecture of HEPTAconnect as well as on the storage layer used for the message broker. </p> <p>In detail, we've been using the message broker to completely keep the data in question for each transfer. Read our ADR about jobs and their payloads to follow our thoughts but here are the basic pros:</p> <ul> <li>When emptying a message queue, the messages can be reconstructed</li> <li>The message provider has fewer data to store</li> <li>It is easy to change job types and payload structures</li> </ul> <p>We were testing the storage sizes on a default Shopware 6 setup. It uses php serialization to store messages on the database. After our change we only store a job reference in the message and store the payload on the database. Our referenced payload takes up from 40% to 95% less memory on the same database driver than in the message table. The following tasks benefit from the size difference:</p> <ul> <li>database query times</li> <li>database backup sizes</li> <li>message broking on various providers</li> <li>restoring and duplicating systems</li> </ul> <p>Above mentioned the architecture also draws a big benefit from that change: As we now have the job payloads separated from their execution scheduling, it is easier to add reference between these jobs. This is especially useful for SAT algorithms that will make their way into HEPTAconnect one day.</p>"},{"location":"news/2021-06-21-symfony-dependency-injection/","title":"Symfony dependency injection for portal developers","text":""},{"location":"news/2021-06-21-symfony-dependency-injection/#tldr","title":"TL;DR","text":"<p>Write less. \\ Achieve more in less time. \\ Look at your results faster.</p> <p>Read more about Dependency injection and the new default utilities.</p>"},{"location":"news/2021-06-21-symfony-dependency-injection/#preamble","title":"Preamble","text":"<p>One of our main goals for HEPTAconnect is the ability to replace lots of different implementations to gain a frictionless integrability. When we were looking for the service container feature, we had an issue to solve: As service container builders have not been addressed in the PSR-11, we had to implement service container and builder. The custom implementation holds a 47 lines-of-code container implementation, a 36 lines-of-code container builder and a single entry point for portal developers in their code.</p>"},{"location":"news/2021-06-21-symfony-dependency-injection/#what-we-achieved","title":"What we achieved","text":"<p>We were able to get yet another PSR compatibility and its benefits: build and share reusable components. By now our implementation of a service container is about half a year old, and we are missing features. We didn't expect our small implementation to have it all right away, but it is a bit impractical in daily usage.</p> <ul> <li>Tagged services are missing</li> <li>Every service had to have a service definition</li> <li>Service decoration was possible but very unpleasant</li> <li>Services could only be pulled out of the container</li> </ul> <p>It served the purpose, but it wasn't quite right.</p>"},{"location":"news/2021-06-21-symfony-dependency-injection/#what-we-were-looking-for","title":"What we were looking for","text":"<p>Basically we were looking for what we were missing:</p> <ul> <li>Tagged services</li> <li>Write no boilerplate service definitions (in the best case)</li> <li>Easy service decoration</li> <li>Dependency injection (instead of pulling)</li> </ul> <p>We were accustomed to the Symfony and Laravel worlds having all these features. Laravel didn't make the cut for us as it is difficult to pull Illuminate components out of their ecosystem. Symfony gave us similar expectations back when we noticed Bundles are part of the HttpKernel and also quite baked into the Symfony framework <code>/rant</code>.</p>"},{"location":"news/2021-06-21-symfony-dependency-injection/#the-future-is-now","title":"The future is now","text":"<p>On our search for a good implementation for service containers with dependency injection we stumbled upon a benchmark. The Symfony implementation was most of the time in second place but had all we ever wanted. So we revisited that package and were happy to see that it had barely any dependencies which is good for an almost frictionless package. Having the service definition files based on xml and yml also allows portal developers to define services without knowing the exact Symfony version behind the scenes.</p> <p>We gave the implementation a try and got hooked right back into it. Enabling all the nice things and sprinkling some more educated guesses into the container builder gave us the shiny new developer experience for portal developers we always wanted to provide:</p> <ul> <li>Even in bigger scenarios there is no definition file needed as we are using the composer.json of the portal for prototyping definitions</li> <li>Auto-wiring allows for smart service injection guesses</li> <li>Auto-configuration allows for smart service kind detection</li> <li>Integrations are now able to alter the containers almost effortlessly</li> <li>Flow components (explorer, emitter, receivers) and status reporters can make use of dependency injection</li> <li>Portal developers are most likely from a Laravel or Symfony background and should be already quite familiar with the logic behind the scenes</li> </ul>"},{"location":"news/2021-06-21-symfony-dependency-injection/#documentation","title":"Documentation","text":"<p>When you already had a deeper look into our documentation, you can notice the reduction of boilerplate code in almost every portal developer code sample. We added a new chapter to the documentation under portal development containing everything you need to know to use dependency injection with the new service container. This way we also took the chance to provide a complete list of utility service we provide out of the box.</p>"},{"location":"news/2021-07-12-short-notation/","title":"Short notation for flow components","text":""},{"location":"news/2021-07-12-short-notation/#tldr","title":"TL;DR","text":"<p>Write less. \\ Achieve more in less time. \\ Look at your results faster.</p> <p>Read more about short notation for flow components.</p>"},{"location":"news/2021-07-12-short-notation/#preamble","title":"Preamble","text":"<p>No, the TL;DR is not a copy mistake from the previous feed entry about dependency injection. We once more achieved to improve the developer experience by adding more tools to reduce your boilerplate code. Summarizing our ADR you can now stop writing sections of code and start to write lines of code. Previously you had to write:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace FooBar\\Emitter;\n\nuse FooBar\\Packer\\BottlePacker;\nuse FooBar\\Service\\ApiClient;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract;\n\nclass BottleEmitter extends EmitterContract\n{\n    private ApiClient $client;\n\n    private BottlePacker $packer;\n\n    public function __construct(ApiClient $client, BottlePacker $packer)\n    { \n        $this-&gt;client = $client;\n        $this-&gt;packer = $packer;\n    }\n\n    public function run(string $externalId, EmitContextInterface $context) : ?DatasetEntityContract\n    {\n        return $this-&gt;packer-&gt;pack($this-&gt;client-&gt;getBottleData($externalId));\n    }\n}</code></pre> <p>Sieve out the boilerplate lines and you have:</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nuse FooBar\\Packer\\BottlePacker;\nuse FooBar\\Service\\ApiClient;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\n\nFlowComponent::emitter(Bottle::class)-&gt;run(\n    fn (ApiClient $client, BottlePacker $packer, string $id) =&gt; $packer-&gt;pack($client-&gt;getBottleData($id))\n);</code></pre> <p>When this reminds you of Laravel routes and commands, you are right. This is heavily inspired by Laravel's nature of quickly scribbling down some lines to get something big running. To get an overview of the short notation and how to use it visit the documentation page.</p>"},{"location":"news/2021-07-23-easy-batch/","title":"Easy batch just like step-by-step runs","text":""},{"location":"news/2021-07-23-easy-batch/#tldr","title":"TL;DR","text":"<p>Train in step-by-step. \\ Run in batches.</p> <p>Read more about the way how to batch in short notation for flow components and flow components like emitter and receiver.</p>"},{"location":"news/2021-07-23-easy-batch/#batches-and-step-by-step-runs","title":"Batches and step by step runs","text":"<p>Every emitting or receiving flow component can improve on performance when data is processed in batches. In general HEPTAconnect groups data into batches to allow the flow components to be able to act in reasonable batch sizes. The documentation in the past only explained how to make a single step-by-step API interactions. Running through a data transfer in such a sequential manner is due to its complexity better to outline its inner statements. The flow component loops that unrolled the batches into single steps are now accessible for child classes to override. Compare the following real life examples how to receive manufacturer data to its successor within Shopware 6:</p> <pre><code>&lt;?php\n\nuse Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Manufacturer;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalAccess;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker;\n\nFlowComponent::receiver(Manufacturer::class)-&gt;run(static fn (\n    DalAccess $dal,\n    Manufacturer $manufacturer,\n    Unpacker\\ManufacturerUnpacker $unpacker\n) =&gt; $dal-&gt;createSyncer()-&gt;upsert('product_manufacturer', [$unpacker-&gt;unpack($manufacturer)])-&gt;flush());</code></pre> <pre><code>&lt;?php\n\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection;\nuse Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Manufacturer;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalAccess;\nuse Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker;\n\nFlowComponent::receiver(Manufacturer::class)-&gt;batch(static fn (\n    DalAccess $dal,\n    TypedDatasetEntityCollection $manufacturers,\n    Unpacker\\ManufacturerUnpacker $unpacker\n) =&gt; $dal-&gt;createSyncer()-&gt;upsert('product_manufacturer', $manufacturers-&gt;map([$unpacker, 'unpack']))-&gt;flush());</code></pre> <p>There is basically no difference. Your project can make use of this today when you are in the lucky position to have a batch-ready API, and you've been following architectural patterns to use packer and unpacker services.</p>"},{"location":"news/2021-08-10-new-documentation/","title":"New Documentation","text":""},{"location":"news/2021-08-10-new-documentation/#tldr","title":"TL;DR","text":"<ul> <li>New domain</li> <li>New style</li> <li>New search</li> <li>New diagrams</li> <li>New PDF export</li> </ul> <p>Maybe you already noticed it: We have a beautiful new documentation website, and we think you will love it. Our new website is based on the material theme for MkDocs with some customizations and it's rocking a bunch of new and improved features.</p> <p>The HEPTAconnect documentation is now available under a new domain: heptaconnect.io. We have moved from a subdomain under heptacom.de to a dedicated domain and we are also using the .io domain ending.</p> <p>Perhaps the most notable change are the stunning visuals. The main landing page shows the HEPTAconnect logo and prominently advertises the four most important sections of the documentation. Have you noticed the glowing backdrop behind the cards when you hover over them?</p> <p>Speaking of sections: We have restructured our content into different sections. Most of our existing content went into Portal Developer and Reference. The sections Integrator and Administrator are completely new and bring different perspectives into the documentation. Truth be told, they are not finished yet. But we have big plans to extend the documentation with new content for them, so stay tuned.</p> <p>And when we are already on the topic of staying tuned: We noticed that most RSS readers don't update as frequently as we would like them to. So starting from today we will additionally publish our blog entries on Twitter. So if your RSS reader is giving you trouble, feel free to follow us there.</p> <p>Let's get back to the star of today's show: The new documentation website has an amazing new search function. A big problem we had with the search on the old website was the small space where the search results would get crammed into. Search results were nearly indistinguishable from one another rendering them downright useless. The new search bar makes use of all the space it can get to give results that are actually helpful.</p> <p>If you are hyped to try it out, a good first search term would be \"Basic flow\". The first result will take you to a brand-new page with our new sequence diagrams to visualize how data flows through HEPTAconnect. Those diagrams show both the perspective of a portal and the perspective of HEPTAconnect core components during an exploration, an emission and a reception in a basic flow. Let us know if they could help you to better grasp the big picture.</p> <p>And there is still more. MkDocs has another trick up its sleeve. The entire documentation is available for download as a PDF file with a cover page and a linked table of contents. So when your client demands a copy of the documentation, it's just one click away. Take a look on the left side of the footer.</p> <p>Last but not least, the switch from docsify to MkDocs means that our documentation is finally visible for Google and other search engines. So hopefully you can soon find your answers even faster from your favourite search engine.</p>"},{"location":"news/2021-12-07-http-handler-flow-component/","title":"HTTP handler flow component","text":""},{"location":"news/2021-12-07-http-handler-flow-component/#tldr","title":"TL;DR","text":"<ul> <li>New flow component: HTTP handler</li> </ul> <p>In the last news the new documentation structure and engine have been celebrated. Now we can suggest once again to read into the new pages about our new flow component: HTTP handler. This new component already has some configuration which can be managed as administrator that can be read upon in the HTTP APIs page of the administrator section.</p>"},{"location":"news/2021-12-07-http-handler-flow-component/#underlying-technology","title":"Underlying technology","text":"<p>We rely fully on <code>PSR-7</code> and <code>PSR-17</code>. Unfortunately <code>PSR-15</code> does not fit into our just released HTTP handler structure. It behaves similar to other flow components in terms of stacked processing, extensibility by portal extensions and integrations, ability to write definition in a short-notation and an object-oriented manner.</p>"},{"location":"news/2021-12-07-http-handler-flow-component/#new-flow-options","title":"New flow options","text":"<p>In the past you had to be an integration to host an HTTP controller to create an event driven flow over HTTP messages. With HTTP handlers at hand you can now use incoming web requests and transfer them into publications or already a direct emission. We already use it in the Business Central portal to build an OAuth 2 authentication flow. The following example shows how to convert an incoming request into a publication of external ids about new data that is ready to pick up.</p> <pre><code>use Heptacom\\HeptaConnect\\Playground\\Dataset\\Bottle;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nFlowComponent::httpHandler('bottle')-&gt;post(static function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    PortalNodeKeyInterface $portalNodeKey\n): ResponseInterface {\n    $bottleIds = \\json_decode($request-&gt;getQueryParams()['bottle-ids']);\n\n    $bottleMappings = \\array_map(static fn (string $bottleId) =&gt; new MappingComponentStruct(\n        $portalNodeKey,\n        Bottle::class,\n        $bottleId\n    ), $bottleIds);\n\n    $this-&gt;publisher-&gt;publishBatch(new MappingComponentCollection($bottleMappings));\n\n    return $response-&gt;withStatus(201);\n});</code></pre> <p>Direct emission based flows can be created quickly when you already use packers to pack API data into HEPTAconnect entities. With packers at hand you can use the request body, pass it into the packer and use the packed entity directly into the DirectEmissionFlow.</p>"},{"location":"news/2022-01-11-changelogs/","title":"Changelogs for safer and understandable updating","text":""},{"location":"news/2022-01-11-changelogs/#tldr","title":"TL;DR","text":"<ul> <li>Feature focussed changelogs</li> <li>Human-readable</li> <li>Machine-readable</li> <li>Guides for portal developer and integrator.</li> </ul> <p>With the release of version 0.7 we started to add changelogs. These are important news and therefore reside in our news section. There you can find a human-readable and easy to browse version of the changelogs. So with each upcoming release of HEPTAconnect you should check out the documentation about the new changes and get excited.</p>"},{"location":"news/2022-01-11-changelogs/#why-is-that-important-to-me","title":"Why is that important to me?","text":"<p>Updating to the most recent version of HEPTAconnect is always a combination of:</p> <ul> <li>Oh, something new I want to use to write less code in the future</li> <li>Oh, something new I can adapt to improve performance or flexibility</li> <li>Oh, something broke, and I should check my tuned application as well</li> </ul> <p>So you can check your version of HEPTAconnect using <code>$ composer show heptacom/heptaconnect-\\*</code>, understand the news and compare.</p>"},{"location":"news/2022-01-11-changelogs/#how-do-i-understand","title":"How do I understand?","text":"<p>That is super easy as we write them in a non code-exclusive focussed view to explain the changes of the public API. We are focussing on feature based logs so the generic changes of a <code>git diff</code> turns into a human understandable view on the change. The keep a changelog project thinks alike, therefore we follow its guidelines for a good changelog. To summarize: Every version has a clear title with a semantic version and the release date. Each version has a section filled changes grouped by their classification of additions, changes, deprecations, removals, fixes and security fixes.</p> <p>Looking at the changelog lines you will see they always reveal quite technical information. We add them to the messages to visualize a clear connection of features to code components. It makes it easy to research for unique code components and understand why they have been changed. When we do package internal changes you won't see them as they probably won't bother you. Don't worry though, when we change e.g. database interactions this is often considered an internal change but still resides under the changes classification for e.g. resources usage reasons.</p>"},{"location":"news/2022-01-11-changelogs/#how-do-i-compare","title":"How do I compare?","text":"<p>You have to take every log and look up whether it affects your code changes as every log should contain enough technical reference. When you have a match you can understand the connected feature and apply the knowledge.</p> <p>The process sounds correct but tedious, right? We thought so as well, so we decided to snoop around one step ahead again and had a look on how to automate this, so we all have less to do again.</p>"},{"location":"news/2022-01-11-changelogs/#how-do-i-upgrade-my-code","title":"How do I upgrade my code?","text":"<p>So we like our code a bit magical but still reasonable. As we do it ourselves, we are aware how people can turn PHP into anything. Therefore, we can't provide an automatic upgrade yet, but we are working on a tool which either supports or fixes code automatically for you. We prepared guides to do upgrades for portal developers and integrators as well for contributors which we will both upgrade regularly.</p>"},{"location":"news/2022-04-19-code-documentation/","title":"Documentation at source code level","text":""},{"location":"news/2022-04-19-code-documentation/#tldr","title":"TL;DR","text":"<ul> <li>Easy queryable documentation within source code</li> <li>Documentation on interfaces and contracts</li> </ul> <p>With the release of 0.9 we started to document every interface and contract. This way we ensure clear communication how to use the interface as an API consumer and as an API provider.</p> <p>Adding documentation on source code is a delicate discussion topic in most developer conversations. We evaluated our experience with other documentations and were (and still are) really happy with the approach of the PSR composer packages. When looking at e.g. the <code>\\Psr\\Log\\LoggerInterface</code>, there is a common description at the interface and a short hint on every method. In everyday usage it was nice to use a logger instance, navigate to the interface symbol or one of the methods and see right away how the intended use is. A similar pattern can be seen in the documentation stubs PHPStorm ships for native PHP functions. This kept the developer in the IDE without losing their focus.</p> <p>We see the possibility that these comments may go out of date. To prevent this from happening too often, we decided to only write expected usage and possible implementation hints. With this rule of thumb we are not fixed to a certain implementation that may change over time. Instead, we use the intended use case as comment when the component was introduced so everyone shares the same expectation.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/","title":"Release 0.9.0.0","text":""},{"location":"news/2022-04-26-release-0-9-0-0/#tldr","title":"TL;DR","text":"<ul> <li>Fast file transfers</li> <li>Flow component stacking re-imagined with more configuration</li> <li>Improved performance and stability for management storage</li> <li>Flexible portal node configurations by the integration environment</li> <li>Improved API Design<ul> <li>Feature-rich HTTP client</li> <li>More quality logging</li> <li>Reduction of technical debt</li> <li>Code documentation</li> </ul> </li> <li>Peek into the future for administrators</li> </ul>"},{"location":"news/2022-04-26-release-0-9-0-0/#release-09","title":"Release 0.9","text":"<p>Two weeks ago we released the first 0.9 version. To be more specific it is 0.9.0.0 and so the first version following the new version scheme described in this ADR. Updated changelogs for your updating strategy can be found in the release news section. Let's get more detailed and hydrate the TL;DR above.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#file-references","title":"File references","text":"<p>The file references are a new way to transfer files with the focus on availability via HTTP and reduction of I/O operations in the HEPTAconnect installation. The datasets and portals have been updated accordingly to use the new performant transport. See a sample usage here.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#flow-component-stacks","title":"Flow component stacks","text":"<p>Flow components are now loaded deferred and only grouped when used. This allows portal extensions to provide as much flexibility as portals in terms of flow components. New flexibilities are also given to portal extension developers and administrators as portal extension can now be deactivated on a stack and declared as optional.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#normalization-of-storage-actions","title":"Normalization of storage actions","text":"<p>We restructured the internal management storage handling to ensure the stability and performance it deserves. This includes a new package full of test scenarios against the storage base interfaces to allow also pre-built tests for any future storage provider. Read more here.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#flexible-portal-node-configuration","title":"Flexible portal node configuration","text":"<p>New utilities for integrators are now available to build automatically assigned portal node configurations by patterns. This enables various configurations sources like JSON files from hosting services or environment variables. Read more here.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#http-client","title":"HTTP client","text":"<p>We provide a new service for portals to make HTTP API usage a step easier. The PSR-18 compatible <code>HttpClientContract</code> is preconfigured to throw exceptions for 4XX and 5XX status codes, add missing headers, follow redirects and retry in case of an error or rate limit.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#logging","title":"Logging","text":"<p>When a flow component is put into the log context it will be swapped out with its code origin. This supports navigation to the source of an error, that is not identified by an exception.</p> <p>All our storage implementations start to add some form of unique identifier to the request, so it can be found more easily in the source code when found in logs.</p> <p>Even more log messages we write and exceptions we throw have unique identifiers for quick search in the code and in the online changelog.</p> <p>Jobs have a state history that can be inspected for processing and performance analysis.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#dependency-updates","title":"Dependency updates","text":"<p>The dependency version range is changed to keep everything up to date. This affects <code>doctrine/dbal</code>, <code>shopware/core</code>, <code>ramsey/uuid</code> and <code>dragonmantank/cron-expression</code> as library usage has been updated to match known deprecations and raised or removed. Read more about its details in the changelogs.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#developer-experience","title":"Developer Experience","text":"<p>As HEPTAconnect is looking to achieve a state-of-the-art experience on using our API, we improved our API design by ensuring to use <code>final</code> more frequently without removing extensibility. To ensure code documentation browsing is easy, we add it to a lot of places within the code.  Even small subtleties are taken into account like <code>$this</code> in short notation flow components now refers to the wrapping object-oriented flow component.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#administrators","title":"Administrators","text":"<p>Everyone managing an HEPTAconnect instance on setup can now use <code>--bidirectional</code> on <code>heptaconnect:router:add</code> to also create a route in the reverse direction. More CLI commands are supporting JSON output for easier scripting use. Spoiler alert: There is a huge change coming to raise the quality bar for administrator tools in the not so distant future.</p>"},{"location":"news/2022-04-26-release-0-9-0-0/#future","title":"Future","text":"<p>Follow the news section by subscribing to the RSS feeds:</p> <ul> <li>RSS</li> <li>Atom</li> <li>JSON</li> </ul> <p>Or follow us on Twitter to get more insights on the briefly touched topics in here in the future.</p>"},{"location":"news/2022-05-17-exception-and-log-message-codes/","title":"Exception and log messages in action","text":""},{"location":"news/2022-05-17-exception-and-log-message-codes/#tldr","title":"TL;DR","text":"<ul> <li>Log messages and exceptions have unique codes</li> <li>Documentation explains these codes</li> <li>These are not correlation identifiers</li> </ul>"},{"location":"news/2022-05-17-exception-and-log-message-codes/#unique-codes","title":"Unique codes","text":"<p>Since the version of 0.8 we add unique codes to exceptions and log messages. The full explanation can be read in this ADR.</p> <p>In short: these unique codes are quickly looked out for. Either online in our documentation or your IDE. They describe a point in the source code and keeps consistent in meaning even after an update.</p>"},{"location":"news/2022-05-17-exception-and-log-message-codes/#documenting-the-codes","title":"Documenting the codes","text":"<p>Although we use the unique codes for log messages and exceptions, you will likely only look them up because you are a first-responder to an issue of your system. So whenever you get a code from your log message's metadata you can just look them up in the search of our documentation. In general, you get a single hit within changelogs when the code has been introduced. There can be more hits, when the code has been moved to a different place or removed. In this scenario you can match by your installed HEPTAconnect version to find your issue. As these codes are part of our public API and are in the changelogs, you will find a technical reference and a human-readable meaning to it.</p> <p>The real life scenario could now be something like this:</p> <p>When there is the exception code 123 in your logs, and you find this message in the changelogs:</p> <p>Add code <code>123</code> in <code>\\Heptacom\\HeptaConnect\\TechnicalReference::doSomething</code> when JSON configuration file is invalid JSON.</p> <p>And someone recently edited a JSON file, you can combine these hints and find a solution on your own. As the changelogs are shipped with the code, you can also find this hint with a <code>grep</code> call in your installation. When you search the files, you will also find that single piece of code that triggered the exception right away.</p> <p>This will make first-responders more helpful and independent.</p>"},{"location":"news/2022-05-17-exception-and-log-message-codes/#correlation-identifiers","title":"Correlation identifiers","text":"<p>When we talk about codes in log messages, we should point out that these are not correlation identifiers. Correlation identifiers could only be queried in the HEPTAconnect installation as they identify a single situation like a specific web request or a job run.</p> <p>To keep posted with our news, that will definitely contain information on correlation ids once they are released, subscribe our feeds: </p> <ul> <li>RSS</li> <li>Atom</li> <li>JSON</li> </ul> <p>Or follow us on Twitter.</p>"},{"location":"news/2022-06-07-file-references/","title":"File reference for direct and fast file transfer","text":""},{"location":"news/2022-06-07-file-references/#tldr","title":"TL;DR","text":"<ul> <li>Don't store any files to transfer publicly hosted content</li> <li>Tunnel FTP access (and other protocols) through HTTP for more versatile usage</li> <li>Avoid obsolete I/O operations whenever possible</li> </ul> <p>With the release of 0.9 we introduce a new feature for portal developers to vastly improve performances of file transfers. Previously, transferring files always required to write them to an intermediate storage and later read them from this storage again. The new FileReferences will respect the source of a file and choose the optimal transfer method accordingly. A portal developer can choose from three available file sources:</p> <ol> <li>Public URL<ul> <li>An HTTP request with the GET method will be responded with the file contents.   No authentication will be performed.</li> </ul> </li> <li>HTTP Request<ul> <li>This HTTP request will be responded with the file contents.   Every aspect of the request can be customized.</li> </ul> </li> <li>File contents<ul> <li>The raw file contents are provided directly.   This is the only source that leads to I/O operations in the intermediate storage.</li> </ul> </li> </ol> <p>These three strategies already cover many use cases. Here are some example usages for each source type:</p> <pre><code>use Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract;\nuse League\\Flysystem\\Filesystem;\nuse Psr\\Http\\Message\\RequestFactoryInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\n\nFlowComponent::explorer(Media::class, function (\n    FileReferenceFactoryContract $fileReferenceFactory\n): iterable {\n    $publicUrl = 'https://picsum.photos/seed/php/300/300';\n\n    $fileReference = $fileReferenceFactory-&gt;fromPublicUrl($publicUrl);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('ad9e5b8a46364e019d9b3045b5172623');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});\n\nFlowComponent::explorer(Media::class, function (\n    FileReferenceFactoryContract $fileReferenceFactory,\n    RequestFactoryInterface $requestFactory,\n    StreamFactoryInterface $streamFactory\n): iterable {\n    $request = $requestFactory\n        -&gt;createRequest('POST', 'https://private-image-server.test/api/download-image/28664337703749c49af4bf198e94c396')\n        -&gt;withHeader('Authorization', 'Basic aGVwdGFjb25uZWN0OmlzIGNvb2w=')\n        -&gt;withBody($streamFactory-&gt;createStream(\\json_encode([\n            'foo' =&gt; 'bar'\n        ])));\n\n    $fileReference = $fileReferenceFactory-&gt;fromRequest($request);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('ad9e5b8a46364e019d9b3045b5172623');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});\n\nFlowComponent::explorer(Media::class, function (\n    FileReferenceFactoryContract $fileReferenceFactory,\n    Filesystem $filesystem\n): iterable {\n    $fileContents = $filesystem-&gt;read('data/images/a2ef9e0ef17e4b3585041ea36c4cde13/1.jpg');\n\n    $fileReference = $fileReferenceFactory-&gt;fromContents($fileContents);\n\n    $mediaEntity = new Media();\n    $mediaEntity-&gt;setPrimaryKey('ad9e5b8a46364e019d9b3045b5172623');\n    $mediaEntity-&gt;setFile($fileReference);\n\n    yield $mediaEntity;\n});</code></pre> <p>We recommend to avoid using the source type \"File contents\", because it leads to I/O operations and preventing those will greatly improve performance. In an effort to prevent usages of \"File contents\" and therefore improve performance, you can utilize HTTP handlers to tunnel file downloads through HEPTAconnect. The idea is to generate a URL to be used as \"Public URL\" file source. This URL points to an HTTP handler that will perform the file download and return its contents as its response body. Take a look at the new article Send files from an FTP server to learn more about this topic and see our example code.</p>"},{"location":"news/2022-11-29-production-template/","title":"New repository: HEPTAconnect production template","text":""},{"location":"news/2022-11-29-production-template/#tldr","title":"TL;DR","text":"<ul> <li>New repository: Production template</li> <li>Kickstart your own projects</li> <li>More documentation coming soon\u2122</li> </ul>"},{"location":"news/2022-11-29-production-template/#template-repository-for-production-ready-integrations","title":"Template repository for production-ready integrations","text":"<p>HEPTAconnect is (at its core) completely framework-agnostic. That means, it can virtually be integrated into any kind of PHP-based application. This approach makes HEPTAconnect highly versatile, but it also requires integrating HEPTAconnect into an application to provide a runtime environment.</p> <p>We aim to make setting up HEPTAconnect projects as simple as possible, so we created a template repository to kickstart your projects. This repository is designed to be forked and then adjusted to your requirements. Here you can check out our HEPTAconnect production template repository on GitHub and fork it yourself. You can also use <code>composer create-project</code> to start your new project.</p> <pre><code>composer create-project heptaconnect/production my-project -s dev</code></pre> <p>At this point you should take a look at the <code>README.md</code> file. There you will find a quick introduction and useful first steps.</p> <p>This repository template is our recommendation to create new projects with HEPTAconnect. We will continue to maintain it to stay up to date with the latest HEPTAconnect releases. We also use this repository internally to kickstart our own HEPTAconnect integrations.</p>"},{"location":"news/2022-11-29-production-template/#future","title":"Future","text":"<p>Currently, the production template depends on <code>shopware/core</code> for some dev-ops utilities and uses it as runtime environment for HEPTAconnect. While this is not really a problem, we aim to be fully independent from <code>shopware/core</code> to trim down on our required composer packages. We have that planned for version 0.10 of HEPTAconnect.</p> <p>Furthermore, we plan to release more documentation content about the production template. As of now, the <code>README.md</code> file inside the repository is the only documentation for it. More detailed documentation that covers more use cases will follow soon\u2122 in the Integrator section on the HEPTAconnect documentation website.</p>"},{"location":"news/2023-02-14-http-middleware/","title":"HTTP middlewares for clients and servers","text":""},{"location":"news/2023-02-14-http-middleware/#tldr","title":"TL;DR","text":"<ul> <li>Support for PSR-15 middlewares for HTTP handlers</li> <li>PSR-15 is not enough, so we add HTTP middlewares for HTTP clients as well</li> </ul>"},{"location":"news/2023-02-14-http-middleware/#http-handlers","title":"HTTP handlers","text":"<p>With HTTP handlers we already solved different challenges in the past:</p> <ul> <li>We built visual setup wizards, which are able to handle OAuth2 authorization flows.</li> <li>We built development tools, which we reuse in our own projects.</li> <li>We react to webhooks and we build a lot of other stuff.</li> </ul> <p>So many use cases, where we could use an abstraction layer to share common code efficiently.  Good news: <code>PSR-15</code> solves this problem conceptually.</p> <p>With 0.9.2 we added support for PSR-15 middlewares for HTTP handlers. This means, you can add middlewares to your portal, which are automatically applied to all inbound HTTP requests and responses. Using this very powerful concept allows you to add custom logic like authorization, logging, caching, etc. to your portal.</p>"},{"location":"news/2023-02-14-http-middleware/#http-clients","title":"HTTP clients","text":"<p>PSR-15 is unfortunately not made for HTTP clients. The PSR-7 HTTP client can already have shared common code with the use of decorators, which are very similar to PSR-15 middlewares. Using these decorators is a good and known strategy but it is not as easy to use as the automatically applied PSR-15 middlewares.  Therefore, we created our own middleware interface for HTTP clients, that is similar to PSR-15 middleware specification.</p> <p>These two middleware interfaces will support you to build your own helpful tools for your project. Have a look at the documentation pages for the PSR-15 middleware interface and the HTTP client middleware interface to learn more about the interfaces and how to use them.</p>"},{"location":"news/2023-08-15-code-execution-in-repl/","title":"Code execution in REPL","text":""},{"location":"news/2023-08-15-code-execution-in-repl/#tldr","title":"TL;DR","text":"<ul> <li>REPLs allow code execution without prior writing and deployment</li> <li>psysh is a ready to use REPL for PHP</li> <li>Once you <code>composer require psysh</code> you can use <code>heptaconnect:repl</code>, which integrates psysh into HEPTAconnect</li> </ul>"},{"location":"news/2023-08-15-code-execution-in-repl/#what-is-a-repl","title":"What is a REPL?","text":"<p>REPL stands for Read-Eval-Print-Loop. It is a common pattern in programming languages to provide a way to execute code without prior writing and deployment. You are likely familiar with this pattern from the browser console or the <code>php -a</code>/<code>php --interactive</code> command. The <code>php -a</code> command is a REPL for PHP, that is shipped with the PHP interpreter itself. Try it out yourself by simply typing <code>php -a</code> into your terminal and execute a command like <code>var_dump(new DateTime())</code>. It will print the current date and time. The execution did not stop though. You can execute multiple commands in a row now by entering a new command. This is where the loop comes in. It will keep executing commands until you exit the REPL by typing <code>exit</code> or pressing <code>Ctrl+D</code>.</p>"},{"location":"news/2023-08-15-code-execution-in-repl/#what-is-psysh","title":"What is psysh?","text":"<p>The php interactive mode is a very simple REPL, that does not provide any additional features you are used to from IDEs or other development tools. psysh is a REPL for PHP written in PHP itself and shipped as a standalone package, that can be used as a replacement for <code>php --interactive</code>. In comparison, it is a very powerful REPL, that provides a lot of features, that you know from your IDE. You can look up code behind classes, read documentation, autocomplete code and much more. It is really versatile and that is why we integrated it into HEPTAconnect.</p>"},{"location":"news/2023-08-15-code-execution-in-repl/#how-to-use-psysh-with-heptaconnect","title":"How to use psysh with HEPTAconnect?","text":"<p>Once you <code>composer require psysh</code> you can use the <code>heptaconnect:repl</code> command, which integrates psysh into HEPTAconnect. It will automatically load a portal node container of your choice and provide you with a REPL, that is already configured to work with that specific portal node.</p> <p>As example you can paste the following code into the REPL and execute it:</p> <pre><code>service(\\Psr\\Log\\LoggerInterface::class)-&gt;info('Hello World');</code></pre> <p>This will log the message <code>Hello World</code> to the portal node specific logger. You can access any service out of the portal node container and execute any code you want.</p>"},{"location":"reference/","title":"Reference","text":"<p>Here you find technical references about design decisions, graphical representations and plain lists of information.</p>"},{"location":"reference/#plain-information","title":"Plain information","text":""},{"location":"reference/#glossary","title":"Glossary","text":"<p>So we are all on the same page. </p>"},{"location":"reference/#license","title":"License","text":"<p>See our open source license.</p>"},{"location":"reference/#graphical-references","title":"Graphical references","text":""},{"location":"reference/#package-structure","title":"Package structure","text":"<p>See all the components of the framework coming together.</p>"},{"location":"reference/#data-flows","title":"Data flows","text":"<p>See different data flows.</p>"},{"location":"reference/#basic-data-flow-in-detail","title":"Basic data flow in detail","text":"<p>See the three components of the basic flow in detail.</p>"},{"location":"reference/#architecture-decision-records","title":"Architecture Decision Records","text":""},{"location":"reference/glossary/","title":"Glossary","text":"<p>There are several types of classes or entities referenced throughout this documentation. To have a uniform understanding of their meanings they are listed here with a short definition and explanation.</p>"},{"location":"reference/glossary/#flow-components","title":"Flow components","text":""},{"location":"reference/glossary/#explorer","title":"Explorer","text":"<p>An <code>Explorer</code> reads ids from the source and publishes them for emission. This is suitable for initial object discovery in the data source and successive data transfer via emissions.</p>"},{"location":"reference/glossary/#emitter","title":"Emitter","text":"<p>An <code>Emitter</code> reads data from the endpoint or data storage of a <code>PortalNode</code>, prepares the data in a structured form and then emits these structs. When it is asked to read data, a collection of <code>Mappings</code> is passed to its <code>emit</code> method. It is the <code>Emitters</code> job to connect to its data source and read the data (identified by the passed <code>Mappings</code>). The data should then be structured as a collection of <code>MappedDatasetEntityStructs</code> and returned or yielded.</p>"},{"location":"reference/glossary/#direct-emitter","title":"Direct Emitter","text":"<p>An <code>Explorer</code> that does the work like an <code>Emitter</code> as it reads and yields complete objects instead of ids from the source and release them for emission. This is suitable for faster object transfer or transfer that is triggered only by the source portal.</p>"},{"location":"reference/glossary/#receiver","title":"Receiver","text":"<p>A <code>Receiver</code> receives a collection of <code>DatasetEntities</code> and writes the data to the endpoint or data storage of a <code>PortalNode</code>.  When it is asked to write data, it traverses over the given collection, writes the data and retrieves an external identifier from the endpoint of the <code>PortalNode</code>. This identifier is then set in the given mapping and the collection of mappings is returned or yielded.</p>"},{"location":"reference/glossary/#portal","title":"Portal","text":"<p>A <code>Portal</code> is the implementation of an endpoint to connect it via HEPTAconnect. When you want to provide connectivity for an external API or some other form of data storage, you implement a portal. So a portal is just a name for the composition of code (e.g. a composer package) that is necessary for HEPTAconnect to communicate with an endpoint.</p>"},{"location":"reference/glossary/#portalnode","title":"PortalNode","text":"<p>A <code>Portal</code> is not the connection to an endpoint but the implementation of an endpoint. A <code>Portal</code> can then be configured with customizable fields. These fields may hold information like API-URLs, user credentials, file locations and so on. A configured <code>Portal</code> that is ready to communicate to an endpoint or data storage is called a <code>PortalNode</code>. A single <code>Portal</code> can potentially be used for many <code>PortalNodes</code>.</p>"},{"location":"reference/glossary/#portalregistry","title":"PortalRegistry","text":"<p>The <code>PortalRegistry</code> is provided by HEPTAconnect and can be used as a factory for <code>PortalNodes</code>. When a component has an identifier of a <code>PortalNode</code> and needs the corresponding instance to interact with it, this service should be used to retrieve the instance.</p>"},{"location":"reference/glossary/#bridge","title":"Bridge","text":"<p>The <code>Bridge</code> implements the core functionality in a certain environment by providing services for behaviours of the core that are dependent on the runtime of the surrounding application. As HEPTAconnect is environment agnostic it is not specified by default which database server, ORM, message broker, request cycle manager, request routing or file storage is in use.</p>"},{"location":"reference/glossary/#publisher","title":"Publisher","text":"<p>The <code>Publisher</code> is a central service that can be accessed by a <code>Bridge</code> to create <code>Mappings</code> for new entities. Publishing means, you target one specific object inside one specific <code>PortalNode</code> and have HEPTAconnect create a <code>Mapping</code> for it. The <code>Publisher</code> will prepare and schedule the freshly created <code>Mapping</code> for the <code>Emitter</code>. This happens asynchronously, so a <code>Publisher</code> will not take up a lot of computing time and it can be called during a web request with minimal performance impact.</p>"},{"location":"reference/glossary/#morpher","title":"Morpher","text":"<p>A <code>Morpher</code> is a special form of <code>PortalNode</code>. <code>Morphers</code> can receive various data types and store the entities temporarily. When certain conditions are met, the <code>Morpher</code> triggers its own <code>Emitter</code> to emit processed data. This could be used to collect different aspects of an entity and resolve dependencies. A <code>Morpher</code> could e.g. collect orders, addresses and customers and keep the data to itself until every sub-entity of the order has been received (a. k. a. all dependencies are resolved). After that the <code>Morpher</code> will emit a compound <code>DatasetEntity</code> with all the necessary data.</p>"},{"location":"reference/glossary/#packer","title":"Packer","text":"<p>A <code>Packer</code> is a class that supports <code>Flow components</code> like <code>Direct Emitter</code> and <code>Emitter</code> packing API specific data into <code>DatasetEntities</code>. This naming has been really helpful in the past to find the right entrypoint when extending other portals. There is no interface or contract to follow.</p>"},{"location":"reference/glossary/#unpacker","title":"Unpacker","text":"<p>An <code>Unpacker</code> is a class that supports <code>Flow components</code> like <code>Receiver</code> unpacking <code>DatasetEntities</code> into portal API specific payloads. This naming has been really helpful in the past to find the right entrypoint when extending other portals. There is no interface or contract to follow.</p>"},{"location":"reference/glossary/#dataset","title":"Dataset","text":"<p>A <code>Dataset</code> is a collection of common data structs that various <code>Portals</code> can rely on. There are different <code>Datasets</code> for different use cases and even some compound <code>Datasets</code> (e.g. <code>ecommerce</code>) that consist of multiple smaller <code>Datasets</code> (e.g. <code>physical-location</code>). <code>Datasets</code> are required by <code>Portals</code> to have a shared understanding of data and to establish communication between them.</p>"},{"location":"reference/glossary/#datasetentity","title":"DatasetEntity","text":"<p>A single entity in a <code>Dataset</code> is called a <code>DatasetEntity</code>. They are used to have a common data structure to pass objects from one <code>Portal</code> to another. Effectively a <code>Portal</code> does not need to know other <code>Portals</code> but simply work with <code>DatasetEntities</code> that other <code>Portals</code> also work with. This way any two <code>Portals</code> that share support for common <code>Datasets</code> can be connected.</p>"},{"location":"reference/glossary/#mapping","title":"Mapping","text":"<p>A <code>Mapping</code> is used to identify an entity in a <code>PortalNode</code>. It has an external identifier that points to the foreign entity, a <code>PortalNode</code> identifier that points to the <code>PortalNode</code> and a <code>MappingNode</code>. A mapping can also exist without an external identifier when the goal is to describe the connection between a <code>DatasetEntity</code> and a <code>PortalNode</code> before the foreign entity exists in the <code>PortalNode</code>. In practise this is used with <code>Receivers</code> when the foreign entity is yet to be created. HEPTAconnect will prepare a <code>Mapping</code> with the <code>PortalNode</code> identifier and a <code>MappingNode</code> but it will leave the external identifier empty. During a reception taking place in a <code>Receiver</code> the entities receive primary keys after they've been sent to the portal's  API. After the <code>Receiver</code> finished its reception, any assigned primary key is passed to the management storage, which will store these external identifiers as mapping.</p>"},{"location":"reference/glossary/#mappingnode","title":"MappingNode","text":"<p>A <code>MappingNode</code> is used to associate various <code>Mappings</code> for different <code>PortalNodes</code> with each other. While one <code>Mapping</code> only points to a single foreign entity in a <code>PortalNode</code>, this is not enough to connect entities of different <code>PortalNodes</code> with each other. Every <code>Mapping</code> must have exactly one <code>MappingNode</code>, while one <code>MappingNode</code> can have multiple <code>Mappings</code>.</p>"},{"location":"reference/glossary/#identity-redirect","title":"Identity Redirect","text":"<p>An identity redirect has two mapping representations where one mapping points to another mapping with the aspect, that these mappings do not have to exist in the storage. It is used to bypass the singularity aspect of a mapping node and allows to connect multiple mappings on one portal node to a single mapping on a different portal node.</p>"},{"location":"reference/glossary/#router","title":"Router","text":"<p>The <code>Router</code> is a central point in the data flow between different <code>PortalNodes</code>. When an <code>Emitter</code> emits a collection of <code>DatasetEntities</code>, the <code>Router</code> will search for matching <code>Routes</code> with the corresponding <code>PortalNode</code> as source. It will then pass the collection of <code>DatasetEntities</code> to every <code>PortalNode</code> that is specified as target in these <code>Routes</code>.</p>"},{"location":"reference/glossary/#route","title":"Route","text":"<p>A <code>Route</code> defines a direction for data to flow from one <code>PortalNode</code> to another. After setting up various <code>PortalNodes</code> it is necessary to create some <code>Routes</code>. A <code>Route</code> has a source, a target and a data type.</p>"},{"location":"reference/glossary/#storage","title":"Storage","text":"<p>HEPTAconnect requires a form of storage in order to be functional. The storage is used to keep track of mappings, configurations and other data that is relevant to the system. All access to a storage provider is abstracted in the storage base and the core only relies on these interfaces.</p>"},{"location":"reference/glossary/#keys","title":"Keys","text":"<p>The storage provider alone has data sovereignty over the keys that are used to persist entities in the data storage. <code>Keys</code> can be obtained by a factory that is provided by the storage provider. A <code>Key</code> is a small data structure that is a valid identifier in its origin storage (e.g. an auto-incremented integer or a UUIDv4). The existence of a <code>Key</code> itself guarantees its validity.</p>"},{"location":"reference/license/","title":"License","text":"<p>Dual licensed under the GNU Affero General Public License v3.0 (the \"License\") and proprietary license; you may not use this project except in compliance with the License. You may obtain a copy of the AGPL License at https://spdx.org/licenses/AGPL-3.0-or-later.html. Contact us on our website for further information about proprietary usage.</p> <pre><code>                GNU AFFERO GENERAL PUBLIC LICENSE\n                   Version 3, 19 November 2007</code></pre> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p> <pre><code>                        Preamble</code></pre> <p>The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works.  By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.</p> <p>When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software.</p> <p>A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate.  Many developers of free software are heartened and encouraged by the resulting cooperation.  However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public.</p> <p>The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community.  It requires the operator of a network server to provide the source code of the modified version running there to the users of that server.  Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version.</p> <p>An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals.  This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p> <pre><code>                   TERMS AND CONDITIONS</code></pre> <ol> <li>Definitions.</li> </ol> <p>\"This License\" refers to version 3 of the GNU Affero General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License.  Each licensee is addressed as \"you\".  \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy.  The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy.  Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies.  Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License.  If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p> <ol> <li>Source Code.</li> </ol> <p>The \"source code\" for a work means the preferred form of the work for making modifications to it.  \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form.  A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities.  However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work.  For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p> <ol> <li>Basic Permissions.</li> </ol> <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met.  This License explicitly affirms your unlimited permission to run the unmodified Program.  The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work.  This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force.  You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright.  Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below.  Sublicensing is not allowed; section 10 makes it unnecessary.</p> <ol> <li>Protecting Users' Legal Rights From Anti-Circumvention Law.</li> </ol> <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p> <ol> <li>Conveying Verbatim Copies.</li> </ol> <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p> <ol> <li>Conveying Modified Source Versions.</li> </ol> <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <pre><code>a) The work must carry prominent notices stating that you modified\nit, and giving a relevant date.\n\nb) The work must carry prominent notices stating that it is\nreleased under this License and any conditions added under section\n7.  This requirement modifies the requirement in section 4 to\n\"keep intact all notices\".\n\nc) You must license the entire work, as a whole, under this\nLicense to anyone who comes into possession of a copy.  This\nLicense will therefore apply, along with any applicable section 7\nadditional terms, to the whole of the work, and all its parts,\nregardless of how they are packaged.  This License gives no\npermission to license the work in any other way, but it does not\ninvalidate such permission if you have separately received it.\n\nd) If the work has interactive user interfaces, each must display\nAppropriate Legal Notices; however, if the Program has interactive\ninterfaces that do not display Appropriate Legal Notices, your\nwork need not make them do so.</code></pre> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit.  Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p> <ol> <li>Conveying Non-Source Forms.</li> </ol> <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <pre><code>a) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by the\nCorresponding Source fixed on a durable physical medium\ncustomarily used for software interchange.\n\nb) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by a\nwritten offer, valid for at least three years and valid for as\nlong as you offer spare parts or customer support for that product\nmodel, to give anyone who possesses the object code either (1) a\ncopy of the Corresponding Source for all the software in the\nproduct that is covered by this License, on a durable physical\nmedium customarily used for software interchange, for a price no\nmore than your reasonable cost of physically performing this\nconveying of source, or (2) access to copy the\nCorresponding Source from a network server at no charge.\n\nc) Convey individual copies of the object code with a copy of the\nwritten offer to provide the Corresponding Source.  This\nalternative is allowed only occasionally and noncommercially, and\nonly if you received the object code with such an offer, in accord\nwith subsection 6b.\n\nd) Convey the object code by offering access from a designated\nplace (gratis or for a charge), and offer equivalent access to the\nCorresponding Source in the same way through the same place at no\nfurther charge.  You need not require recipients to copy the\nCorresponding Source along with the object code.  If the place to\ncopy the object code is a network server, the Corresponding Source\nmay be on a different server (operated by you or a third party)\nthat supports equivalent copying facilities, provided you maintain\nclear directions next to the object code saying where to find the\nCorresponding Source.  Regardless of what server hosts the\nCorresponding Source, you remain obligated to ensure that it is\navailable for as long as needed to satisfy these requirements.\n\ne) Convey the object code using peer-to-peer transmission, provided\nyou inform other peers where the object code and Corresponding\nSource of the work are being offered to the general public at no\ncharge under subsection 6d.</code></pre> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling.  In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage.  For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product.  A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source.  The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information.  But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed.  Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p> <ol> <li>Additional Terms.</li> </ol> <p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law.  If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it.  (Additional permissions may be written to require their own removal in certain cases when you modify the work.)  You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <pre><code>a) Disclaiming warranty or limiting liability differently from the\nterms of sections 15 and 16 of this License; or\n\nb) Requiring preservation of specified reasonable legal notices or\nauthor attributions in that material or in the Appropriate Legal\nNotices displayed by works containing it; or\n\nc) Prohibiting misrepresentation of the origin of that material, or\nrequiring that modified versions of such material be marked in\nreasonable ways as different from the original version; or\n\nd) Limiting the use for publicity purposes of names of licensors or\nauthors of the material; or\n\ne) Declining to grant rights under trademark law for use of some\ntrade names, trademarks, or service marks; or\n\nf) Requiring indemnification of licensors and authors of that\nmaterial by anyone who conveys the material (or modified versions of\nit) with contractual assumptions of liability to the recipient, for\nany liability that these contractual assumptions directly impose on\nthose licensors and authors.</code></pre> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10.  If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term.  If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p> <ol> <li>Termination.</li> </ol> <p>You may not propagate or modify a covered work except as expressly provided under this License.  Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p> <ol> <li>Acceptance Not Required for Having Copies.</li> </ol> <p>You are not required to accept this License in order to receive or run a copy of the Program.  Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance.  However, nothing other than this License grants you permission to propagate or modify any covered work.  These actions infringe copyright if you do not accept this License.  Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p> <ol> <li>Automatic Licensing of Downstream Recipients.</li> </ol> <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License.  You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations.  If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License.  For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p> <ol> <li>Patents.</li> </ol> <p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based.  The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version.  For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement).  To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients.  \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License.  You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p> <ol> <li>No Surrender of Others' Freedom.</li> </ol> <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all.  For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p> <ol> <li>Remote Network Interaction; Use with the GNU General Public License.</li> </ol> <p>Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software.  This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph.</p> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work.  The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License.</p> <ol> <li>Revised Versions of this License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number.  If the Program specifies that a certain numbered version of the GNU Affero General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions.  However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p> <ol> <li>Disclaimer of Warranty.</li> </ol> <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <ol> <li>Limitation of Liability.</li> </ol> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p> <ol> <li>Interpretation of Sections 15 and 16.</li> </ol> <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <pre><code>                 END OF TERMS AND CONDITIONS\n\n        How to Apply These Terms to Your New Programs</code></pre> <p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the program's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If your software can interact with users remotely through a computer network, you should also make sure that it provides a way for users to get its source.  For example, if your program is a web application, its interface could display a \"Source\" link that leads users to an archive of the code.  There are many ways you could offer source, and different solutions will be better for different programs; see section 13 for the specific requirements.</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU AGPL, see https://www.gnu.org/licenses/.</p>"},{"location":"reference/adr/2020-01-27-telemetry-recording/","title":"2020-01-27 - Telemetry recording","text":""},{"location":"reference/adr/2020-01-27-telemetry-recording/#context","title":"Context","text":"<p>API web requests, file system access, database requests, message queue dispatches, I/O interrupts, interprocess communication and similar interactions are part of any portal. The usage of these resources should be known to a certain degree for monitoring of usage compared against a usage limitation, order of calls across portal nodes and their time of action.</p>"},{"location":"reference/adr/2020-01-27-telemetry-recording/#decision","title":"Decision","text":"<p>The information have to be connected to a portal node and its structural resource subdivision. There is no context given as it is just about when and what kind of categories are affected. For example a processing involving the transport of a file does not contain the complete file but can be tagged with e.g. the mime type or encoding, \u2026. There need to be common decorators for common implementations to simplify automatic recording like PSR HTTP client. Adding common decorators in a global registry simplifies the usage of portal node developer that can depend on common decorator implementations. The telemetry entry only represents a single direction in a synchronous interaction and should represent two directions as two entries in an asynchronous interaction. Incoming web requests and cronjob runs are automatically recorded. Telemetry has to be optional by core configuration as the storage is impacted heavily and it can affect the performance. Storing telemetry data is not allowed to break the portal node flow by e.g. throwing an exception. Recording describes an incrementable reference object that stores the timestamps of each increment and is taggable.</p> <p>The exact way for analysis of the recorded data is up to discussion and postponed to a different point in time.</p>"},{"location":"reference/adr/2020-01-27-telemetry-recording/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2020-01-27-telemetry-recording/#pros","title":"Pros","text":"<ul> <li>Analysis of API usages helps to identify upcoming limitation breaks.</li> <li>By requests across portal nodes it helps to identify errors in flow and order.</li> <li>Taggable incrementable reference objects allow for data point analysis of groups and of fine grain later on.</li> </ul>"},{"location":"reference/adr/2020-01-27-telemetry-recording/#cons","title":"Cons","text":"<ul> <li>Although supporting infrastructure is given it adds a heavy complexity layer to portal node developers that needs to be simplified.</li> <li>Depending on the implementation the storage is heavily impacted by amount of data and frequent usage. This can end up in a project-wide bottleneck.</li> </ul>"},{"location":"reference/adr/2020-01-27-telemetry-recording/#how-to-use","title":"How to use","text":"<p>A suggested pattern is that portal class prepares API clients. They should be easily wrapped by a decorator whereas the instantiation should be lightweight. Any context is able to supply a telemetry accessor that can be passed to other services and decorators for easy usage.</p>"},{"location":"reference/adr/2020-01-27-telemetry-recording/#related-thoughts","title":"Related thoughts","text":"<p>The space reduction of the storage and performance impact can be accomplished by a recording instance that receives the prepared payloads via a message broker. Telemetry recording can be stored in-memory and flushed later for performance reasons. Telemetry should not be abused for success/failure metrics as this is part of internal analysis on mapping errors.</p>"},{"location":"reference/adr/2020-04-30-contracts-and-interfaces/","title":"2020-04-30 - Contracts and interfaces","text":""},{"location":"reference/adr/2020-04-30-contracts-and-interfaces/#context","title":"Context","text":"<p>There has to be a guide how to structure code to allow extendability. We have to ensure that functionality can be exchanged without interfering with adjacent packages within the package hierarchy.</p>"},{"location":"reference/adr/2020-04-30-contracts-and-interfaces/#decision","title":"Decision","text":"<p>The approved approach is using the language feature type hierarchy. Using interfaces, traits and contracts (abstract classes) is a good way to structure and allow replacements by ensuring certain behaviors.</p> <p>We use interfaces when multiple implementation will exist and are unknown at any time for the package that it is introduced in. For example, we do not know what kind of storage is used within the portal-base, but it will need some kind of storage.</p> <p>To supply some basic logic for commonly used interfaces we can provide traits for others to implement them easier.</p> <p>We use contracts similar to interfaces but use their advantages to contain any logic beforehand. This enables us to add additional code later with a reduced level of changes that can be non-breaking without removing the replacing option. Contracts are best without dependencies that have to be given in the constructor as this forces other implementations to follow this pattern regardless whether they need it.</p>"},{"location":"reference/adr/2020-04-30-contracts-and-interfaces/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2020-04-30-contracts-and-interfaces/#pros","title":"Pros","text":"<ul> <li>Others can build their own logic and replace existing one more easily</li> </ul>"},{"location":"reference/adr/2020-04-30-contracts-and-interfaces/#cons","title":"Cons","text":"<ul> <li>This adds more complexity in designing functionality as decisions have to be made whether interfaces or contracts are best suited</li> </ul>"},{"location":"reference/adr/2020-08-10-architecture-decision-records/","title":"2020-08-10 - Architecture decision records","text":""},{"location":"reference/adr/2020-08-10-architecture-decision-records/#context","title":"Context","text":"<p>We document architecture and technical decisions for HEPTAconnect. Inspired by https://github.com/shopware/platform/ we follow the same principles and use ADRs to keep track of decision making to make it easier to understand why things are how they are:</p> <ul> <li>A Simple but Powerful Tool to Record Your Architectural Decisions</li> <li>Documenting Architecture Decisions</li> <li>When should I write an Architecture Decision Record</li> </ul>"},{"location":"reference/adr/2020-08-10-architecture-decision-records/#decision","title":"Decision","text":"<p>Having the ADRs as part of the versioning adds more pros:</p> <ul> <li>Decisions remain in sync with the code itself</li> <li>The Git history is also the decision history</li> <li>Decisions are public available and accessible for every developer</li> <li>Also external developers can add new ADRs via GitHub pull requests</li> </ul>"},{"location":"reference/adr/2020-08-10-architecture-decision-records/#consequences","title":"Consequences","text":"<p>Every architectural change or addition should contain a Markdown file like this to have a brief understanding what are the pros, cons and how it should be used. Until the release of version 1.0.0 it is ok to add ADRs for decisions made in the past. This is the reason why you probably find ADRs with a timestamp before we decided to add ADRs.</p> <p>ADRs have to approved by a maintainer when they are proposed by a contributor. As a past ADR can't be changed it has to be marked as deprecated by copying it into the deprecated folder, change the original file to link to the copy and refer to the new superseeding ADR.</p>"},{"location":"reference/adr/2020-08-10-architecture-decision-records/#how-does-an-adr-look-like","title":"How does an ADR look like?","text":"<p>You can use this first ADR as an orientation. The filename of the ADR should contain the date and a meaningful title. The content of the ADR should always use the following template:</p> <pre><code># [Date] - [Title]\n## Context\n## Decision\n## Consequences\n### Pros\n### Cons\n### How to use\n## Related thoughts</code></pre>"},{"location":"reference/adr/2020-08-28-parallelization-locks/","title":"2020-08-28 - Parallelization locks","text":""},{"location":"reference/adr/2020-08-28-parallelization-locks/#context","title":"Context","text":"<p>In horizontally scaled processes problems of parallelization can happen like race conditions (a resource is accessed simultaneously by multiple processes and can have a different value for each process as a previous one wrote to the resource before).</p>"},{"location":"reference/adr/2020-08-28-parallelization-locks/#decision","title":"Decision","text":"<p>To support horizontal scaling there is also the need to allow resource locking. As the resource accessing is part of transmitting data over time or space, the storages and portals should be able to use this feature. Therefore we will put in the contracts into the portal-base. As locks need some sort of storage to maintain a lock state an additional repository has to be added to the storages.</p> <p>The featured methods shall be:</p> <ul> <li>isLocked</li> <li>lock</li> <li>release</li> </ul> <p>A utility class or methods to easily write spinlocks by time or iteration shall be added.</p> <p>Locks shall rather run out of time or a different measurement instead to unintentionally lock a resource.</p>"},{"location":"reference/adr/2020-08-28-parallelization-locks/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2020-08-28-parallelization-locks/#pros","title":"Pros","text":"<ul> <li>Horizontal scaling is easier to support for portals and storages</li> <li>It is easier to implement checks to prevent resource requests that should not be overlapping</li> </ul>"},{"location":"reference/adr/2020-08-28-parallelization-locks/#cons","title":"Cons","text":"<ul> <li>Portals and storages who uses this feature will perform worse than without using this feature</li> </ul>"},{"location":"reference/adr/2020-10-15-portal-status-reporters/","title":"2020-10-15 - Portal status reporters","text":""},{"location":"reference/adr/2020-10-15-portal-status-reporters/#context","title":"Context","text":"<p>A portal should have some kind of status page. It has to tell an administrating person and a health check automation whether the portal is in a good state.</p> <p>A good state can differ from the point of perspective. A configuration might be syntactically correct but is not able to setup an I/O connection to the datasource.</p>"},{"location":"reference/adr/2020-10-15-portal-status-reporters/#decision","title":"Decision","text":"<ul> <li>A portal and the portal extension have to be able to provide new status topics and have impact on the contents they report.</li> <li>Every reporter has to expose JSON serializable content for easy automation access.</li> <li>Every reporter should expose a boolean value keyed with the topics' key to determine whether the report displays a good state.</li> <li>Every portal should expose a status reporter for topic <code>health</code> when the portal interacts with a datasource connected via I/O operations to determine correct configuration and connectivity.</li> <li>Portal extensions have to prefix their own keys they expose with a reasonable identifier.</li> <li>Every topic should be accessible on their own.</li> <li>A status report should act fast and use as little I/O operations as possible to allow frequent health checks.</li> <li>A status report should be promoted for the following use cases:<ul> <li>static information that are not part of the providing composer package</li> <li>health check of the datasource connection</li> <li>portal internal behaviour analysis (last time usage, remaining API calls by time limitations)</li> <li>configuration support</li> </ul> </li> </ul>"},{"location":"reference/adr/2020-10-15-portal-status-reporters/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2020-10-15-portal-status-reporters/#pros","title":"Pros","text":"<ul> <li>A portal has a way to expose data independently of data transportation.</li> <li>Automated processes and humans can process this data.</li> <li>Health checks can be implemented in a standardized way for every portal.</li> <li>Multi-step configuration is easier to provide.</li> <li>Internal API usage can be exposed for behaviour analysis.</li> </ul>"},{"location":"reference/adr/2020-10-15-portal-status-reporters/#cons","title":"Cons","text":"<ul> <li>It can be misused for data reading that does not belong to the intended use cases.</li> </ul>"},{"location":"reference/adr/2020-10-15-portal-status-reporters/#how-to-use","title":"How to use","text":"<p>A command like <code>heptaconnect:portal-node:status PortalNode:123 health | jq -e .health</code> as a simple health check condition can be setup as crontab entry. An other example is <code>heptaconnect:portal-node:status PortalNode:123 config</code> to display possible values for further configuration.</p> <p>Regarding the usage of behaviour analysis it is suggested to compare the intended functionality to be achieved is compared against the telemetry feature as this allows a very specific way to deal with behaviour analysis.</p>"},{"location":"reference/adr/2020-10-30-job-messages-and-payload/","title":"2020-10-30 - Job messages and payloads","text":""},{"location":"reference/adr/2020-10-30-job-messages-and-payload/#context","title":"Context","text":"<p>In case of a structural change in a dataset you might need to migrate serialized data in a way to make in work with the latest code. The data that is affected of the structural change can still be within a message queue provider and is often out of access until message handling. You could unintentionally send duplicated messages to drain performance and increase I/O operations overall.</p>"},{"location":"reference/adr/2020-10-30-job-messages-and-payload/#decision","title":"Decision","text":"<ul> <li>Extract job actions from the messages into the storage.</li> <li>Separate job payloads from their actions.</li> <li>Prevent sending of duplicate messages.</li> <li>Normalize the structure of a job regarding the current message structure.</li> </ul>"},{"location":"reference/adr/2020-10-30-job-messages-and-payload/#consequences","title":"Consequences","text":"<p>This change adds a little overhead on the message dispatching but adds multiple benefits regarding upcoming structure changes and future I/O operations that can be prevented.</p>"},{"location":"reference/adr/2020-10-30-job-messages-and-payload/#pros","title":"Pros","text":"<ul> <li>Prevention of duplicate messages reduces handler calls and follow-up I/O operations.</li> <li>Message payloads can be accessed without knowledge about the used message provider.</li> <li>When emptying a message queue the messages can be reconstructed in a plausible order.</li> <li>The message provider has less data to store than before.</li> <li>It is easy to add new job types in the core without changing the storage.</li> </ul>"},{"location":"reference/adr/2020-10-30-job-messages-and-payload/#cons","title":"Cons","text":"<ul> <li>More I/O operations have to be done when the message handlers have to hydrate the message with the payload storage before processing can be continued.</li> <li>It is difficult to add new job types that are not similar to the existing jobs when there is a structural mismatch.</li> </ul>"},{"location":"reference/adr/2020-10-30-job-messages-and-payload/#related-thoughts","title":"Related thoughts","text":"<p>Datasets could use some sort of migration pattern which can be applied by the storage implementations onto their stored payload to react to a structural change. When a new job has to be introduced that is not related to this job pattern which is tied to mapping components a new message type can be introduced instead.</p>"},{"location":"reference/adr/2020-12-10-portal-service-container/","title":"2020-12-10 - Portal service container","text":""},{"location":"reference/adr/2020-12-10-portal-service-container/#context","title":"Context","text":"<p>Portal extensions shall be able to interfere with any operation the supported portal is doing to make any business logic within the supported portal adjustable. This is already possible having the explorer, emitter and receiver stacks when it is about changing the flow and the incoming data from HEPTAconnect and the outgoing data towards HEPTAconnect. There is no way yet to change the exact behaviour how an API is used within the supported portal. It has been suggested to expose the operational APIs as public methods in the supported portal class. Portal extension are able to interact with the same APIs like their supported portal but not yet able to change the implementation of these public methods.</p>"},{"location":"reference/adr/2020-12-10-portal-service-container/#decision","title":"Decision","text":"<ul> <li>Use PSR-11 containers</li> <li>Do not use inheritance / decoration between portal extensions and the portal itself</li> <li>Do not use a container builder as there is no common interface yet and is not needed yet</li> <li>Do not use a hook pattern</li> </ul>"},{"location":"reference/adr/2020-12-10-portal-service-container/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2020-12-10-portal-service-container/#pros","title":"Pros","text":"<ul> <li>Portal developers can decide what is allowed to be changed</li> <li>Portal and portal extension developers can use the commonly known container way of publishing services within an application</li> </ul>"},{"location":"reference/adr/2020-12-10-portal-service-container/#cons","title":"Cons","text":"<ul> <li>Portal developers have to publish every implementation to allow being changed</li> <li>Containers have to be managed per stack to prevent</li> <li>To have static typing you have to add additional <code>instanceof</code> checks or trust type hints</li> </ul>"},{"location":"reference/adr/2020-12-10-portal-service-container/#related-thoughts","title":"Related thoughts","text":"<p>One could use inheritance and decoration pattern to allow portal extension claim to be the supported portal but this moves all the development overhead to the developer</p> <p>There is a follow up to this regarding the exact implementation.</p>"},{"location":"reference/adr/2021-02-03-direct-emission-exploration/","title":"2021-02-03 - Direct emission exploration","text":""},{"location":"reference/adr/2021-02-03-direct-emission-exploration/#context","title":"Context","text":"<p>Data sources like plain tables (.csv, .tsv, .txt, .json, .xml) and slow/rate-limited APIs both share the fact that you want to keep the interaction count low. Plain tables need to be parsed and are missing an index for fast navigation wich reduces speed in reading and often uses computation time and memory. Rate-limited APIs should not be consumed twice for the same information. When they allow retrieving list data similar to single entries that should be preferred to allow for smart rate-limit usage.</p>"},{"location":"reference/adr/2021-02-03-direct-emission-exploration/#decision","title":"Decision","text":"<ul> <li>Allow emission to take place in the same moment as exploration</li> </ul>"},{"location":"reference/adr/2021-02-03-direct-emission-exploration/#consequences","title":"Consequences","text":"<ul> <li>There are now two places that can emit data and therefore the conversion logic from a data source payload to a HEPTAconnect dataset entity should be extracted</li> </ul>"},{"location":"reference/adr/2021-02-03-direct-emission-exploration/#pros","title":"Pros","text":"<ul> <li>Portal developers can support multiple data flows</li> <li>Named data source can be processed more efficient</li> <li>Portal developers do not have to cache data structures on exploration anymore for an efficient emission</li> </ul>"},{"location":"reference/adr/2021-02-03-direct-emission-exploration/#cons","title":"Cons","text":"<ul> <li>Portal developers have to decide which of the data flow models they want to support</li> <li>Additional complexity in the return type of explorers' explore method as this can change the data flow to a direct emission flow </li> </ul>"},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/","title":"2021-04-13 - Portal dependency injection implementation","text":""},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/#context","title":"Context","text":"<p>This is a follow-up to the ADR about general service containers.</p> <p>Dependency injection is a common pattern to create reusable components that can build upon each other. Portals will have to communicate with their API of choice in different flow components. Presumably a portal developer wants to build an API client that can be used within all flow components. This is where dependency injection comes in handy. Depending on the implementation this can also be used to decorate services which will add more freedom for modifications. We were able to provide a service container for each portal node matching PSR-11 in the past, which allowed easy access to services but no injection into flow components. There is the PSR-11 standard to define a service container but not a service container builder and therefore there are no drop in implementations.</p>"},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/#decision","title":"Decision","text":"<ul> <li>Use Symfony dependency injection</li> <li>Replace custom service container with Symfony</li> <li>Enable auto-wiring, auto-configuration, auto-binding and automatic PSR-4 resource loading</li> <li>Automatically load flow components and drop their definition from portals</li> </ul>"},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/#pros","title":"Pros","text":"<ul> <li>Portal developers are most likely familiar with Symfony dependency injection</li> <li>Using service definitions based on xml or yaml do not require a tight composer dependency and can be used fluently with different Symfony versions</li> <li>Symfony's dependency injection has a very good documentation</li> <li>Symfony's dependency injection supports tagged services</li> <li>Symfony's auto-wiring, auto-configuration, auto-binding and resource auto-loading allows for zero-configuration dependency injection out of the box for portal developers</li> </ul>"},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/#cons","title":"Cons","text":"<ul> <li>Portal developers need to know or learn Symfony dependency injection</li> </ul>"},{"location":"reference/adr/2021-04-13-portal-dependency-injection-implementation/#related-thoughts","title":"Related thoughts","text":"<p>We looked up comparisons of different dependency injection implementations and evaluated those against the criteria: * performance in building * performance in usage * the least friction against current and possible future dependencies</p> <p>Symfony's implementation isn't the best in that comparison paper, but it allows for compilation and is well known in our context of work. In the past we also saw very frictionless migrations between the Symfony versions using service definitions that are based upon xml and yaml.</p>"},{"location":"reference/adr/2021-06-17-flow-component-short-notation/","title":"2021-06-17 - Flow component short notation","text":""},{"location":"reference/adr/2021-06-17-flow-component-short-notation/#context","title":"Context","text":"<p>When a portal has its code separated into different domains, many flow components will look like this:</p> <pre><code>&lt;?php\n\ndefine(string_types=1);\n\nnamespace FooBar\\Emitter;\n\nuse FooBar\\Packer\\BottlePacker;\nuse FooBar\\Service\\ApiClient;\nuse Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface;\nuse Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract;\n\nclass BottleEmitter extends EmitterContract\n{\n    private ApiClient $client;\n\n    private BottlePacker $packer;\n\n    public function __construct(ApiClient $client, BottlePacker $packer)\n    { \n        $this-&gt;client = $client;\n        $this-&gt;packer = $packer;\n    }\n\n    public function run(string $externalId, EmitContextInterface $context) : ?DatasetEntityContract\n    {\n        return $this-&gt;packer-&gt;pack($this-&gt;client-&gt;getBottleData($externalId));\n    }\n}</code></pre> <p>This sample emitter of about 30 lines of code only consists of, when trimmed down to the essentials, two lines of instructions.</p> <p>Acquisition of dependencies:</p> <pre><code>public function __construct(ApiClient $client, BottlePacker $packer/*, string $externalId*/)</code></pre> <p>Wiring everything into an emitter run method:</p> <pre><code>return $this-&gt;packer-&gt;pack($this-&gt;client-&gt;getBottleData($externalId));</code></pre> <p>Using this perspective we have 28 lines of code that are basically boilerplate. Boilerplate code is code we want to eliminate.</p>"},{"location":"reference/adr/2021-06-17-flow-component-short-notation/#decision","title":"Decision","text":"<ul> <li>Allow declaration of flow components in a callback registration way.</li> </ul>"},{"location":"reference/adr/2021-06-17-flow-component-short-notation/#consequences","title":"Consequences","text":"<ul> <li>There are now two places that can define flow components</li> </ul>"},{"location":"reference/adr/2021-06-17-flow-component-short-notation/#pros","title":"Pros","text":"<ul> <li>Portal developers can wire their API clients to HEPTAconnect infrastructure in a very efficient way<ul> <li>Not extending certain classes</li> <li>Storing services dependencies in fields</li> <li>Dropping unused default parameters (like <code>$context</code>)</li> </ul> </li> <li>Portal developers do not have to use them</li> </ul>"},{"location":"reference/adr/2021-06-17-flow-component-short-notation/#cons","title":"Cons","text":"<ul> <li>Although discouraged, it is not possible to decorate the generated flow component services as the id naming is not predictable</li> <li>Code that follows PSR-4 is next to plain code in the same directory hierarchy</li> <li>The generated flow components can't make use of class inheritance features</li> </ul>"},{"location":"reference/adr/2021-06-17-flow-component-short-notation/#additional-thoughts","title":"Additional thoughts","text":"<p>This developer experience is heavily inspired from Laravel route definitions. Mixing PSR-4 compliant code with plain php is also done like this in Symfony bundles.</p>"},{"location":"reference/adr/2021-08-24-php-8-named-arguments/","title":"2021-08-24 - PHP 8.0 named arguments","text":""},{"location":"reference/adr/2021-08-24-php-8-named-arguments/#context","title":"Context","text":"<p>At one point the old RFC for named arguments got an update, has been approved and implemented. With the implementation of this feature a language aspect changes how public API is perceived. When using PHP &gt;=8.0 function arguments are not just positional but also associative and keyed by their name depending on the callers function calling behaviour.</p>"},{"location":"reference/adr/2021-08-24-php-8-named-arguments/#decision","title":"Decision","text":"<p>We do not support this feature and claim the argument names as private API. This includes to wrap calls for <code>func_get_arguments</code> in an <code>array_values</code> or similar approaches to remove names from parameters. This feature can be replicated to a certain degree with parameter classes the only contain the data for a method call in a single object, and therefore is not a language feature we depend on. We already use this occasionally with a trend towards this. This allows setting parameters by name via using their respective setter. It also has the same developer experience across PHP versions.</p>"},{"location":"reference/adr/2021-08-24-php-8-named-arguments/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2021-08-24-php-8-named-arguments/#pros","title":"Pros","text":"<ul> <li>Contributors to HEPTAconnect packages have one breaking change complexity layer less to work on</li> <li>Contributors to HEPTAconnect packages can apply the same backward compatibility promises across all supported PHP versions (which includes versions prior to this feature)</li> <li>Contributors to HEPTAconnect packages are allowed to rename parameters</li> </ul>"},{"location":"reference/adr/2021-08-24-php-8-named-arguments/#cons","title":"Cons","text":"<ul> <li>Users of HEPTAconnect packages can make use of this feature, but they should implement a test that targets this feature to ensure functionality using HEPTAconnect defined private API.</li> <li>HEPTAconnect can be evaluated as non-fully PHP 8 compatible</li> </ul>"},{"location":"reference/adr/2021-09-06-exception-and-log-message-codes/","title":"2021-09-06 - Exception and log message codes","text":""},{"location":"reference/adr/2021-09-06-exception-and-log-message-codes/#context","title":"Context","text":"<p>Making log messages that are helpful is difficult for various reason. You can not be sure which persona will read them (either administrator, integrator or portal developer). Therefore, phrasing a good message takes additional thoughts. Log messages in general just have a single line of text and some human-readable metadata that are crammed into the same line of text. Sometimes crucial data is left out of a log message. Most log messages are written when an exception is caught. Exceptions can have integer codes assigned. Exception codes are set on construction, which is in almost all cases the moment they are thrown.</p>"},{"location":"reference/adr/2021-09-06-exception-and-log-message-codes/#decision","title":"Decision","text":"<p>Exception stack traces are too big for log messages, so we need to refer to them in a different way. When we pass a unique code to the exception constructor, we can identify the source code that triggers the exception immediately. This makes exception codes a good alternative to stack traces. There are also log message written without the situation to log an exception. These message have no code from an exception but can benefit from a code to identify their origin as well. Exception codes and log message codes need documentation with a class reference and a reason for occurrence to supply information for an administrator and a developer.</p>"},{"location":"reference/adr/2021-09-06-exception-and-log-message-codes/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2021-09-06-exception-and-log-message-codes/#pros","title":"Pros","text":"<ul> <li>Every log message can have a code that identifies origin</li> <li>Codes can move with refactoring and can keep their meaning which is better than different stack traces for the same issue</li> <li>Codes can be looked up in the documentation with helpful information for any common first-responders</li> </ul>"},{"location":"reference/adr/2021-09-06-exception-and-log-message-codes/#cons","title":"Cons","text":"<ul> <li>A small changes like adding a log message is handled with additional complexity in a release</li> <li>More documentation needs to be written</li> </ul>"},{"location":"reference/adr/2021-09-25-optimized-storage-actions/","title":"2021-09-25 - Optimized storage actions","text":""},{"location":"reference/adr/2021-09-25-optimized-storage-actions/#context","title":"Context","text":"<p>In the past we were approaching an entity repository pattern for reading and writing HEPTAconnect internal data. This has been useful for building applications inside various frameworks in the past as their storages often come with a database abstraction layer that follows the same pattern. In any implementation that follows the entity repository pattern we have the issue that reading the data for different use cases is different and therefore performance varies significantly. When we started to extract reading access for mappings in different parts we had much more control in the underlying storage layer.</p>"},{"location":"reference/adr/2021-09-25-optimized-storage-actions/#decision","title":"Decision","text":"<p>We split up the different reading scenarios into separate classes. Writing operations potentially need to read other data first so these need to be extracted as well. All write operations should be transactional to ensure a known state in case of an exception. With their transactional behaviour their return value can safely be a fixed collection of values. Other operations that run indefinitely long as they look for and load data should return an iterable of a single entry. As every operation will have its own class and the intention is not to add future methods into the services, we will use interfaces. Names of the operations are not prescribed and should represent the expected business logic. Ingoing payload- and criteria- as well as returned result objects should have verbose property names to prevent ambiguity errors in the future.  With this in mind we found these naming patterns to be useful:</p> <ul> <li>list - is a non-human-used listing of a search based upon a criteria</li> <li>overview - is a human-used listing of a pageable search with various information</li> <li>create - creates a batch of entries which should return the primary keys</li> <li>get - read a list of entries based upon primary keys</li> <li>find - look for a certain entry by its unique components</li> </ul>"},{"location":"reference/adr/2021-09-25-optimized-storage-actions/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2021-09-25-optimized-storage-actions/#pros","title":"Pros","text":"<ul> <li>Every storage access can be optimized separately</li> <li>Storage accessing tests can be mocked more easily</li> </ul>"},{"location":"reference/adr/2021-09-25-optimized-storage-actions/#cons","title":"Cons","text":"<ul> <li>We need a services for every storage operation</li> <li>New access variations need a new release of the storage-base and all storage implementations</li> </ul>"},{"location":"reference/adr/2021-10-29-flow-components-are-not-crud/","title":"2021-10-29 - Flow components are not CRUD","text":""},{"location":"reference/adr/2021-10-29-flow-components-are-not-crud/#context","title":"Context","text":"<p>At the time of writing we have explorers, emitters and receivers as three main flow components. They resemble CR and U from the well-known CRUD. Most APIs are CRUD or BREAD based and therefore match the three named flow components.  For now, emitting and receiving entities can be also used differently as this \"just\" sends data from one portal node and is received by another portal node. Emitters and receivers could send commands instead of entities. As previously mentioned we do not have a deletion flow component. A receiver could receive an entity with a custom deletion command with any previous version of HEPTAconnect.  This is discouraged but possible. We have already seen implementations, that receive data but don't write anything to the API the portal resembles. This is a misuse that is similar to described scenario above. Looking at the other existing flow components we also have webhooks and status reporters. These are not related to CRUD at all, so we are not limited to CRUD.</p>"},{"location":"reference/adr/2021-10-29-flow-components-are-not-crud/#decision","title":"Decision","text":"<p>Receivers are not meant to do everything, when it is about receiving a command. Receivers are meant to be used for entities only. Grouping explorers, emitters, receivers and \"deleters\" into a single CRUD flow component enforces structures that probably don't benefit APIs, that do not fall into this pattern. Grouping flow components is not helpful when we do not know the possible groups in beforehand and therefore can't be done right. Every other transfer needs a new flow component. As routes connect emitters and receivers they need to learn how to decide which flow components to use on a route. This is described in a different ADR.</p>"},{"location":"reference/adr/2021-10-29-flow-components-are-not-crud/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2021-10-29-flow-components-are-not-crud/#pros","title":"Pros","text":"<ul> <li>New data flows can be implemented by custom integrations without misusing existing components, which could lead to unexpected behaviour</li> <li>Separating different flows into unique components allows for clear code structures</li> </ul>"},{"location":"reference/adr/2021-10-29-flow-components-are-not-crud/#cons","title":"Cons","text":"<ul> <li>New data flows need new flow components to be developed, integrated in routes and implemented</li> <li>Routes need to be configured per each flow scenario</li> </ul>"},{"location":"reference/adr/2021-10-30-route-capabilities/","title":"2021-10-30 - Route capabilities","text":""},{"location":"reference/adr/2021-10-30-route-capabilities/#context","title":"Context","text":"<p>Routes define directions for data to flow. The interpretation or use-case for a flow can be different for various reasons. In general, we support read-multiple-times write-multiple-times scenarios, and they are very generous in options to work with but often needs to be limited in integrations. Limitations like transferring data only once or transferring data for finding the equivalent on the target are missing but requested. We need a way to configure route behaviour in core without adding more work to the integrators.</p>"},{"location":"reference/adr/2021-10-30-route-capabilities/#decision","title":"Decision","text":"<p>All limitations (e.g. transferring once) will be implemented as skipping existing steps. These changes in behaviour can be represented by simple boolean flags. Every step that is not a limitation will result in further flow components that will get a boolean flag.</p>"},{"location":"reference/adr/2021-10-30-route-capabilities/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2021-10-30-route-capabilities/#pros","title":"Pros","text":"<ul> <li>Common known and implemented behaviours can be handled more globally and applied to any route</li> <li>This allows for wide range of operations portal developers can provide which can be combined later on by configuration</li> </ul>"},{"location":"reference/adr/2022-01-05-code-documentation/","title":"2022-01-05 - Code documentation","text":""},{"location":"reference/adr/2022-01-05-code-documentation/#context","title":"Context","text":"<p>Code often needs documentation. Not every code is self-explanatory without documentation. In most cases this is due to code separation by interfaces and contracts from their implementation that is used in e.g. strategy patterns. Code documentation online is often easy to query due to use of search engines. Code documentation online is not easy to separate by code version for neither the ones writing documentation nor the ones looking for documentation. Any documentation can easily be forgotten to be updated.</p>"},{"location":"reference/adr/2022-01-05-code-documentation/#decision","title":"Decision","text":"<p>In our ticket refinement process we state right away which parts of the online documentation are likely to be affected and need to be checked. We add documentation at source code level. We add expectations to interfaces and contracts to reach API providers and API consumers.</p>"},{"location":"reference/adr/2022-01-05-code-documentation/#consequences","title":"Consequences","text":""},{"location":"reference/adr/2022-01-05-code-documentation/#pros","title":"Pros","text":"<ul> <li>Online documentation is likely to be up-to-date with every release to match its content</li> <li>Developers can make use of IDE features like tooltips or symbol navigation to read documentation right away</li> </ul>"},{"location":"reference/adr/2022-01-24-semver-with-generation-version/","title":"2022-01-24 - SemVer with generation version","text":""},{"location":"reference/adr/2022-01-24-semver-with-generation-version/#context","title":"Context","text":"<p>We follow semantic versioning to label our releases with expectations for its users, when upgrading. At point of writing updating to a new major version includes upgrade options, that portals are likely to still work without any changes and storage implementations can continue working on previous storage structures. There can be a time in the future, where these upgrading options are not applicable anymore or at a certain complexity level, that is above the current upgrade expectations. Can we put this expectation in semver?</p>"},{"location":"reference/adr/2022-01-24-semver-with-generation-version/#decision","title":"Decision","text":"<p>Yes, we can. Each semver version part describes a certain expectation regarding the magnitude of changes between two versions. A difference in a version part, that is on the left, has more breaking changes than a difference in a version part that is further on the right. The first number is already allowed to include breaking changes. Increments in the first place are therefore expecting breaks. When we add a number on the left side similar expectations are readable from semver although we do not comply completely with semver anymore. We call this first number \"generation\" as a follow-up/next generation is allowed to be non-compatible with its ancestors as it evolves.</p>"},{"location":"reference/adr/2022-01-24-semver-with-generation-version/#consequences","title":"Consequences","text":"<p>Releases need to have a rating to explain our expectations like increments in second place is still a major breaking change. Every repository that follows this variance in semver must have an explanation in its README.md file. Related packages should follow this versioning schema to reduce ambiguities.</p>"},{"location":"reference/adr/2022-01-24-semver-with-generation-version/#pros","title":"Pros","text":"<ul> <li>Users have additional release information, which simplifies risk management on planning an upgrade</li> <li>HEPTAconnect is allowed to evolve into HEPTAconnect 2 or 3 while keeping the brand and project name without creating technical ambiguities</li> </ul>"},{"location":"reference/adr/2022-01-24-semver-with-generation-version/#cons","title":"Cons","text":"<ul> <li>Users can misread version string</li> <li>Releases need to have additional information</li> </ul>"},{"location":"reference/adr/2022-03-02-final-classes/","title":"2022-03-02 - Final classes","text":""},{"location":"reference/adr/2022-03-02-final-classes/#context","title":"Context","text":"<p>During development, we noticed that autocompletion suggested to extend from implementations that were not meant to be extended and result in confusion for API beginners. This is a signal for bad developer experience. In discussions with Macro \"Ocramius\", who is a well known defensive programmer, we took advise from him to use <code>final</code>.  With that you will notice the <code>final</code> keyword more often, when e.g. using PSR-7 implementation from Tobias Nyholm <code>nyholm/psr7</code>, final has been recently shifted to a PHP doc comment.  </p>"},{"location":"reference/adr/2022-03-02-final-classes/#decision","title":"Decision","text":"<p>We add <code>final</code> keyword to everything, when it is not breaking extensibility. As most of our solutions are based on strategy patterns and have contracts and interfaces, we can rely on these to define our API without exposing the implementations. We prefer the keyword over the PHP doc comment as the keyword is already present on language level without further extensions needed. DTOs may also be final when they implement the <code>Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface</code>.</p>"},{"location":"reference/adr/2022-03-02-final-classes/#consequences","title":"Consequences","text":"<p>We need to evaluate every class to be final. To support this we provide an internal phpstan test case and pay attention to its hints.</p>"},{"location":"reference/adr/2022-03-02-final-classes/#pros","title":"Pros","text":"<ul> <li>We can be sure our implementations are not reused, when we don't expect it</li> <li>We have more contracts and interfaces to keep flexibility and extensibility</li> </ul>"},{"location":"reference/adr/2022-03-02-final-classes/#cons","title":"Cons","text":"<ul> <li>We can not mock every implementation anymore and might need to rewrite implementations</li> <li>We can not have implementations depending on each other by inheritance like we do at a few spots</li> </ul>"},{"location":"reference/adr/2022-06-12-type-safe-class-strings/","title":"2022-06-12 - Type safe class strings","text":""},{"location":"reference/adr/2022-06-12-type-safe-class-strings/#context","title":"Context","text":"<p>PHP and the PHP community are striving further towards static analysis. More and more tools arise next to the movement of the php-src developers adding language features to improve type safe programming. Tools like phpstan and psalm add PHPDoc comments based features like type templating/generics. There are also typed class strings. One can add comments to basic strings and indicate that these strings are references to fully-qualified class names. We make use of this class-string feature as we have references for types at several places. For example: we reference the types of entities to store data transfer relations between portal nodes. The only issue is, that this class-string feature is solely powered by PHPDoc comments. There are no validations during runtime. Without these validations the code is only valid in theory but can fail at real life usage. Real life usage includes scenarios like references to classes that do not exist anymore due to refactoring.</p>"},{"location":"reference/adr/2022-06-12-type-safe-class-strings/#decision","title":"Decision","text":"<p>We need validation at runtime. Therefore, we need a replacement for class-string type hints. Although string is a very simple type, we will add a complex meaning to it. To have similar features at runtime like we have during static analysis, we need multiple classes. The following features must be implemented:</p> <ul> <li>Strings encapsulated in objects must behave like before and keep their original initial value</li> <li>Valid references mean, that the referenced class can be loaded</li> <li>String objects, that reference a class, do not necessarily have to reference an existing class</li> <li>String objects, that reference a class and claim to be valid, must perform validation on creation so its usage always ensures a valid reference</li> <li>String objects, that reference a class and claim to be of a certain type, must perform validation on creation so its usage always ensures a valid reference</li> </ul>"},{"location":"reference/adr/2022-06-12-type-safe-class-strings/#consequences","title":"Consequences","text":"<p>With different string validations at hand, various classes will follow different expectations towards validation of class strings. Loading data from the storage layer must assume invalid historical data and therefore must not invoke validation when loading the data. In contrast, business logic, that expects certain classes to be available for further processing, may use more strictly validating string classes.</p>"},{"location":"reference/adr/2022-06-12-type-safe-class-strings/#pros","title":"Pros","text":"<ul> <li>Class string references can now be validated at runtime</li> </ul>"},{"location":"reference/adr/2022-06-12-type-safe-class-strings/#cons","title":"Cons","text":"<ul> <li>More decisions have to be made, when to use which degree of validation</li> </ul>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/","title":"2022-10-06 - Filesystem abstraction with stream wrapper","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#context","title":"Context","text":"<p>From the release of Shopware 5.1 (2015) via the release of Shopware 6.0 developer preview up to the latest version of Shopware 6.4 (2023), which is the latest released version as of writing, Flysystem is used as abstraction layer to the filesystem for extensions.  We started developing HEPTAconnect within the Shopware ecommerce framework, so we followed the same filesystem abstraction guidelines. With the dependency within Shopware and within HEPTAconnect core to Flysystem v1 we can easily swap the filesystem storage from local disk to memory, AWS S3, Azure Blob Storage, SFTP. This simplifies administrative tasks to set up auto-scaling app servers accessing a network storage while also running the same code on a small development setup on a local machine. Flysystem v1 has been completely overhauled with the releases v2 and v3. As we depend on Shopware integrations we can't use a different Flysystem version. With the limitation to Flysystem v1 we can only support frameworks, that also support Flysystem v1. This excludes e.g. Laravel 9.</p>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#decision","title":"Decision","text":"<p>We deprecate and remove later the dependency on <code>league/flysystem</code>. As replacement, we use the even older interface, that did not receive breaking changes in our lifetime of using it: stream wrappers.  It is possible to wrap Flysystem with a stream wrapper, so you can keep integrations, that make use of it, without forcing them to switch. It is possible to wrap stream wrapper with a Flysystem adapter, so you can keep portals, that make use of it, without forcing them to switch. We need to rewrite portals and integrations regarding their file access. There is a deprecation release before the removal of Flysystem so one can migrate step by step.</p>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#consequences","title":"Consequences","text":"<ul> <li>Portals, that use Flysystem need to be rewritten to access streams, files and the filesystem in a different way</li> </ul>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#pros","title":"Pros","text":"<ul> <li>Integrates easier into other frameworks</li> <li>Use more native PHP methods, that will work with more libraries, that are not compatible with Flysystem</li> </ul>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#cons","title":"Cons","text":"<ul> <li>Stream wrappers are more difficult to debug as the stack trace due to a PHP script calling a PHP method, that internally calls a different user-provided PHP class with a different set of arguments</li> </ul>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#how-to-migrate","title":"How to migrate","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#file-listing","title":"File listing","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#before","title":"before","text":"<pre><code>/** @var \\League\\Flysystem\\FilesystemInterface $filesystem */\n$files = $filesystem-&gt;listContents('', true);\n$paths = [];\n\nforeach ($files as $file) {\n    $paths[] = $file['path'];\n}</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#after","title":"after","text":"<pre><code>/** @var \\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface $filesystem */\n$fileIterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($filesystem-&gt;toStoragePath('/')));\n$paths = [];\n\n/** @var SplFileInfo $file */\nforeach ($fileIterator as $file) {\n    $paths[] = $file-&gt;getPath();        \n}</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#reading-file-content","title":"Reading file content","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#before_1","title":"before","text":"<pre><code>/** @var \\League\\Flysystem\\FilesystemInterface $filesystem */\n$content = $filesystem-&gt;read('foobar.txt');</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#after_1","title":"after","text":"<pre><code>/** @var \\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface $filesystem */\n$content = file_get_contents($filesystem-&gt;toStoragePath('foobar.txt'));</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#writing-file-content","title":"Writing file content","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#before_2","title":"before","text":"<pre><code>/** @var \\League\\Flysystem\\FilesystemInterface $filesystem */\n$filesystem-&gt;put('foobar.txt', 'Hello world');</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#after_2","title":"after","text":"<pre><code>/** @var \\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface $filesystem */\nfile_put_contents($filesystem-&gt;toStoragePath('foobar.txt'), 'Hello world');</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#moving-files","title":"Moving files","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#before_3","title":"before","text":"<pre><code>/** @var \\League\\Flysystem\\FilesystemInterface $filesystem */\n$filesystem-&gt;rename('foobar.txt', 'gizmo.txt');</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#after_3","title":"after","text":"<pre><code>/** @var \\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface $filesystem */\nrename($filesystem-&gt;toStoragePath('foobar.txt'), $filesystem-&gt;toStoragePath('gizmo.txt'));</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#deleting-files","title":"Deleting files","text":""},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#before_4","title":"before","text":"<pre><code>/** @var \\League\\Flysystem\\FilesystemInterface $filesystem */\n$filesystem-&gt;delete('foobar.txt');</code></pre>"},{"location":"reference/adr/2022-10-06-filesystem-stream-wrapper/#after_4","title":"after","text":"<pre><code>/** @var \\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface $filesystem */\nunlink($filesystem-&gt;toStoragePath('foobar.txt'));</code></pre>"},{"location":"reference/general-resources/data-flow/","title":"Data flow","text":"<p>In HEPTAconnect we separate different steps where data processing is happening to have different entry points for developers and enable horizontal scaling for each step. The main steps are exploration, emission and reception. The exploration can be triggered from different places and will follow in emissions and receptions when the data routes exists. In the following paragraphs you will see what kind of data flows can occur:</p>"},{"location":"reference/general-resources/data-flow/#basic-flow","title":"Basic flow","text":"<p>The basic flow of the previous mentioned steps exploration, emission and reception in their most common form. For this you need to implement a handler for each step: An explorer, an emitter and a receiver.</p> <p></p> <p>Click here to read more about the details that happen within the basic flow. </p>"},{"location":"reference/general-resources/data-flow/#direct-emission-flow","title":"Direct emission flow","text":"<p>This is a condensed form of the basic flow as the first two steps are merged into one. A very useful pattern for sources that do not differ between gathering selecting primary keys and their corresponding data on it. For this flow you only need to implement explorers as direct emission explorers and receivers. To ensure other flows like the next one you still have to provide an emitter which can be omitted otherwise.</p> <p></p>"},{"location":"reference/general-resources/data-flow/#reverse-publication-flow","title":"Reverse publication flow","text":"<p>The reverse publication is requesting data from a previously running transfer a second time to keep data up-to-date. This is useful for any event driven data transfer that has to happen on demand.</p> <p></p>"},{"location":"reference/general-resources/mapping/","title":"Mapping","text":"<p>Since HEPTAconnect enables various systems to exchange data and keep it synchronized, it will need to keep track of the data it transfers from one system to another. This is done via mappings. This article will go into detail about how mappings are structured and how they work in HEPTAconnect.</p>"},{"location":"reference/general-resources/mapping/#mappingnode","title":"MappingNode","text":"<p>Every entity in a PortalNode (that should be visible to HEPTAconnect) must receive a mapping. So a mapping represents a single entity inside of a PortalNode. Every mapping also has a MappingNode. These are used to connect different mappings from different PortalNodes with each other. Several mappings can share a MappingNode to indicate that they mark the same entity throughout different PortalNodes. A MappingNode itself knows its data type and its origin (the PortalNode of the first mapping associated with this MappingNode). The associated mappings know the external identifier and have an association to their PortalNode.</p> <p>Example: A product in an ERP system is published to HEPTAconnect. This means, it now has a mapping which in turn has a MappingNode. HEPTAconnect then transfers this product to an ecommerce system. Upon creation the ecommerce system responds with an identifier for the newly created product. HEPTAconnect will now save a new mapping for the product in the ecommerce system with the same MappingNode. So there are now two mappings for the same product in two different PortalNodes that share a MappingNode.</p> <p>In some situations mappings are not attached to a mapping node but instead preconfigured using an identity redirect. This is useful when multiple mappings in one portal node are represented as a single mapping in a different portal node. As this scenario is not supported by the singularity approach of a mapping node, redirects are applied separately and manually created. PortalNodes cannot influence redirects as they are cross portal nodes by design.</p>"},{"location":"reference/general-resources/mapping/#publisher","title":"Publisher","text":"<p>To make HEPTAconnect aware of an entity inside a PortalNode, that entity has to be published. The publisher will create a mapping and a MappingNode for an entity and it will schedule the entity to be emitted. Because the actual emitting will happen asynchronously, the publisher can be called during a web request with a minimal performance impact. For the initial integration into an existing HEPTAconnect ecosystem, it is recommended for a PortalNode to publish every entity that should be synchronized by HEPTAconnect. This process is called exploration.</p>"},{"location":"reference/general-resources/mapping/#exploration","title":"Exploration","text":"<p>A recommended step in adding a new PortalNode into a HEPTAconnect ecosystem is the exploration. A portal can ship multiple explorers that will each publish every entity of a certain type from its PortalNode. While this process could in theory be done manually, it is recommended to create classes implementing the ExplorerContract. The benefit is a better integration into automated processes of HEPTAconnect, so your exploration process can be triggered by the system rather than relying on a manual trigger.</p>"},{"location":"reference/general-resources/mapping/#identities","title":"Identities","text":"<p>To perform operations on mappings, various storage actions can be used depending on the exact use case:</p> <ul> <li><code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code> used to create missing mappings for entities</li> <li><code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code> used to update mappings on existing mapping nodes</li> <li><code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectCreateActionInterface</code> used to create identity redirects to connect multiple mappings on one portal node to a single mapping on a different portal node</li> </ul> <p>These service can save mappings to the storage and find a counterpart of a mapping for another PortalNode. This is done after an identifier has been set on an entity by a receiver.</p> <p>The process of finding a counterpart of a mapping for another PortalNode is called reflecting. The <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityReflectActionInterface</code> will check, if the provided entities have known mappings or identity redirects in the management storage. Afterwards the service checks, if a reference mapping for the requested PortalNode already exists and assigns it.</p>"},{"location":"reference/general-resources/mapping/#error-handling","title":"Error handling","text":"<p>There are situations that are prone to error regarding mappings, like e.g. when a mapping is passed to a receiver but the receiver throws an exception. These errors are stored in the database alongside the mapping. The idea is to associate errors to the entities they are related to.</p>"},{"location":"reference/general-resources/package-structure/","title":"Package structure","text":"<p>This software is divided into several repositories that have composer dependecies on each other. Some of the packages are always required for a functional HEPTAconnect ecosystem while others are more or less optional or specific to the use case. This article attempts to clarify the structure of the different packages and outline their role in the ecosystem.</p>"},{"location":"reference/general-resources/package-structure/#dataset-base","title":"Dataset-Base","text":"<p>HEPTAconnect is all about data. Reading data, moving it from one point to an other and writing it again. To make different APIs understand each other, they need a common ground to understand each other. A dataset is a group of class definitions for a type of data. Usually these data types are grouped into sets by their topic. The dataset base consists of interfaces and helper classes to make up a base for the individual datasets.</p> <p></p>"},{"location":"reference/general-resources/package-structure/#dataset","title":"Dataset","text":"<p>A single dataset can hold a number of classes for different data types. Datasets can also require other datasets to make up larger sets.</p> <p></p>"},{"location":"reference/general-resources/package-structure/#portal-base","title":"Portal-Base","text":"<p>Since HEPTAconnect itself is not much more than a framework, it does not come with any external connectivity. To connect an external API, you will need to provide a portal for this API. A portal has to require the portal base and whatever datasets it may support. The portal base comes with structs and interfaces that a portal will need in order to work.</p> <p></p>"},{"location":"reference/general-resources/package-structure/#portal","title":"Portal","text":"<p>Because HEPTAconnect should bring data of different systems together, it has to be someone's responsibility to actually connect to different systems. This is where portals come into play. A portal is a package with emitters and receivers that can read data from and write data to an endpoint. In most cases this endpoint is an API of some sort, but it does not have to be one. In theory this can also be an access to a static local file or a local database. The important part is that a portal connects an external system with the HEPTAconnect ecosystem. The portal has to require all its supported datasets. Portals with shared supported datasets are natively compatible with each other, as their data can be easily transferred from one portal to the other.</p> <p></p>"},{"location":"reference/general-resources/package-structure/#core","title":"Core","text":"<p>At its core HEPTAconnect manages data streams between different endpoints via asynchronously handled messages. One side goes through its entities for a dataset and emits whatever it can find. The other side receives these entities and saves them to another endpoint. It is the core's job to coordinate this traffic and keep things organized. So the core provides a router, a mapping service, an emit service, a receive service, http handling and other tooling.</p> <p></p>"},{"location":"reference/general-resources/package-structure/#storage-base","title":"Storage-Base","text":"<p>Certain components of HEPTAconnect require a form of persistent storage. An example is the mapping of entities. To remember which records of different portal nodes are actually the same entity, a mapping is created and stored in a storage. The storage base will only provide interfaces for the storage, so the core can interact with the storage but does not need to know the actual implementation.</p> <p></p>"},{"location":"reference/general-resources/package-structure/#bridge","title":"Bridge","text":"<p>HEPTAconnect is designed to be able to adapt to its surrounding software. Therefore the core itself will not run without a surrounding runtime. To make this work, there are bridges to connect the core with a runtime. The runtime will then (through the bridge) provide a storage, a messenger and several other components that the core will then make use of. Because of this approach, the core is very portable and can run in a number of runtimes (if they can provide all requirements).</p> <p></p>"},{"location":"reference/general-resources/package-structure/#integration","title":"Integration","text":"<p>The integration is the one package that holds it all together. It is a composition of all required packages necessary for the use case at hand. So this package really changes from project to project and is the most individual part of the software. Typically an integration is composed by specifying all portals that should be connected with each other and a runtime for the software to run. In this example we choose the Shopware bridge as the runtime and the portals for Shopware and Business Central as our portals. Because our runtime is Shopware, the integration has to be a Shopware plugin with the bridge and the portals registered as additional bundles.</p> <p></p>"},{"location":"reference/general-resources/data-flows/basic-flow/","title":"Basic flow in detail","text":"<p>In the following we get more into the details from the basic flow from two perspectives. First perspective is seen from the portal and the second perspective is based upon the HEPTAconnect Core.</p>"},{"location":"reference/general-resources/data-flows/basic-flow/#portals-point-of-view","title":"Portal's point of view","text":""},{"location":"reference/general-resources/data-flows/basic-flow/#cores-point-of-view","title":"Core's point of view","text":""},{"location":"reference/general-resources/data-flows/basic-flow/#exploration","title":"Exploration","text":""},{"location":"reference/general-resources/data-flows/basic-flow/#emission","title":"Emission","text":""},{"location":"reference/general-resources/data-flows/basic-flow/#reception","title":"Reception","text":""},{"location":"reference/portal-developer/service/filesystem-interface/","title":"FilesystemInterface","text":"<p>Service to convert paths to stream wrapper prefixed URIs for portal node specific file storage access. It MUST be used to generate URIs, that give access to a designated filesystem, that is not shared with other portal nodes. </p>"},{"location":"reference/portal-developer/service/filesystem-interface/#service","title":"Service","text":"<p>You can get the service by id <code>Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code>.</p>"},{"location":"reference/portal-developer/service/filesystem-interface/#methods","title":"Methods","text":""},{"location":"reference/portal-developer/service/filesystem-interface/#tostoragepath","title":"toStoragePath","text":"<p>Prefixes the path with a portal node unique PHP stream path.</p>"},{"location":"reference/portal-developer/service/filesystem-interface/#fromstoragepath","title":"fromStoragePath","text":"<p>Removes the portal node unique PHP stream path scheme.</p>"},{"location":"reference/portal-developer/service/http-client-contract/","title":"HttpClientContract","text":"<p>HTTP client that wraps around the PSR-18 <code>Psr\\Http\\Client\\ClientInterface</code> with configurable behaviour for common use-cases.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#service","title":"Service","text":"<p>You can get the service by id <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientContract</code>. It is preconfigured to throw exceptions for status codes between 400 and 599, follow redirects up to 20 times and retry twice in case of an error or rate limit.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#methods","title":"Methods","text":""},{"location":"reference/portal-developer/service/http-client-contract/#getdefaultrequestheaders","title":"getDefaultRequestHeaders","text":"<p>Get the request header configurations that are applied to any request unless they are already present.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withdefaultrequestheaders","title":"withDefaultRequestHeaders","text":"<p>Set the request header configurations that are applied to any request unless they are already present. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#getexceptiontriggers","title":"getExceptionTriggers","text":"<p>Get the HTTP response status codes that will throw an exception.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withexceptiontriggers","title":"withExceptionTriggers","text":"<p>Add HTTP response status codes that will throw an exception. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withoutexceptiontriggers","title":"withoutExceptionTriggers","text":"<p>Remove HTTP response status codes, so they will not throw an exception. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#getmaxredirect","title":"getMaxRedirect","text":"<p>Get the number of automatically followed redirects. Defaults to 0.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withmaxredirect","title":"withMaxRedirect","text":"<p>Sets the number of automatically followed redirects. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#getmaxretry","title":"getMaxRetry","text":"<p>Get the number of automatically processed retries. Defaults to 0.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withmaxretry","title":"withMaxRetry","text":"<p>Sets the number of automatically processed retries. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#getmaxwaittimeout","title":"getMaxWaitTimeout","text":"<p>Get the maximum time in seconds allowed to wait between retries per HTTP status code.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withmaxwaittimeout","title":"withMaxWaitTimeout","text":"<p>Add the maximum time allowed timeout in seconds for an HTTP status code. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"reference/portal-developer/service/http-client-contract/#withoutmaxwaittimeout","title":"withoutMaxWaitTimeout","text":"<p>Remove the wait timeout for an HTTP status code. As it returns a new instance of itself, you SHOULD process its return value.</p>"},{"location":"releases/","title":"Releases","text":"<p>Here is an overview of all public changelogs we supply. They contain helpful hints for upgrading your code. When you want to upgrade your code have a look at the integrator upgrade guide. For everything, that will be coming in the future, you can see on the \"live roadmap\" for the upcoming features.</p>"},{"location":"releases/#bridge-shopware-platform","title":"Bridge Shopware Platform","text":"<p>This is the HEPTAconnect package to provide a runtime in a shopware platform project.</p> <p>Read the Bridge Shopware Platform changelog</p>"},{"location":"releases/#core","title":"Core","text":"<p>This is the HEPTAconnect core package. Here are all processes and entrypoints combined.</p> <p>Read the Core changelog</p>"},{"location":"releases/#dataset-base","title":"Dataset Base","text":"<p>This is a HEPTAconnect package to provide basic dataset structures like structs and collections. Any other dataset library has to use the classes to work with HEPTAconnect utilities.</p> <p>Read the Dataset Base changelog</p>"},{"location":"releases/#dataset-ecommerce","title":"Dataset Ecommerce","text":"<p>This is the ecommerce dataset. It provides all common entities for the transfer of data between different ecommerce portals.</p> <p>Read the Dataset Ecommerce changelog</p>"},{"location":"releases/#portal-base","title":"Portal Base","text":"<p>This is a HEPTAconnect package that provides base structures for portals. Any other portal library has to use the classes to work with HEPTAconnect utilities.</p> <p>Read the Portal Base changelog</p>"},{"location":"releases/#portal-local-shopware-platform","title":"Portal Local Shopware Platform","text":"<p>This is a HEPTAconnect package that allows to communicate multiple entity types with a Shopware 6 instance that also integrates HEPTAconnect.</p> <p>Read the Portal Local Shopware Platform changelog</p>"},{"location":"releases/#package-http","title":"Package HTTP","text":"<p>This is a HEPTAconnect package to support flow components working with HTTP clients or act as HTTP server.</p> <p>Read the Package HTTP changelog</p>"},{"location":"releases/#package-web-frontend","title":"Package Web Frontend","text":"<p>This is a HEPTAconnect package to build web frontends for portals and integrations.</p> <p>Read the Package Web Frontend changelog</p>"},{"location":"releases/#package-shopware-6","title":"Package Shopware 6","text":"<p>This is a HEPTAconnect package all about communicating to Shopware 6 APIs. You can use it in combination with the Shopware 6 Portal.</p> <p>Read the Package Shopware 6 changelog</p>"},{"location":"releases/#storage-base","title":"Storage Base","text":"<p>This is a HEPTAconnect package that provides base structures for storage providers.</p> <p>Read the Storage Base changelog</p>"},{"location":"releases/#storage-shopware-dal","title":"Storage Shopware DAL","text":"<p>This is a HEPTAconnect package that offers an implementation for the storage within shopware 6.</p> <p>Read the Storage Shopware DAL changelog</p>"},{"location":"releases/changelog-bridge-shopware-platform/","title":"Bridge Shopware Platform Changelog","text":""},{"location":"releases/changelog-bridge-shopware-platform/#0970-2024-02-10","title":"[0.9.7.0] - 2024-02-10","text":""},{"location":"releases/changelog-bridge-shopware-platform/#changed","title":"Changed","text":"<ul> <li>Command <code>heptaconnect:job:run</code> now accepts multiple values for argument <code>job-key</code> and runs the jobs simultaneously</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0960-2024-01-03","title":"[0.9.6.0] - 2024-01-03","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added","title":"Added","text":"<ul> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Parallelization\\LockStoreFactoryInterface</code> with corresponding implementation <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Parallelization\\LockStoreFactory</code> to provide lock stores for parallelization</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#fixed","title":"Fixed","text":"<ul> <li>Fix service container when no database url is configured by catching connection errors and falling back to in-memory lock store in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Parallelization\\LockStoreFactory</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0950-2023-07-10","title":"[0.9.5.0] - 2023-07-10","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_1","title":"Added","text":"<ul> <li>Add dependency <code>heptacom_heptaconnect.logger</code> to service <code>Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code></li> <li>Add dependency <code>heptacom_heptaconnect.logger</code> to service <code>Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#changed_1","title":"Changed","text":"<ul> <li>Raise composer dependency constraint for <code>heptacom/heptaconnect-core</code>, <code>heptacom/heptaconnect-dataset-base</code>, <code>heptacom/heptaconnect-portal-base</code> and <code>heptacom/heptaconnect-storage-base</code> from <code>^0.9.4</code> to <code>^0.9.6</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0940-2023-05-27","title":"[0.9.4.0] - 2023-05-27","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_2","title":"Added","text":"<ul> <li>Add service definition <code>Psr\\Http\\Message\\StreamFactoryInterface.heptaconnect</code> factorized by <code>\\Http\\Discovery\\Psr17FactoryDiscovery::findStreamFactory</code></li> <li>Add service definition <code>Psr\\Http\\Message\\UploadedFileFactoryInterface.heptaconnect</code> factorized by <code>\\Http\\Discovery\\Psr17FactoryDiscovery::findUploadedFileFactory</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageMultiPartFormDataBuilderInterface</code> for class <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Psr7MessageMultiPartFormDataBuilder</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Component\\Composer\\Contract\\PackageConfigurationLoaderInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfigurationLoader</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitServiceInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Emission\\EmitService</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExploreServiceInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreService</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackBuilderFactoryInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilderFactory</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalFactoryContract</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalFactory</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalRegistryInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Portal\\Base\\Parallelization\\Contract\\ResourceLockingContract</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Parallelization\\ResourceLocking</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiverStackBuilderFactoryInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilderFactory</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveServiceInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionActorInterface</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor</code></li> <li>Add alternative service id <code>Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\EntityStatusContract</code> for definition <code>Heptacom\\HeptaConnect\\Core\\Support\\EntityStatus</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#changed_2","title":"Changed","text":"<ul> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ExplorationHandlerInterface</code> on <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code></li> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\EmissionHandlerInterface</code> on <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code></li> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> on <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code></li> <li>Add method call <code>setHttpHandleService</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalStackServiceContainerBuilderInterface</code></li> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalStackServiceContainerBuilderInterface</code> on <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageMultiPartFormDataBuilderInterface</code></li> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code> on <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageMultiPartFormDataBuilderInterface</code></li> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code> on <code>Psr\\Http\\Message\\StreamFactoryInterface.heptaconnect</code></li> <li>Add dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code> on <code>Psr\\Http\\Message\\UploadedFileFactoryInterface.heptaconnect</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0930-2023-03-04","title":"[0.9.3.0] - 2023-03-04","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_3","title":"Added","text":"<ul> <li>Add option <code>time-limit</code> to command <code>heptaconnect:job:cleanup-finished</code> to limit the time the command is running measured in seconds</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Support\\Contract\\HeaderUtilityInterface</code> for class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Support\\HeaderUtility</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code> for class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageCurlShellFormatter</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatterContract</code> for class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageRawHttpFormatter</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface</code> for class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\SampleRateServerRequestCycleDumpChecker</code></li> <li>Add service alias <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract</code> to set <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatterContract</code> as default implementation</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\HttpHandlerDumpPathProviderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\HttpHandlerDumpPathProvider</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumperInterface</code> for class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\ServerRequestCycleDumper</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface</code> and <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumperInterface</code> to service <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code> and <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatterContract</code> to service <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalStackServiceContainerBuilderInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectDeleteActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectCreateActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectOverviewActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add command <code>heptaconnect:identity-redirect:add</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\IdentityRedirect\\AddIdentityRedirect</code> to add an identity redirect</li> <li>Add command <code>heptaconnect:identity-redirect:remove</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\IdentityRedirect\\RemoveIdentityRedirect</code> to remove an identity redirect</li> <li>Add command <code>heptaconnect:identity-redirect:list</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\IdentityRedirect\\ListIdentityRedirects</code> to list identity redirects</li> <li>Add identity redirect into evaluation of <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#changed_3","title":"Changed","text":"<ul> <li>Use count of deleted jobs as progress indicator in command <code>heptaconnect:job:cleanup-finished</code></li> <li>Delete jobs, that have not been finished at the start of the command <code>heptaconnect:job:cleanup-finished</code>, but finished during the command run</li> <li>Remove Symfony, connection, proxy and transfer related header from requests handled in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code></li> <li>Raise composer dependency constraint for <code>heptacom/heptaconnect-core</code>, <code>heptacom/heptaconnect-dataset-base</code>, <code>heptacom/heptaconnect-portal-base</code> and <code>heptacom/heptaconnect-storage-base</code> from <code>^0.9.3</code> to <code>^0.9.4</code></li> <li>Raise composer dependency constraint for <code>heptacom/heptaconnect-storage-shopware-dal</code> from <code>^0.9</code> to <code>^0.9.1</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#fixed_1","title":"Fixed","text":"<ul> <li>Ensure missing query parameters in the request's URI passed on to the HTTP handler in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code></li> <li>Interpret <code>entity-type</code> option in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings</code> as filter criteria for identities</li> <li>Show an empty result if first search did not find a mapping node to search for its siblings <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0920-2022-11-26","title":"[0.9.2.0] - 2022-11-26","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_4","title":"Added","text":"<ul> <li>Add composer dependency <code>kor3k/flysystem-stream-wrapper: ^1.0.11</code> to register flysystem filesystems to a stream wrapper</li> <li>Add service definition for implementation <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\PortalNodeFilesystemStreamProtocolProvider</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\PortalNodeFilesystemStreamProtocolProviderInterface</code> to provide stream wrapper protocol and register flysystem filesystems for portal nodes</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\Contract\\FilesystemFactoryInterface</code> for class <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\FilesystemFactory</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\Contract\\FilesystemFactoryInterface</code> to service <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalStackServiceContainerBuilderInterface</code></li> <li>Add command <code>heptaconnect:emit</code> to emit one or more entities</li> <li>Add composer suggestion <code>psy/psysh</code> for an interactive read\u2013eval\u2013print loop in the scope of a portal-node</li> <li>Add command <code>heptaconnect:repl</code> for an interactive read\u2013eval\u2013print loop in the scope of a portal-node</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#fixed_2","title":"Fixed","text":"<ul> <li>Change base filesystem for portal nodes in <code>Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\FilesystemFactory</code> from the Shopware bundle provided private filesystem to a custom prefixed filesystem based on the Shopware instance private filesystem to keep the same default directory but to support adapter access on the file system</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0911-2022-10-03","title":"[0.9.1.1] - 2022-10-03","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_5","title":"Added","text":"<ul> <li>Show progress-bar in command <code>heptaconnect:job:cleanup-finished</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#fixed_3","title":"Fixed","text":"<ul> <li>Remove service <code>Shopware\\Core\\Framework\\MessageQueue\\Monitoring\\MonitoringBusDecorator</code> from container as it has been renamed from <code>Shopware\\Core\\Framework\\MessageQueue\\MonitoringBusDecorator</code>.</li> <li>Fix command <code>heptaconnect:portal-node:status:list-topics</code> when there are no topics</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0910-2022-07-19","title":"[0.9.1.0] - 2022-07-19","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_6","title":"Added","text":"<ul> <li>Add service <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\FrameworkX\\XAppFactoryInterface</code> to initialize a framework-x app. Requires optional dependency <code>clue/framework-x</code>.</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0903-2022-06-08","title":"[0.9.0.3] - 2022-06-08","text":""},{"location":"releases/changelog-bridge-shopware-platform/#fixed_4","title":"Fixed","text":"<ul> <li>Fix command <code>heptaconnect:portal-node:status:list-topics</code> by using the <code>Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry</code> from the portal container</li> <li>Fix command <code>heptaconnect:job:cleanup-finished</code> by using only the job-keys of the <code>Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Listing\\JobListFinishedResult</code> objects</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0902-2022-04-27","title":"[0.9.0.2] - 2022-04-27","text":""},{"location":"releases/changelog-bridge-shopware-platform/#fixed_5","title":"Fixed","text":"<ul> <li>Create lock tables <code>heptaconnect_core_reception_lock</code> and <code>heptaconnect_portal_node_resource_lock</code> manually as <code>Symfony\\Component\\Lock\\Store\\PdoStore</code> does not create them automatically for MySQL driver</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0901-2022-04-19","title":"[0.9.0.1] - 2022-04-19","text":""},{"location":"releases/changelog-bridge-shopware-platform/#fixed_6","title":"Fixed","text":"<ul> <li>Use different locking implementation to follow Shopware master-slave database setup warning in <code>\\Shopware\\Core\\Profiling\\Doctrine\\DebugStack</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_7","title":"Added","text":"<ul> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobGetActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobCreateActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobListFinishedActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobDeleteActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobScheduleActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeCreateActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeDeleteActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeGetActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeOverviewActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add command <code>heptaconnect:portal-node:extensions:activate</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Extension\\ActivateExtension</code> to activate a portal extension on a portal node</li> <li>Add command <code>heptaconnect:portal-node:extensions:deactivate</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Extension\\DeactivateExtension</code> to deactivate a portal extension on a portal node</li> <li>Add command <code>heptaconnect:portal-node:extensions:list</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Extension\\ListExtensions</code> to list activity state of portal extensions on a portal node</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionFindActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionActivateActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionDeactivateActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add option <code>--bidirectional</code> and its functionality to <code>heptaconnect:router:add-route</code> defined in class <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\AddRoute</code> to automate creation of the route back</li> <li>Add service definition <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Logger\\FlowComponentCodeOriginFinderLogger</code> for decorating <code>heptacom_heptaconnect.logger</code> to stringify flow component into human readable code origins in log messages</li> <li>Add command <code>heptaconnect:portal-node:list-flow-components</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\ListFlowComponentsForPortalNode</code> to list all flow components for a given entity type, job type (by base class) and portal node</li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerCodeOriginFinder</code> as <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerCodeOriginFinderInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterCodeOriginFinder</code> as <code>Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterCodeOriginFinderInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerCodeOriginFinder</code> as <code>Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerCodeOriginFinderInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverCodeOriginFinder</code> as <code>Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverCodeOriginFinderInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReporterCodeOriginFinder</code> as <code>Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterCodeOriginFinderInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Bridge\\StorageFacade</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code> that is used to create all storage based service</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGetActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSetActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Component\\Logger\\ExceptionCodeLogger</code> for decorating <code>heptacom_heptaconnect.logger</code> to add exception codes in log messages</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityReflectActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteDeleteActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageClearActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageDeleteActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageGetActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageListActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageSetActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add command <code>heptaconnect:router:remove-route</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\RemoveRoute</code> to remove a route by id seen on <code>heptaconnect:router:list-routes</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\FileContentsUrlProviderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\FileContentsUrlProvider</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\FileRequestUrlProviderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\FileRequestUrlProvider</code></li> <li>Add HTTP route <code>heptaconnect.file.request</code> in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\FileReferenceController::request</code> to send a stored request of a file reference and pass the response through to the client</li> <li>Add HTTP route <code>heptaconnect.file.contents</code> in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\FileReferenceController::contents</code> to read a normalized stream of a file reference and respond with its contents and an arbitrary mime type</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\RequestStorageContract</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestDenormalizer</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestNormalizer</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\RequestContextHelper</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferenceGetRequestActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferencePersistRequestActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Bridge\\File\\FileContentsUrlProviderInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Bridge\\File\\FileRequestUrlProviderInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\File\\FileReferenceController</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\RequestContextHelper</code> to scope a request context to a base URL</li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationInstructionProcessor</code> with dependency onto <code>heptacom_heptaconnect.logger</code>, <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\AliasStorageKeyGenerator</code>, <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code> and all tagged services by tag <code>heptaconnect_core.portal_node_configuration.instruction_file_loader</code> tagged as <code>heptaconnect_core.portal_node_configuration.processor</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationCacheProcessor</code> with dependency onto <code>cache.system</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\StorageKeyGeneratorContract</code> tagged as <code>heptaconnect_core.portal_node_configuration.processor</code></li> <li>Add service and definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\AliasValidator</code> to validate portal node aliases</li> <li>Add command <code>heptaconnect:portal-node:alias:find</code> in service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Alias\\Find</code> to resolve alias to a portal node key</li> <li>Add command <code>heptaconnect:portal-node:alias:get</code> in service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Alias\\Get</code> to get an alias by a portal node key</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#changed_4","title":"Changed","text":"<ul> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\CleanupFinished</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobListFinishedActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobDeleteActionInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\Run</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobGetActionInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Core\\Flow\\MessageQueueFlow\\MessageHandler</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobGetActionInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\JobDispatcherContract</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ExplorationHandlerInterface</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\AddPortalNode</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeCreateActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\ListPortalNodes</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeOverviewActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\RemovePortalNode</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeDeleteActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Web\\HttpHandler\\ListHandlers</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeGetActionInterface</code></li> <li>Remove argument <code>Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent</code> from service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalStackServiceContainerBuilderInterface</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionFindActionInterface</code> to the service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\ReceptionRouteListActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteOverviewActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteFindActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteGetActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteCreateActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteCreateActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\RouteCapabilityOverviewActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFindActionInterface</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetActionInterface</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSetActionInterface</code></li> <li>Change behavior of command <code>heptaconnect:portal-node:config:get</code> to throw an exception when the output cannot be converted to JSON</li> <li>Change output of command <code>heptaconnect:portal-node:config:get</code> to not escape slashes in JSON</li> <li>Change output of command <code>heptaconnect:portal-node:status:report</code> to not escape slashes in JSON</li> <li>Change behavior of command <code>heptaconnect:http-handler:get-configuration</code> to throw an exception when the output cannot be converted to JSON</li> <li>Change output of command <code>heptaconnect:http-handler:get-configuration</code> to not escape slashes in JSON</li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code> to <code>Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\ConfigurationServiceInterface</code> to prioritize service interface as id</li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\ConfigurationServiceInterface</code> from <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ConfigurationStorage</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGetActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSetActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityMapperContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityReflectorContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityReflectActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor</code> from <code>Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodes</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings</code> from <code>Heptacom\\HeptaConnect\\Core\\Portal\\ComposerPortalLoader</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code>, <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerFactory</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\MergeMappingNodes</code> from <code>Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code></li> <li>Switch implementation of <code>Heptacom\\HeptaConnect\\Core\\Router\\Router.lock_factory</code> from <code>Symfony\\Component\\Lock\\Store\\FlockStore</code> to <code>Symfony\\Component\\Lock\\Store\\PdoStore</code> to support horizontally scaled setups out of the box</li> <li>Switch implementation of <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ResourceLockStorage.lock_factory</code> from <code>Symfony\\Component\\Lock\\Store\\FlockStore</code> to <code>Symfony\\Component\\Lock\\Store\\PdoStore</code> to support horizontally scaled setups out of the box</li> <li>Change id and implementation of <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ResourceLockStorage</code> to <code>Heptacom\\HeptaConnect\\Core\\Parallelization\\Contract\\ResourceLockStorageContract</code> implemented by <code>Heptacom\\HeptaConnect\\Core\\Parallelization\\ResourceLockStorage</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorageFactory</code> from <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageClearActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageDeleteActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageListActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageSetActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageGetActionInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Emission\\EmitContextFactory</code> from <code>Heptacom\\HeptaConnect\\Storage\\Core\\Mapping\\Contract\\MappingServiceInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> as previous services are removed</li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code> from <code>Heptacom\\HeptaConnect\\Storage\\Core\\Mapping\\Contract\\MappingServiceInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> as previous service is removed</li> <li>Remove argument <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> from service definition <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code></li> <li>Rename route <code>heptaconnect.http.handler</code> to <code>api.heptaconnect.http.handler</code></li> <li>Change usage of deprecated <code>Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface::publish</code> to <code>Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface::publishBatch</code> in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Explore::execute</code> and <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Core\\Mapping\\PublisherDecorator::flushBuffer</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Core\\Mapping\\PublisherDecorator</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\DependencyInjection\\CompilerPass\\RemoveBusMonitoring</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\DependencyInjection\\CompilerPass\\RemoveEntityCache</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Profiling\\Profiler</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Profiling\\ProfilerFactory</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\CommandsPrintLogsSubscriber</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerUrlProvider</code> and <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerUrlProviderFactory</code> to ensure correct usage of implementation. Decoration by their interfaces or base classes is still possible</li> <li>Add argument <code>Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\RequestStorageContract</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code></li> <li>Add call to <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder::setFileReferenceResolver</code> with argument <code>Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code></li> <li>Add argument <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\RequestContextHelper</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerUrlProviderFactoryInterface</code></li> <li>Switch dependency in <code>Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\ConfigurationServiceInterface</code> from <code>cache.system</code>, <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code> and <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\AliasStorageKeyGenerator</code> to all tagged services by tag <code>heptaconnect_core.portal_node_configuration.processor</code></li> <li>Change service id from <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code> to <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\StorageKeyGeneratorContract</code> and provide by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add argument <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\AliasValidator</code> to service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\AddPortalNode</code></li> <li>Replace <code>heptaconnect:support:alias:list</code> in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Support\\Alias\\ListAliases</code> with new command <code>heptaconnect:portal-node:alias:overview</code> in service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Alias\\Overview</code> to list all portal node keys and their aliases</li> <li>Replace <code>heptaconnect:support:alias:reset</code> in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Support\\Alias\\Reset</code> with new command <code>heptaconnect:portal-node:alias:reset</code> in service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Alias\\Reset</code> to remove an alias from a portal node key</li> <li>Replace <code>heptaconnect:support:alias:set</code> in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Support\\Alias\\Set</code> with new command <code>heptaconnect:portal-node:alias:set</code> in service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Alias\\Set</code> to set an alias to a portal node key</li> <li>Change implementation of <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\CommandsPrintLogsSubscriber</code> to support decoration of the logger. Replace argument <code>\\Psr\\Log\\LoggerInterface</code> with <code>\\Monolog\\Handler\\StreamHandler</code>.</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#removed","title":"Removed","text":"<ul> <li>Remove command <code>heptaconnect:job:cleanup-payloads</code> and service <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\CleanupPayloads</code> in favour of storages removing unused payloads with their jobs</li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepository</code> and its alias <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code></li> <li>Remove unused service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ConfigurationStorage</code> in favour of <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGetActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSetActionInterface</code></li> <li>Remove command <code>heptaconnect:cronjob:ensure-queue</code> and service <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Cronjob\\EnsureQueue</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove command <code>heptaconnect:cronjob:queue</code> and service <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Cronjob\\Queue</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove class and its service <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Messaging\\Cronjob\\CronjobRunHandler</code> and <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Messaging\\Cronjob\\CronjobRunMessageHandler</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Messaging\\Cronjob\\CronjobRunMessage</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove service <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobService</code>, <code>Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobContextFactory</code>, <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRepository</code>, <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRunRepository</code>, <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobDefinition</code> and <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunDefinition</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityMapperContract</code> in favour of storage action <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code> in favour of storage action <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code> in favour of storage action <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingExceptionRepository</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\DalAccess</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code></li> <li>Remove service <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor</code></li> <li>Remove composer dependency <code>dragonmantank/cron-expression</code></li> <li>Integrate service definition <code>Heptacom\\HeptaConnect\\Core\\Router\\Router.lock_store</code> as anonymous service parameter directly into the definition of <code>Heptacom\\HeptaConnect\\Core\\Router\\Router.lock_factory</code></li> <li>Integrate service definition <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ResourceLockStorage.lock_store</code> as anonymous service parameter directly into the definition of <code>Heptacom\\HeptaConnect\\Core\\Parallelization\\Contract\\ResourceLockStorageContract.lock_factory</code></li> <li>Remove support for <code>symfony/lock: &gt;=4 &lt;5.2</code> so the <code>Symfony\\Component\\Lock\\Store\\PdoStore</code> will automatically create the lock tables</li> <li>Remove support for <code>shopware/core: 6.3.*</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage</code> in favour of storage actions <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageClearActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageDeleteActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageListActionInterface</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageSetActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageGetActionInterface</code></li> <li>Remove service definitions for classes <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingErrorMessageDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingNodeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeStorageDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobPayloadDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobTypeDefinition</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteDefinition</code> as well as their generated services <code>heptaconnect_entity_type.repository</code>, <code>heptaconnect_mapping.repository</code>, <code>heptaconnect_mapping_error_message.repository</code>, <code>heptaconnect_mapping_node.repository</code>, <code>heptaconnect_portal_node.repository</code>, <code>heptaconnect_portal_node_storage.repository</code>, <code>heptaconnect_job.repository</code>, <code>heptaconnect_job_payload.repository</code>, <code>heptaconnect_job_type.repository</code> and <code>heptaconnect_route.repository</code> as DAL usage is removed in <code>heptacom/heptaconnect-storage-shopware-dal</code></li> <li>Remove deprecated <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Core\\Mapping\\PublisherDecorator::publish</code> inherited by <code>Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface::publish</code></li> <li>Remove support for <code>doctrine/dbal: &gt;=2.1 &lt;2.11</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Support\\AliasStorageKeyGenerator</code> as portal node alias support is integrated into <code>heptacom/heptaconnect-core</code></li> <li>Remove Shopware entity classes <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Content\\KeyAlias\\KeyAliasCollection</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Content\\KeyAlias\\KeyAliasDefinition</code> and <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Content\\KeyAlias\\KeyAliasEntity</code> for table <code>heptaconnect_bridge_key_alias</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#fixed_7","title":"Fixed","text":"<ul> <li>Change hardcoded <code>prod</code> environment in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\AbstractIntegration::getLifecycleContainer</code> to using the current one</li> <li>Add tag <code>console.command</code> to service definition of <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\CleanupFinished</code> to make the command available</li> <li>Add tag <code>console.command</code> to service definition of <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\Run</code> to make the command available</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#081-2022-03-04","title":"[0.8.1] - 2022-03-04","text":""},{"location":"releases/changelog-bridge-shopware-platform/#fixed_8","title":"Fixed","text":"<ul> <li>Add missing service tag for command <code>heptaconnect:job:run</code></li> <li>Add missing service tag for command <code>heptaconnect:job:cleanup-finished</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_8","title":"Added","text":"<ul> <li>Add command <code>heptaconnect:job:run</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\Run</code> to run jobs by key from the commandline</li> <li>Add command <code>heptaconnect:job:cleanup-finished</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\CleanupFinished</code> to remove finished jobs from the storage</li> <li>Add command <code>heptaconnect:job:cleanup-payloads</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\CleanupPayloads</code> to remove unused job data from the storage</li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\StreamPathContract</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\ReceptionRouteList</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteGet</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewActionInterface</code></li> <li>Add command <code>heptaconnect:router:list-capabilities</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\ListRouteCapabilities</code> to list available route capabilities</li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\RouteCapabilityAccessor</code></li> <li>Add column for route primary key and route capabilities to the output of <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\ListRoutes</code> named <code>heptaconnect:router:list-routes</code></li> <li>Add command <code>heptaconnect:http-handler:set-configuration</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Web\\HttpHandler\\Set</code> to set http handler configuration</li> <li>Add command <code>heptaconnect:http-handler:get-configuration</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Web\\HttpHandler\\Get</code> to read http handler configuration</li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathIdResolver</code></li> <li>Add command <code>heptaconnect:config:base-url:get</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Config\\GetBaseUrlCommand</code> to get base url for http handlers</li> <li>Add command <code>heptaconnect:config:base-url:set</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Config\\SetBaseUrlCommand</code> to set base url for http handlers</li> <li>Add service definition <code>Psr\\Http\\Message\\ResponseFactoryInterface.heptaconnect</code> factorized by <code>\\Http\\Discovery\\Psr17FactoryDiscovery::findResponseFactory</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet</code> as <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContextFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleContextFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilderFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerStackBuilderFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleService</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlingActor</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlingActorInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerUrlProviderFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerUrlProviderFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code> and http handling implementation</li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHostProviderContract</code> and implementation to simplify base URL configuration for integrators</li> <li>Add command <code>heptaconnect:http-handler:list-handlers</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Web\\HttpHandler\\ListHandlers</code> to list available HTTP handlers</li> <li>Add command <code>heptaconnect:portal-node:status:list-topics</code> in service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\ListStatusReportTopics</code> to list all supported status topics</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#changed_5","title":"Changed","text":"<ul> <li>Change service definition id from <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\DatasetEntityTypeAccessor</code> to <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor</code> and set new id for definitions of services <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityMapperContract</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Core\\Mapping\\PublisherDecorator::publish</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change name of service <code>heptaconnect_dataset_entity_type.repository.patched</code> to <code>heptaconnect_entity_type.repository.patched</code></li> <li>Change <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\DatasetEntityType\\DatasetEntityTypeDefinition</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeDefinition</code></li> <li>Change argument and variable names in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodes::configure</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodes::execute</code> and <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings::configure</code>, <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings::execute</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> to the service definition <code>Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> to the service definition <code>Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> to the service definition <code>Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code></li> <li>Add dependency <code>cache.system</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code> with dependencies on <code>Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService</code> and <code>heptacom_heptaconnect.logger</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code> with dependencies on <code>Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code></li> <li>Add dependency to tagged services of tag <code>heptaconnect.postprocessor</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveContextFactoryInterface</code>. The service that are tagged like this are <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code> and <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code></li> <li>Remove argument <code>Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService</code> from service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveContextFactoryInterface</code></li> <li>Remove argument <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code> from service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\StreamPathContract</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\StreamPathContract</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code></li> <li>Add dependency <code>heptacom_heptaconnect.logger</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Core\\Emission\\EmissionActor</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code></li> <li>Change service definition id based upon class <code>Heptacom\\HeptaConnect\\Core\\Emission\\EmissionActor</code> to match its interface <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\ListRoutes</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code>, <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> and <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerFactory</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code> in the service definition <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\AddRoute</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\AddRoute</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> into <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateActionInterface</code> and <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code></li> <li>Change output from <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\AddRoute</code> named <code>heptaconnect:router:add-route</code> to show all route information like <code>heptaconnect:router:list-routes</code></li> <li>Add dependency <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerUrlProviderFactoryInterface</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalStackServiceContainerBuilderInterface</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector</code> from <code>heptaconnect_mapping.repository.patched</code> to <code>heptaconnect_mapping.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage</code> from <code>heptaconnect_portal_node_storage.repository.patched</code> to <code>heptaconnect_portal_node_storage.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRepository</code> from <code>heptaconnect_cronjob.repository.patched</code> to <code>heptaconnect_cronjob.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRunRepository</code> from <code>heptaconnect_cronjob.repository.patched</code> to <code>heptaconnect_cronjob.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRunRepository</code> from <code>heptaconnect_cronjob_run.repository.patched</code> to <code>heptaconnect_cronjob_run.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingExceptionRepository</code> from <code>heptaconnect_mapping_error_message.repository.patched</code> to <code>heptaconnect_mapping_error_message.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code> from <code>heptaconnect_mapping.repository.patched</code> to <code>heptaconnect_mapping.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> from <code>heptaconnect_portal_node.repository.patched</code> to <code>heptaconnect_portal_node.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code> from <code>heptaconnect_mapping_node.repository.patched</code> to <code>heptaconnect_mapping_node.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code> from <code>heptaconnect_mapping.repository.patched</code> to <code>heptaconnect_mapping.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code> from <code>heptaconnect_mapping.repository.patched</code> to <code>heptaconnect_mapping.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> from <code>heptaconnect_job.repository.patched</code> to <code>heptaconnect_job.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> from <code>heptaconnect_job_type.repository.patched</code> to <code>heptaconnect_job_type.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code> from <code>heptaconnect_job_payload.repository.patched</code> to <code>heptaconnect_job_payload.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> from <code>heptaconnect_mapping_node.repository.patched</code> to <code>heptaconnect_mapping_node.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> from <code>heptaconnect_mapping.repository.patched</code> to <code>heptaconnect_mapping.repository</code></li> <li>Change dependency in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor</code> from <code>heptaconnect_entity_type.repository.patched</code> to <code>heptaconnect_entity_type.repository</code></li> <li>Move route annotation registration from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Webhook\\WebhookController</code> to <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code></li> <li>Change command name from <code>heptaconnect:portal-node:status</code> to <code>heptaconnect:portal-node:status:report</code></li> <li>Change option from <code>--dataset-entity-class</code> (<code>-d</code>) to <code>--entity-type</code> (<code>-t</code>) in <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\MappingNode\\ListMappingNodeSiblings</code> (<code>heptaconnect:mapping-node:siblings-list</code>)</li> <li>Add dependency <code>heptacom_heptaconnect.logger</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code></li> <li>Add dependency <code>heptacom_heptaconnect.logger</code> in the service definition <code>Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#removed_1","title":"Removed","text":"<ul> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookContextFactory</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookService</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookDefinition</code></li> <li>Remove service definition <code>heptaconnect_webhook.repository.patched</code></li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\WebhookRepository</code></li> <li>Remove class and its service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Webhook\\WebhookController</code> in favour of <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerController</code></li> <li>Remove class and its service definition <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Webhook\\UrlProvider</code> in favour of <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Web\\Http\\HttpHandlerUrlProviderFactory</code></li> <li>Remove patched entity repository services <code>heptaconnect_mapping_node.repository.patched</code>, <code>heptaconnect_mapping.repository.patched</code>, <code>heptaconnect_job.repository.patched</code>, <code>heptaconnect_job_type.repository.patched</code>, <code>heptaconnect_job_payload.repository.patched</code>, <code>heptaconnect_entity_type.repository.patched</code>, <code>heptaconnect_route.repository.patched</code>, <code>heptaconnect_portal_node_storage.repository.patched</code>, <code>heptaconnect_portal_node.repository.patched</code>, <code>heptaconnect_mapping_error_message.repository.patched</code>, <code>heptaconnect_cronjob_run.repository.patched</code> and <code>heptaconnect_cronjob.repository.patched</code></li> <li>Remove support for <code>shopware/core: 6.2.*</code> and therefore the compatibility patching process with <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\PatchProvider\\EntityRepository</code> and <code>\\Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\PatchProvider\\EntityRepositoryPatch587</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#fixed_9","title":"Fixed","text":"<ul> <li>Change behaviour of command <code>heptaconnect:router:list-routes</code> in <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\ListRoutes</code> to also list created routes that do not have supported flow components (anymore)</li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-bridge-shopware-platform/#added_9","title":"Added","text":"<ul> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code></li> </ul>"},{"location":"releases/changelog-bridge-shopware-platform/#changed_6","title":"Changed","text":"<ul> <li>Add dependency <code>heptacom_heptaconnect.logger</code> to service definition <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorageFactory</code></li> <li>Change service definition id based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContextFactory</code> to match its interface <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitContextFactoryInterface</code></li> <li>Change service definition id based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code> to match its interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\EmissionHandlerInterface</code></li> <li>Change service definition id based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code> to match its interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ExplorationHandlerInterface</code></li> <li>Change service definition id based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> to match its interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code></li> <li>Change service definition id based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContextFactory</code> to match its interface <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveContextFactoryInterface</code></li> <li>Change service definition id based upon class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository</code> to match its contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code></li> <li>Remove argument <code>Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService</code> from service definition <code>Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionFlowContract</code></li> </ul>"},{"location":"releases/changelog-core/","title":"Core Changelog","text":""},{"location":"releases/changelog-core/#0970-2024-02-10","title":"[0.9.7.0] - 2024-02-10","text":""},{"location":"releases/changelog-core/#added","title":"Added","text":"<ul> <li>Add exception code <code>1693671570</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\BuildDefinitionForFlowComponentRegistryCompilerPass::getServiceReferencesGroupedBySource</code> when a flow component service is missing a source attribute on its tag</li> <li>Add exception code <code>1693698154</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\BuildDefinitionForFlowComponentRegistryCompilerPass::getSourcePackage</code> when a referenced flow component package is not found in known packages</li> </ul>"},{"location":"releases/changelog-core/#changed","title":"Changed","text":"<ul> <li>Sort flow components by priority, if the service definition tag has a priority attribute</li> </ul>"},{"location":"releases/changelog-core/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecate parameter <code>$source</code> in method <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry::getExplorers</code></li> <li>Deprecate parameter <code>$source</code> in method <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry::getEmitters</code></li> <li>Deprecate parameter <code>$source</code> in method <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry::getReceivers</code></li> <li>Deprecate parameter <code>$source</code> in method <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry::getStatusReporters</code></li> <li>Deprecate parameter <code>$source</code> in method <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry::getWebHttpHandlers</code></li> <li>Deprecate method <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry::getOrderedSources</code></li> </ul>"},{"location":"releases/changelog-core/#0960-2023-07-10","title":"[0.9.6.0] - 2023-07-10","text":""},{"location":"releases/changelog-core/#added_1","title":"Added","text":"<ul> <li>Add log message code <code>1686752874</code> when handling of job failed in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code></li> <li>Add log message code <code>1686752879</code> when handling of job failed in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code></li> <li>Add log message code <code>1686752889</code> when handling of job failed in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code></li> </ul>"},{"location":"releases/changelog-core/#fixed","title":"Fixed","text":"<ul> <li>Fix a bug in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\AbstractFilesystem</code> that occurred when adapters don't populate the <code>path</code> key in metadata.</li> <li>Fix a bug in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpKernel</code> that broke sub-requests when the request contains no <code>Cookie</code> header.</li> <li>Fix order of packages when building a portal-container in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code>. Packages can now access services of other packages in their service definition, if they list that package in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::getAdditionalPackages</code>.</li> <li>Fix emission check in <code>\\Heptacom\\HeptaConnect\\Core\\Support\\EntityStatus::isMappedByEmitter</code> by validating external id instead of foreign key</li> </ul>"},{"location":"releases/changelog-core/#0950-2023-05-27","title":"[0.9.5.0] - 2023-05-27","text":""},{"location":"releases/changelog-core/#added_2","title":"Added","text":"<ul> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PackageCollection</code> to portal-container, containing the portal, all portal-extensions and all packages involved in building the container</li> <li>Add service <code>Psr\\Http\\Message\\ServerRequestFactoryInterface</code> to portal-container</li> <li>Add service <code>Psr\\Http\\Message\\UploadedFileFactoryInterface</code> to portal-container</li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpKernelInterface</code> to portal-container to execute a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerStackInterface</code> from inside a portal</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContext::forward</code> for <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandleContextInterface::forward</code></li> <li>Add composer dependency <code>riverline/multipart-parser:^2.1</code> to support parsing body-data of <code>\\Psr\\Http\\Message\\ServerRequestInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpKernel</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Psr7MessageMultiPartFormDataBuilder</code> for <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageMultiPartFormDataBuilderInterface</code> to build HTTP payloads for multipart messages</li> <li>Add exception code <code>1682806294</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Psr7MessageMultiPartFormDataBuilder::build</code> when an input parameter is of an illegal type</li> </ul>"},{"location":"releases/changelog-core/#changed_1","title":"Changed","text":"<ul> <li>Use <code>\\Psr\\Http\\Message\\StreamInterface::__toString</code> instead of <code>\\Psr\\Http\\Message\\StreamInterface::getContents</code> to retrieve stream contents in <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedContentsFileReference</code>, <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedPublicUrlFileReference</code> and <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedRequestFileReference</code>. This way, all stream contents are retrieved, regardless of the position of the stream pointer.</li> <li>Add dependency on <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> to set job-states to <code>failed</code> in case of an error</li> <li>Allow handling of HTTP requests, even when no HTTP handler exists for the requested path. This means, middlewares for HTTP handlers will run for every request.</li> <li>Add argument <code>bool $isStackEmpty</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Handler\\HttpMiddlewareChainHandler</code> to indicate whether the related instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerStackInterface</code> is empty.</li> <li>Change log level of code <code>1636845086</code> from <code>critical</code> to <code>notice</code></li> </ul>"},{"location":"releases/changelog-core/#fixed_1","title":"Fixed","text":"<ul> <li>Remove a step in building a portal-container that would remove all services that extend <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code></li> <li>Catch exceptions when running jobs and setting the affected jobs to failed state. Also change behavior in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> to continue with the remaining jobs.</li> </ul>"},{"location":"releases/changelog-core/#0940-2023-03-04","title":"[0.9.4.0] - 2023-03-04","text":""},{"location":"releases/changelog-core/#added_3","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Support\\HeaderUtility</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Support\\Contract\\HeaderUtilityInterface</code> to work with PSR-7 message headers</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageRawHttpFormatter</code> extending <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatter</code> to provide raw HTTP message formatting</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageCurlShellFormatter</code> extending <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code> to provide cURL shell command formatting</li> <li>Add exception code <code>1674950000</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageRawHttpFormatter::formatMessage</code> when the given message is neither a request nor a response</li> <li>Add exception code <code>1674950001</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageRawHttpFormatter::getFileExtension</code> when the given message is neither a request nor a response</li> <li>Add exception code <code>1674950002</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageCurlShellFormatter::formatMessage</code> when the given message is neither a request nor a response</li> <li>Add exception code <code>1674950003</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Formatter\\Psr7MessageCurlShellFormatter::getFileExtension</code> when the given message is neither a request nor a response</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\HttpHandlerDumpPathProviderInterface</code>, that needs to be implemented by bridges and integrations, to return the path for placing HTTP handler dumps</li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface::REQUEST_ATTRIBUTE_PREFIX</code> to identify all request attributes, that can be used as value holders for additional parameters attached to requests to the core layer</li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface::REQUEST_ATTRIBUTE_ORIGINAL_REQUEST</code> as request attribute key holding an instance of <code>\\Psr\\Http\\Message\\ServerRequestInterface</code> of the original inbound HTTP request used for debugging purposes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\ServerRequestCycleDumper</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumperInterface</code> to dump a request cycle in a way, that they can be associated, when accessing the dumps</li> <li>Add sample rate strategy implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\SampleRateServerRequestCycleDumpChecker</code> for new interface <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface</code> using configuration <code>dump-sample-rate</code> for HTTP handlers, which can be an integer between 0 and 100, that will be used to determine whether a request-cycle will be dumped. Use value 100 for a request-response dump on every request</li> </ul>"},{"location":"releases/changelog-core/#changed_2","title":"Changed","text":"<ul> <li>Add dependency on <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code> to provide service for raw HTTP message formatting</li> <li>Add dependency on <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatterContract</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code> to provide service for cURL shell command formatting</li> <li>Add dependency on <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumpCheckerInterface</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Dump\\Contract\\ServerRequestCycleDumperInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleService</code> to dump requests and responses from HTTP handling</li> </ul>"},{"location":"releases/changelog-core/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecate class <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Exception\\DelegatingLoaderLoadException</code>. Use <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Exception\\DelegatingLoaderLoadException</code> instead.</li> </ul>"},{"location":"releases/changelog-core/#fixed_2","title":"Fixed","text":"<ul> <li>Fix issue in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code> when a composer package with a portal has multiple PSR-4 entries in its <code>composer.json</code></li> <li>Fix container compile error when an excluded service has an automatic alias from its interface.</li> </ul>"},{"location":"releases/changelog-core/#0930-2022-11-26","title":"[0.9.3.0] - 2022-11-26","text":""},{"location":"releases/changelog-core/#added_4","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\Contract\\StreamUriSchemePathConverterInterface</code> to convert between URIs and paths when using paths as contextualized URIs</li> <li>Add exception code <code>1666942800</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToUri</code> when the path is not a compatible URI</li> <li>Add exception code <code>1666942801</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToUri</code> when the path already has a protocol</li> <li>Add exception code <code>1666942802</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToUri</code> when the path has a port</li> <li>Add exception code <code>1666942803</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToUri</code> when the path has query parameters</li> <li>Add exception code <code>1666942804</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToUri</code> when the path has a URI fragment</li> <li>Add exception code <code>1666942810</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToPath</code> when the URI is not a URI</li> <li>Add exception code <code>1666942811</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToPath</code> when the URI has no host</li> <li>Add exception code <code>1666942812</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToPath</code> when the URI has a port</li> <li>Add exception code <code>1666942813</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToPath</code> when the URI has query parameters</li> <li>Add exception code <code>1666942814</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\StreamUriSchemePathConverter::convertToPath</code> when the URI has a URI fragment</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\Filesystem</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> to provide a path conversion for portals</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\Contract\\StreamWrapperInterface</code> to describe, what the PHP documentation describes as signatures for a class to use as a stream wrapper</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\PortalNodeFilesystemStreamProtocolProviderInterface</code>, that needs to be implemented by bridges and integrations, to create portal node specific stream protocols</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\FilesystemFactory</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\Contract\\FilesystemFactoryInterface</code> to create portal node specific instances of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code></li> <li>Add stream wrapper implementation <code>\\Heptacom\\HeptaConnect\\Core\\File\\Filesystem\\RewritePathStreamWrapper</code> to rewrite requested paths to a new protocol while changing the protocol and the path itself</li> </ul>"},{"location":"releases/changelog-core/#changed_3","title":"Changed","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\AbstractFilesystem::getConfig</code> to forward the decorated filesystem config</li> <li>Wrap result of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\PrefixFilesystem::getAdapter</code> into an adaptor decorator of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\PrefixAdapter</code> to ensure that adapter usage will apply same path rewrites like the filesystem itself</li> <li>Add dependency on <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\File\\Filesystem\\Contract\\FilesystemFactoryInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code> to provide a <code>Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> service for portal nodes</li> </ul>"},{"location":"releases/changelog-core/#fixed_3","title":"Fixed","text":"<ul> <li>Changed return type of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Filesystem\\AbstractFilesystem::getAdapter</code> from <code>\\League\\Flysystem\\FilesystemInterface</code> to <code>\\League\\Flysystem\\AdapterInterface</code> by returning the decorated filesystem adapter instead of the filesystem itself</li> </ul>"},{"location":"releases/changelog-core/#0920-2022-10-16","title":"[0.9.2.0] - 2022-10-16","text":""},{"location":"releases/changelog-core/#added_5","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpMiddlewareClient</code> to execute a chain of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface</code> services for outbound HTTP requests via <code>\\Psr\\Http\\Client\\ClientInterface</code> from a portal-node context.</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AddHttpMiddlewareClientCompilerPass</code> to automatically tag services implementing <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface</code> with <code>heptaconnect.http.client.middleware</code>.</li> <li>Execute a chain of <code>\\Psr\\Http\\Server\\MiddlewareInterface</code> services for inbound HTTP request via <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AddHttpMiddlewareCollectorCompilerPass</code> to automatically tag services implementing <code>\\Psr\\Http\\Server\\MiddlewareInterface</code> with <code>heptaconnect.http.handler.middleware</code>.</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Support\\HttpMiddlewareCollector</code> as a service in the portal-node container. It is used to retrieve tagged middleware services from the container.</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Handler\\HttpMiddlewareChainHandler</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpMiddlewareHandler</code> to wrap execution of middleware chain</li> <li>Add composer dependency <code>psr/http-server-handler: ^1.0</code> and <code>psr/http-server-middleware: ^1.0</code> to support PSR-15 middlewares for HTTP handlers</li> <li>Add exception code <code>1651338559</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::list</code> when unpacking a single entry fails</li> <li>Add exception code <code>1651338621</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code> when denormalizing any stored value fails</li> </ul>"},{"location":"releases/changelog-core/#fixed_4","title":"Fixed","text":"<ul> <li>Only load dev-packages from <code>composer.lock</code> file when dev-mode is active in <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfigurationLoader</code></li> <li>Only check for dev-mode in <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfigurationLoader</code>, if the installed version of composer supports it.</li> <li>Skip broken entries in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::list</code> instead of returning an empty list</li> </ul>"},{"location":"releases/changelog-core/#0911-2022-09-28","title":"[0.9.1.1] - 2022-09-28","text":""},{"location":"releases/changelog-core/#added_6","title":"Added","text":"<ul> <li>Load composer packages also from <code>require-dev</code> section of <code>composer.lock</code> file in <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfigurationLoader</code></li> </ul>"},{"location":"releases/changelog-core/#0910-2022-08-15","title":"[0.9.1.0] - 2022-08-15","text":""},{"location":"releases/changelog-core/#changed_4","title":"Changed","text":"<ul> <li>Move decision of exclusion by class for automatically created portal node container services from <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\RemoveAutoPrototypedDefinitionsCompilerPass</code> into <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::getContainerExcludedClasses</code></li> </ul>"},{"location":"releases/changelog-core/#fixed_5","title":"Fixed","text":"<ul> <li>Fix reception of multiple entities with the same identity within a single batch in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code></li> <li>Add fallback value for the reported topic in <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReportingService::reportSingleTopic</code></li> <li>Prevent parallelization lock from being released immediately after creating or checking it in <code>\\Heptacom\\HeptaConnect\\Core\\Parallelization\\ResourceLockStorage</code></li> </ul>"},{"location":"releases/changelog-core/#0902-2022-04-23","title":"[0.9.0.2] - 2022-04-23","text":""},{"location":"releases/changelog-core/#fixed_6","title":"Fixed","text":"<ul> <li>Portal instances and portal extension instances are not shared across multiple portal node service containers anymore. If these instances are used stateful, portal node A can affect portal node B. All packages we provide have been checked negative against stateful usage of portal and portal extension instances.</li> <li>Portal extension stacks are now built for each portal node instead for each portal. This resulted in portal node service containers with active portal extension that have not been set active for the stack's portal node. It only occurs when more than one portal node service containers of the same portal is created in a single PHP process e.g. a message consumption process.</li> <li>Portal node configuration for preview portal nodes are now loaded statically again</li> <li>Portal node service container for preview portal nodes are now loaded statically again</li> </ul>"},{"location":"releases/changelog-core/#0901-2022-04-19","title":"[0.9.0.1] - 2022-04-19","text":""},{"location":"releases/changelog-core/#fixed_7","title":"Fixed","text":"<ul> <li>Fix order of portals and portal extensions in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry</code></li> <li>Fix creating identity error messages in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor::handle</code></li> <li>Fix a critical error when writing portal node configuration</li> </ul>"},{"location":"releases/changelog-core/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-core/#added_7","title":"Added","text":"<ul> <li>Implement <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerCodeOriginFinderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerCodeOriginFinder</code></li> <li>Add exception code <code>1637607699</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerCodeOriginFinder::findOrigin</code> when HTTP handler is a short-notation HTTP handler and has no configured callback</li> <li>Add exception code <code>1637607700</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerCodeOriginFinder::findOrigin</code> when HTTP handler class cannot be read via reflection</li> <li>Add exception code <code>1637607701</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerCodeOriginFinder::findOrigin</code> when HTTP handler class does not belong to a physical file</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterCodeOriginFinderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterCodeOriginFinder</code></li> <li>Add exception code <code>1637607653</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterCodeOriginFinder::findOrigin</code> when emitter is a short-notation emitter and has no configured callback</li> <li>Add exception code <code>1637607654</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterCodeOriginFinder::findOrigin</code> when emitter class cannot be read via reflection</li> <li>Add exception code <code>1637607655</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterCodeOriginFinder::findOrigin</code> when emitter class does not belong to a physical file</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerCodeOriginFinderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerCodeOriginFinder</code></li> <li>Add exception code <code>1637421327</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerCodeOriginFinder::findOrigin</code> when explorer is a short-notation explorer and has no configured callback</li> <li>Add exception code <code>1637421328</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerCodeOriginFinder::findOrigin</code> when explorer class cannot be read via reflection</li> <li>Add exception code <code>1637421329</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerCodeOriginFinder::findOrigin</code> when explorer class does not belong to a physical file</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverCodeOriginFinderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverCodeOriginFinder</code></li> <li>Add exception code <code>1641079368</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverCodeOriginFinder::findOrigin</code> when receiver is a short-notation receiver and has no configured callback</li> <li>Add exception code <code>1641079369</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverCodeOriginFinder::findOrigin</code> when receiver class cannot be read via reflection</li> <li>Add exception code <code>1641079370</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverCodeOriginFinder::findOrigin</code> when receiver class does not belong to a physical file</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterCodeOriginFinderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReporterCodeOriginFinder</code></li> <li>Add exception code <code>1641079371</code> in <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReporterCodeOriginFinder::findOrigin</code> when status reporter is a short-notation status reporter and has no configured callback</li> <li>Add exception code <code>1641079372</code> in <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReporterCodeOriginFinder::findOrigin</code> when status reporter class cannot be read via reflection</li> <li>Add exception code <code>1641079373</code> in <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReporterCodeOriginFinder::findOrigin</code> when status reporter class does not belong to a physical file</li> <li>Add logger decorator <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Logger\\FlowComponentCodeOriginFinderLogger</code> that replaces instances of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code> within the context with their code origin</li> <li>Add new service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientContract</code> to portal node container as an alternative to <code>Psr\\Http\\Client\\ClientInterface</code> with behaviour by configuration e.g. that can throw <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Exception\\HttpException</code> on certain status code</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Logger\\ExceptionCodeLogger</code> intended as a decorator to prepend the exception code to log messages if available</li> <li>Add log message code <code>1647396033</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\MessageQueueFlow\\MessageHandler::handleJob</code> when jobs from message cannot be loaded</li> <li>Add log message code <code>1647396034</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\MessageQueueFlow\\MessageHandler::handleJob</code> when jobs from message cannot be processed</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Core\\Parallelization\\Contract\\ResourceLockStorageContract</code> migrated from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\ResourceLockStorageContract</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Parallelization\\ResourceLockStorage</code> for <code>\\Heptacom\\HeptaConnect\\Core\\Parallelization\\Contract\\ResourceLockStorageContract</code> that depends on <code>symfony/lock</code> which is already required</li> <li>Add log message code <code>1646383738</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::list</code> when reading portal node storage entries fails</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PreviewPortalNodeStorage</code> for the interface <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface</code> to support interactions on <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PreviewPortalNodeKey</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\FileContentsUrlProviderInterface</code> to provide public URLs for normalized streams</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\File\\FileRequestUrlProviderInterface</code> to prode public URLs for serialized requests</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\FileReferenceFactory</code> to create file references from public URLs, request objects or file contents</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\FileReferenceResolver</code> to resolve file references for read operations</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\Reference\\ContentsFileReference</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code> that is created from file contents</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\Reference\\PublicUrlFileReference</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code> that is created from a public URL</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\Reference\\RequestFileReference</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code> that is created from a PSR-7 request object</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedContentsFileReference</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\ResolvedFileReferenceContract</code> for file references that were created from file contents</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedPublicUrlFileReference</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\ResolvedFileReferenceContract</code> for file references that were created from a public URL</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedRequestFileReference</code> as implementation of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\ResolvedFileReferenceContract</code> for file references that were created from a PSR-7 request object</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestDenormalizer</code> to deserialize instances of <code>\\Psr\\Http\\Message\\RequestInterface</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestNormalizer</code> to serialize instances of <code>\\Psr\\Http\\Message\\RequestInterface</code></li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\RequestStorageContract</code> with implementation in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\RequestStorage</code> to persist and load instances of <code>\\Psr\\Http\\Message\\RequestInterface</code></li> <li>Add exception code <code>1647788744</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\FileReferenceFactory::fromContents</code> when the NormalizationRegistry is missing a normalizer for streams</li> <li>Add exception code <code>1648315863</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\FileReferenceFactory::fromContents</code> when the normalizer is unable to serialize the given file contents</li> <li>Add exception code <code>1647788896</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\FileReferenceResolver::resolve</code> when the NormalizationRegistry is missing a denormalizer for streams</li> <li>Add exception code <code>1647789133</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\FileReferenceResolver::resolve</code> when the FileReference has an unsupported source</li> <li>Add exception code <code>1647789503</code> in <code>\\Heptacom\\HeptaConnect\\Core\\File\\ResolvedReference\\ResolvedContentsFileReference::getContents</code> when denormalizing a normalized stream fails</li> <li>Add exception code <code>1647789809</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestNormalizer::normalize</code> when trying to normalize anything other than a request object</li> <li>Add exception code <code>1647790094</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\RequestStorage::load</code> when denormalizing a serialized request fails</li> <li>Add exception code <code>1647791094</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\RequestStorage::load</code> when a serialized request is not found</li> <li>Add exception code <code>1647791390</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\RequestStorage::persist</code> when persisting a serialized request fails</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Contract\\InstructionTokenContract</code> to define a contract for changing portal node configurations</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\ClosureInstructionToken</code> that changes portal node configuration by the given closure</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\PortalNodeConfigurationHelper</code> to generate closures for processing configuration sources like json files and environment variables</li> <li>Add exception code <code>1647801828</code> in return callable from <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\PortalNodeConfigurationHelper::ini</code> when the ini file can not be loaded and parsed</li> <li>Add exception code <code>1647801829</code> in return callable from <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\PortalNodeConfigurationHelper::json</code> when the JSON file can not be loaded and parsed</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config</code> to collect <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Contract\\InstructionTokenContract</code> in a short-notation manner</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Contract\\InstructionLoaderInterface</code> to identify services that provide <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Contract\\InstructionTokenContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\InstructionFileLoader</code> to provide <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Contract\\InstructionTokenContract</code> using <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config</code></li> <li>Add exception code <code>1645611612</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\InstructionFileLoader::loadInstructions</code> when referenced file can not be loaded</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationInstructionProcessor</code> as <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\PortalNodeConfigurationProcessorInterface</code> to change portal node configuration by instructions from given <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Contract\\InstructionLoaderInterface</code> instances</li> <li>Add log message code <code>1647826121</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationInstructionProcessor</code> when an error happens during instruction loading</li> </ul>"},{"location":"releases/changelog-core/#changed_5","title":"Changed","text":"<ul> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\MessageQueueFlow\\MessageHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobGetActionInterface</code> to improve performance by batching job reading</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code> to improve performance by batching job state changes</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code> to improve performance by batching job state changes</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code> to improve performance by batching job state changes</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\JobDispatcher</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobCreateActionInterface</code> to improve performance by batching job insertion</li> <li>Switch storage access in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeGetActionInterface</code></li> <li>Use portal node container tags <code>heptaconnect.flow_component.status_reporter_source</code>, <code>heptaconnect.flow_component.emitter_source</code>, <code>heptaconnect.flow_component.explorer_source</code>, <code>heptaconnect.flow_component.receiver_source</code>, <code>heptaconnect.flow_component.web_http_handler_source</code> instead of <code>heptaconnect.flow_component.emitter</code>, <code>heptaconnect.flow_component.emitter_decorator</code>, <code>heptaconnect.flow_component.explorer</code>, <code>heptaconnect.flow_component.explorer_decorator</code>, <code>heptaconnect.flow_component.receiver</code>, <code>heptaconnect.flow_component.receiver_decorator</code> and <code>heptaconnect.flow_component.web_http_handler</code> to collect flow component services</li> <li>Short-noted flow components by portals load on first flow component usage instead of on container building using <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\FlowComponentRegistry</code></li> <li>Add dependency onto <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionFindActionInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code> for loading portal extension availability</li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder</code> logger usage</li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder</code> logger usage</li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder</code> logger usage</li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilder</code> logger usage</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\ConfigurationStorageContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGetActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSetActionInterface</code> to improve performance on reading and writing portal node configuration</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityMapperContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code> as previous service is renamed</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityReflectorContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityReflectActionInterface</code> as previous service is renamed</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code></li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code> as previous service is renamed</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorageFactory</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageClearActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageDeleteActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageGetActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageListActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageSetActionInterface</code></li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContext</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Core\\Mapping\\Contract\\MappingServiceInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> as previous services are removed</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContextFactory</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Core\\Mapping\\Contract\\MappingServiceInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> as previous services are removed</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Core\\Mapping\\Contract\\MappingServiceInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> as previous service is removed</li> <li>Split argument in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveServiceInterface::receive</code> of type <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\TypedMappedDatasetEntityCollection</code> into <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface</code> to state target portal clearly</li> <li>Extract caching of <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code> into new class <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationCacheProcessor</code> using the <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\PortalNodeConfigurationProcessorInterface</code> interface</li> <li>Make classes final: <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfigurationLoader</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmissionActor</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitService</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilderFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmitter</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilderFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreService</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\DirectEmissionFlow</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\DelegatingJobActor</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\JobDispatcher</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingStruct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Publisher</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AddPortalConfigurationBindingsCompilerPass</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AllDefinitionDefaultsCompilerPass</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\BuildDefinitionForFlowComponentRegistryCompilerPass</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\RemoveAutoPrototypedDefinitionsCompilerPass</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalConfiguration</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalRegistry</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PreviewPortalNodeStorage</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilderFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor</code>, <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReportingContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReportingContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReportingService</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\ScalarDenormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\ScalarNormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableCompressDenormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableDenormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableNormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\NormalizationRegistry</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Support\\EntityStatus</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilderFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleService</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlingActor</code></li> </ul>"},{"location":"releases/changelog-core/#removed","title":"Removed","text":"<ul> <li>Remove separation of source flow components and decorator flow components in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilder</code>. First flow component in list is always the source</li> <li>Remove portal node container service ids <code>Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection.decorator</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection.decorator</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\StatusReporterCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection.decorator</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection</code> and <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection.decorator</code> due to refactoring of flow component stack building</li> <li>Remove dependency on <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code></li> <li>Remove classes <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobContextFactory</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobService</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove composer dependency <code>dragonmantank/cron-expression</code></li> <li>Remove unused implementation <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::get</code> of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::get</code></li> <li>Remove unused implementation <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::save</code> of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::save</code></li> <li>Remove unused implementation <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::reflect</code> of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::reflect</code></li> <li>Remove unused implementation <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::addException</code> of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::addException</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::getListByExternalIds</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface::map</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::merge</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Exception\\MappingNodeAreUnmergableException</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Exception\\MappingNodeNotCreatedException</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code></li> <li>Remove log message code <code>1631563639</code>, <code>1631563699</code>, <code>1631565446</code> and <code>1631565376</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code></li> <li>Remove deprecated methods <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::canSet</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::canGet</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Core\\Router\\CumulativeMappingException</code></li> <li>Remove dependency on <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code></li> <li>Remove deprecated method <code>Heptacom\\HeptaConnect\\Core\\Mapping\\Publisher::publish</code> inherited from <code>Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface::publish</code></li> </ul>"},{"location":"releases/changelog-core/#fixed_8","title":"Fixed","text":"<ul> <li>Portal node extensions can supply source flow components for data types that have not been introduced by the decorated portal</li> <li>All aliases in the dependency-injection container for portals are now public. This enables injection of aliased services in short-notation flow-components.</li> </ul>"},{"location":"releases/changelog-core/#086-2022-03-07","title":"[0.8.6] - 2022-03-07","text":""},{"location":"releases/changelog-core/#fixed_9","title":"Fixed","text":"<ul> <li>Prevent leak of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Support\\PostProcessorDataBag</code> into subsequent iterations of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor::performReception</code>. Every entry of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedData</code> is now only handled once.</li> </ul>"},{"location":"releases/changelog-core/#085-2021-12-28","title":"[0.8.5] - 2021-12-28","text":""},{"location":"releases/changelog-core/#fixed_10","title":"Fixed","text":"<ul> <li>Change composer dependency <code>bentools/iterable-functions: &gt;=1 &lt;2</code> to <code>bentools/iterable-functions: &gt;=1.4 &lt;2</code> to ensure availability of <code>\\iterable_map</code> in a lowest-dependency-version installation</li> <li>Change composer dependency <code>composer/composer: &gt;=1</code> to <code>composer/composer: &gt;=1.9</code> to ensure correct composer project and library parsing in a lowest-dependency-version installation</li> <li>Change composer dependency <code>php-http/discovery: ^1.0</code> to <code>php-http/discovery: ^1.11</code> to ensure availability of <code>\\Http\\Discovery\\Psr17FactoryDiscovery</code> and <code>\\Http\\Discovery\\Psr17FactoryDiscovery::findUriFactory</code> in a lowest-dependency-version installation</li> <li>Add composer dependency <code>symfony/event-dispatcher-contracts: &gt;=1.1</code> to ensure availability of <code>\\Symfony\\Contracts\\EventDispatcher\\Event</code> in a lowest-dependency-version installation</li> <li>Change composer dependency <code>symfony/polyfill-php80: &gt;=1.15</code> to <code>symfony/polyfill-php80: &gt;=1.16</code> to ensure availability of <code>\\str_starts_with</code> a php 7.4 and lowest-dependency-version installation</li> <li>Amend signature of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\ScalarDenormalizer::denormalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\ScalarDenormalizer::supportsDenormalization</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\ScalarNormalizer::normalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\ScalarNormalizer::supportsNormalization</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableCompressDenormalizer::denormalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableCompressDenormalizer::supportsDenormalization</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableCompressNormalizer::normalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableDenormalizer::denormalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableDenormalizer::supportsDenormalization</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableNormalizer::normalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableNormalizer::supportsNormalization</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer::denormalize</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer::supportsDenormalization</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer::normalize</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer::supportsNormalization</code> to allow installations of <code>symfony/serializer: &gt;=4</code> and <code>symfony/serializer: &gt;= 5</code></li> </ul>"},{"location":"releases/changelog-core/#084-2021-12-16","title":"[0.8.4] - 2021-12-16","text":""},{"location":"releases/changelog-core/#removed_1","title":"Removed","text":"<ul> <li>Remove the code for unit tests, configuration for style checks as well as the Makefile</li> </ul>"},{"location":"releases/changelog-core/#fixed_11","title":"Fixed","text":"<ul> <li>Provide portal node container services as definition instead of synthetic service to allow decoration for service ids <code>Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepCloneContract</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract</code>, <code>Psr\\Http\\Client\\ClientInterface</code>, <code>Psr\\Http\\Message\\RequestFactoryInterface</code>, <code>Psr\\Http\\Message\\UriFactoryInterface</code>, <code>Psr\\Http\\Message\\ResponseFactoryInterface</code> and <code>Psr\\Http\\Message\\StreamFactoryInterface</code></li> <li>Remove expired keys from the result of <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::getMultiple</code></li> </ul>"},{"location":"releases/changelog-core/#083-2021-12-02","title":"[0.8.3] - 2021-12-02","text":""},{"location":"releases/changelog-core/#fixed_12","title":"Fixed","text":"<ul> <li>Fix auto-wiring array values from portal configuration</li> </ul>"},{"location":"releases/changelog-core/#082-2021-11-25","title":"[0.8.2] - 2021-11-25","text":""},{"location":"releases/changelog-core/#fixed_13","title":"Fixed","text":"<ul> <li>Fix type error during reception when entity with numeric primary key is received</li> </ul>"},{"location":"releases/changelog-core/#081-2021-11-22","title":"[0.8.1] - 2021-11-22","text":""},{"location":"releases/changelog-core/#fixed_14","title":"Fixed","text":"<ul> <li>Fix stack building to allow for decorators. Previously when a portal extension had provided a decorator for a flow component, the stack would only contain the decorator and would miss the source component. (<code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::pushSource</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::pushSource</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::pushSource</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilder::pushSource</code>)</li> </ul>"},{"location":"releases/changelog-core/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-core/#added_8","title":"Added","text":"<ul> <li>Add calls to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::start</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::finish</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler::triggerEmission</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler::triggerExplorations</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> to track job states</li> <li>Add caching layer to <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService::getPortalNodeConfiguration</code></li> <li>Add composer dependency <code>symfony/event-dispatcher: ^4.0 || ^5.0</code></li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::MARK_AS_FAILED_ENTITY_IS_UNMAPPED</code> with log message code <code>1637456198</code> for issues during logging error messages during reception</li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::RECEIVE_NO_SAVE_MAPPINGS_NOT_PROCESSED</code> for issues after saving mappings after a reception</li> <li>Introduce <code>\\Heptacom\\HeptaConnect\\Core\\Event\\PostReceptionEvent</code> for reception new event dispatcher in reception</li> <li>Add post-processing type <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\PostProcessing\\MarkAsFailedData</code></li> <li>Implement new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiveContextInterface::getEventDispatcher</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::getEventDispatcher</code></li> <li>Implement new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiveContextInterface::getPostProcessingBag</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::getEventDispatcher</code></li> <li>Add post-processor base class <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\PostProcessorContract</code></li> <li>Add post-processing for failed receptions using <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedData</code> and handled in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code></li> <li>Add post-processing for saving mappings after receptions using <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsData</code> and handled in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code></li> <li>Extract path building from <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer</code> into new service <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\StreamPathContract</code></li> <li>Add log messages codes <code>1634868818</code>, <code>1634868819</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer</code></li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::STORAGE_STREAM_NORMALIZER_CONVERTS_HINT_TO_FILENAME</code> with the message code <code>1635462690</code> to track generated filenames from the stream file storage in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code></li> <li>Add log exception code <code>1636503503</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job has no related route</li> <li>Add log exception code <code>1636503504</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job has no entity</li> <li>Add log exception code <code>1636503505</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job refers a non-existing route</li> <li>Add log exception code <code>1636503506</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job refers to a route that is not configured to allow receptions</li> <li>Add log exception code <code>1636503507</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job has an entity, that is of a different type than the route's entity type</li> <li>Add log exception code <code>1636503508</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> when job has an entity, that has a different primary key than the one saved on the job</li> <li>Add web HTTP handler context factory interface <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleContextFactoryInterface</code> and implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContextFactory</code> as well as <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContext</code></li> <li>Add web HTTP stack building interfaces <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerStackBuilderFactoryInterface</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerStackBuilderInterface</code> and implementations <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilderFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilder</code> for acting with web HTTP handlers</li> <li>Add web HTTP service interface <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface</code> and implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleService</code> to validate and handle requests</li> <li>Add web HTTP actor interface <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlingActorInterface</code> and implementation <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlingActor</code> to process any request through a web HTTP handler stack</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerUrlProviderFactoryInterface</code> for bridges to provide implementation as bridges implement routing</li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::WEB_HTTP_HANDLE_NO_THROW</code> used with log message code <code>1636845126</code> when handling the web request triggered an exception in the flow component</li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::WEB_HTTP_HANDLE_NO_HANDLER_FOR_PATH</code> used with log message code <code>1636845086</code> when handling the web request could not match any flow component</li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::WEB_HTTP_HANDLE_DISABLED</code> used with log message code <code>1636845085</code> when route is disabled and still called</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Exception\\GzipCompressException</code> for cases when gzip related methods fail</li> <li>Add exception code <code>1637432095</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableCompressNormalizer::normalize</code> when <code>gzcompress</code> fails to compress</li> <li>Add exception code <code>1637101289</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer::denormalize</code> when file to denormalize does not exist</li> <li>Add exception code <code>1637432853</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer::normalize</code> when object is no <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream</code></li> <li>Add exception code <code>1637432854</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer::normalize</code> when object does not hold a valid stream</li> <li>Add exception code <code>1637433403</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AddPortalConfigurationBindingsCompilerPass::process</code> when an array_combine call fails that logically should not be able to fail</li> <li>Add log message <code>\\Heptacom\\HeptaConnect\\Core\\Component\\LogMessage::EMIT_NO_PRIMARY_KEY</code> used with log message code <code>1637434358</code> when emitted entity has no primary key</li> <li>Add parameter <code>$jobKey</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\JobData::__construct</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Core\\Job\\JobData::getJobKey</code></li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerUrlProviderInterface</code> to portal container</li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection</code> to portal container</li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection.decorator</code> to portal container</li> <li>Add log message code <code>1637527920</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor::handle</code> when an entity has been received with a primary key but has no mapping data</li> <li>Add log message code <code>1637527921</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor::handle</code> when an entity has been received with a primary key but has invalid mapping data</li> </ul>"},{"location":"releases/changelog-core/#changed_6","title":"Changed","text":"<ul> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContext::markAsFailed</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackBuilderFactoryInterface::createEmitterStackBuilder</code> from <code>$entityClassName</code> to <code>$entityType</code>, respective change in its implementing class <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilderFactory::createEmitterStackBuilder</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::__construct</code> from <code>$entityClassName</code> to <code>$entityType</code>. Change the field name in corresponding functions that use the field (<code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::push</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::pushSource</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::pushDecorators</code>)</li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitService::getEmitterStack</code> from <code>$entityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackBuilderFactoryInterface::createExplorerStackBuilder</code> from <code>$entityClassName</code> to <code>$entityType</code>, respective change in its implementing class <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilderFactory::createExplorerStackBuilder</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface::performExploration</code> from <code>$entityClassName</code> to <code>$entityType</code>, respective change in its implementing class <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor::performExploration</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::__construct</code> from <code>$entityClassName</code> to <code>$entityType</code>. Change the field name in corresponding functions that use the field (<code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::push</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::pushSource</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::pushDecorators</code>)</li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiverStackBuilderFactoryInterface::createReceiverStackBuilder</code> from <code>$entityClassName</code> to <code>$entityType</code>, respective change in its implementing class <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilderFactory::createReceiverStackBuilder</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::__construct</code> from <code>$entityClassName</code> to <code>$entityType</code>. Change the field name in corresponding functions that use the field (<code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::push</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::pushSource</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::pushDecorators</code>)</li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService::getReceiverStack</code> from <code>$entityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::get</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code>, respective change in its implementing class for <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::get</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::getListByExternalIds</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code>, respective change in its implementing class for <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::getListByExternalIds</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::__construct</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Publisher::publish</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::__construct</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingComponentStructContract::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingComponentStructContract::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingStruct::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingStruct::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::setDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::setEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::getForeignDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::getForeignEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::setForeignDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::setForeignEntityType</code></li> <li>Add dependency onto <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> for job tracking</li> <li>Add dependency onto <code>\\Psr\\Cache\\CacheItemPoolInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code> for configuration caching</li> <li>Remove parameter <code>$mappingService</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContextFactory::__construct</code> as it is no longer needed</li> <li>Add parameter <code>$postProcessors</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContextFactory::__construct</code> to contain every post-processing handler for this context</li> <li>Change <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::markAsFailed</code> to add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\PostProcessing\\MarkAsFailedData</code> to the post-processing data bag instead of directly passing to <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::addException</code></li> <li>Remove parameter <code>$mappingPersister</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor::__construct</code> as its usage has been moved into <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code></li> <li>Move of saving mappings from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor::performReception</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor::handle</code></li> <li>Add dependency onto <code>\\Psr\\Log\\LoggerInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code> for logging filename conversions</li> <li>Change dependency in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmissionActor</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code> into <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code> for more performant route lookup</li> <li>Change dependency in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract</code> into <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> for more performant route reading</li> <li>Allow <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface::triggerReception</code> to throw <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Exception\\ReceptionJobHandlingException</code></li> <li>Add dependency onto <code>\\Psr\\Log\\LoggerInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> for logging exceptions</li> <li>Add dependency onto <code>\\Psr\\Log\\LoggerInterface</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\SaveMappingsPostProcessor</code> for logging unclearmapping scenarios</li> </ul>"},{"location":"releases/changelog-core/#deprecated_2","title":"Deprecated","text":"<ul> <li>Move <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer::STORAGE_LOCATION</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\StreamPathContract::STORAGE_LOCATION</code></li> </ul>"},{"location":"releases/changelog-core/#removed_2","title":"Removed","text":"<ul> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\Contract\\UrlProviderInterface</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookContext</code> in favour of <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContext</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookContextFactory</code> in favour of <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContextFactory</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookService</code></li> <li>Remove interface <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::ensurePersistence</code> and implementation <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingService::ensurePersistence</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code></li> </ul>"},{"location":"releases/changelog-core/#fixed_15","title":"Fixed","text":"<ul> <li>Provide callback-function to \\array_filter in <code>Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\DirectEmissionFlow::run</code> to only filter out primary keys with null and not 0</li> <li><code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamDenormalizer</code> rejects null and empty string as data</li> <li>Usage of <code>\\Ramsey\\Uuid\\Uuid</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\StreamNormalizer</code> only supported <code>ramsey/uuid: 3</code> but composer configuration allowed installation of <code>ramsey/uuid: 4</code>. Now it is used cross-compatible to work with <code>ramsey/uuid: 3 || 4</code></li> <li><code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService::setPortalNodeConfiguration</code> removes nested <code>null</code> values and does not store <code>null</code> anymore</li> <li>Fix automatic prototyping when a portal provides an interface in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\RemoveAutoPrototypedDefinitionsCompilerPass::isPrototypable</code></li> </ul>"},{"location":"releases/changelog-core/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-core/#added_9","title":"Added","text":"<ul> <li>Change implementation for <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code> to allow PSR simple cache compatibility</li> <li>Add log messages codes <code>1631387202</code>, <code>1631387363</code>, <code>1631387430</code>, <code>1631387448</code>, <code>1631387470</code>, <code>1631387510</code>, <code>1631561839</code>, <code>1631562097</code>, <code>1631562285</code>, <code>1631562928</code>, <code>1631563058</code>, <code>1631563639</code>, <code>1631563699</code>, <code>1631565257</code>, <code>1631565376</code>, <code>1631565446</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveContextFactoryInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContextFactory</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ExplorationHandlerInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\EmissionHandlerInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitContextFactoryInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContextFactory</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmitter::batch</code> for better performance in direct emissions</li> </ul>"},{"location":"releases/changelog-core/#changed_7","title":"Changed","text":"<ul> <li><code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::get</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::set</code> will now throw exceptions when normalization could not happen</li> <li>Add parameter for <code>\\Psr\\Log\\LoggerInterface</code> dependency in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorageFactory::__construct</code></li> <li>Change type of parameter <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContextFactory</code> to its new interface <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiveContextFactoryInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService::__construct</code></li> <li>Change type of parameter <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler</code> to its new interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\EmissionHandlerInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\DelegatingJobActor::__construct</code></li> <li>Change type of parameter <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> to its new interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ReceptionHandlerInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\DelegatingJobActor::__construct</code></li> <li>Change type of parameter <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code> to its new interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\ExplorationHandlerInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\DelegatingJobActor::__construct</code></li> <li>Change type of parameter <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContextFactory</code> to its new interface <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitContextFactoryInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitService::__construct</code></li> <li>Change behavior of service <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\DirectEmissionFlow</code> to not create mappings anymore</li> <li>Remove parameter <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\DirectEmissionFlow::__construct</code></li> <li>Change method <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor::saveMappings</code> to use new service <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code></li> <li><code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::pushSource</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::pushDecorators</code> don't push explorers onto the stack when they are already in the stack</li> <li><code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::pushSource</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::pushDecorators</code> don't push emitters onto the stack when they already in the stack</li> <li><code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::pushSource</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::pushDecorators</code> don't push receivers onto the stack when they already in the stack</li> </ul>"},{"location":"releases/changelog-core/#removed_3","title":"Removed","text":"<ul> <li>Remove method <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmitter::run</code> as it became obsolete</li> </ul>"},{"location":"releases/changelog-core/#060-2021-07-26","title":"[0.6.0] - 2021-07-26","text":""},{"location":"releases/changelog-core/#added_10","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExploreServiceInterface::dispatchExploreJob</code> to start an exploration as a job via <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\JobDispatcherContract::dispatch</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code> to handle exploration jobs <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Type\\Exploration</code></li> <li>Add support for handling exploration jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\DelegatingJobActor</code> with using <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ExplorationHandler</code></li> <li>Add <code>\\Psr\\Http\\Message\\ResponseFactoryInterface</code> service to the portal containers in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code> for better HTTP and messaging PSR support for portal developers</li> <li>Add <code>\\Psr\\Http\\Message\\StreamFactoryInterface</code> service to the portal containers in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder</code> for better HTTP and messaging PSR support for portal developers</li> </ul>"},{"location":"releases/changelog-core/#changed_8","title":"Changed","text":"<ul> <li>Direct emission and explorations create mappings via <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\Contract\\MappingServiceInterface::getListByExternalIds</code> on <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface::performExploration</code> when implemented by <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor::performExploration</code></li> </ul>"},{"location":"releases/changelog-core/#051-2021-07-13","title":"[0.5.1] - 2021-07-13","text":""},{"location":"releases/changelog-core/#fixed_16","title":"Fixed","text":"<ul> <li>Remove impact of entity primary keys on lock keys in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code></li> </ul>"},{"location":"releases/changelog-core/#050-2021-07-11","title":"[0.5.0] - 2021-07-11","text":""},{"location":"releases/changelog-core/#added_11","title":"Added","text":"<ul> <li>Add composer dependency <code>symfony/yaml: ^4.4|^5.0</code></li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionFlowContract</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow</code> to expose service for portals</li> <li>Add classes to hold job data for batch processing <code>\\Heptacom\\HeptaConnect\\Core\\Job\\JobData</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Job\\JobDataCollection</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalLogger</code> that can decorate any <code>\\Psr\\Log\\LoggerInterface</code> to apply any additional message prefix and context to all logs</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface</code> to portal node service container</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionFlowContract</code> to portal node service container</li> </ul>"},{"location":"releases/changelog-core/#changed_9","title":"Changed","text":"<ul> <li>The acting to jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\DelegatingJobActorContract::performJob</code> will now happen in batches in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Contract\\DelegatingJobActorContract::performJobs</code> and expects different parameters</li> <li>The trigger on emission jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler::triggerEmission</code> will now happen in batches and expects different parameters</li> <li>The trigger on reception jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> will now happen in batches and expects different parameters</li> <li>Change signature of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionActorInterface::performReception</code> to not rely on previously entities bound to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface</code> objects</li> <li>Change signature of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::markAsFailed</code> to not rely on previously entities bound to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface</code> objects</li> <li>Do most of the business logic for reception in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler</code> to have job related logic less bound to reception processes in general</li> </ul>"},{"location":"releases/changelog-core/#deprecated_3","title":"Deprecated","text":"<ul> <li>Deprecate cronjobs and therefore mark <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Cronjob\\CronjobService</code> as internal</li> <li>Deprecate webhooks and therefore mark <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookContext</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookContextFactory</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\WebhookService</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Webhook\\Contact\\UrlProviderInterface</code> as internal</li> </ul>"},{"location":"releases/changelog-core/#removed_4","title":"Removed","text":"<ul> <li>Move <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\DirectEmissionResult</code> into the portal base package as <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionResult</code></li> <li>Move <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\Exception\\UnidentifiedEntityException</code> into the portal base package as <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\Exception\\UnidentifiedEntityException</code></li> <li>The handling of jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\MessageQueueFlow\\MessageHandler::handleJob</code> does not republish failed jobs anymore. That feature will be added back again in a different form</li> <li>The trigger on emission jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\EmissionHandler::triggerEmission</code> will no longer report back success</li> <li>The trigger on reception jobs in <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Handler\\ReceptionHandler::triggerReception</code> will no longer report back success</li> <li>Remove automatically registered services in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\RemoveAutoPrototypedDefinitionsCompilerPass</code> that is based on <code>\\Throwable</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachableInterface</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract</code></li> </ul>"},{"location":"releases/changelog-dataset-base/","title":"Dataset Base Changelog","text":""},{"location":"releases/changelog-dataset-base/#0940-2023-03-04","title":"[0.9.4.0] - 2023-03-04","text":""},{"location":"releases/changelog-dataset-base/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecate and discourage usage of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DeferralAwareInterface</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\DeferralAwareTrait</code> as it has not been a practical solution to defer closure execution in a different process</li> </ul>"},{"location":"releases/changelog-dataset-base/#0911-2022-09-28","title":"[0.9.1.1] - 2022-09-28","text":""},{"location":"releases/changelog-dataset-base/#added","title":"Added","text":"<ul> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::withoutItems</code> to create safely new instances of the same type but without content</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::chunk</code> to iterate over the items prepared in a buffer of a certain size</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::asArray</code> to access the items of the collection as fixed size array</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::reverse</code> to reverse the order of the collection items</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::isEmpty</code> to check whether the collection is empty without counting</li> <li>Add aggregation methods <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\FloatCollection::sum</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\FloatCollection::max</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\FloatCollection::min</code> to reduce boilerplate code when aggregating a float collection</li> <li>Add aggregation methods <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\IntegerCollection::sum</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\IntegerCollection::max</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\IntegerCollection::min</code> to reduce boilerplate code when aggregating an integer collection</li> </ul>"},{"location":"releases/changelog-dataset-base/#0910-2022-08-15","title":"[0.9.1.0] - 2022-08-15","text":""},{"location":"releases/changelog-dataset-base/#added_1","title":"Added","text":"<ul> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\StringCollection::join</code> to implode strings</li> </ul>"},{"location":"releases/changelog-dataset-base/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-dataset-base/#added_2","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::isAttached</code> to check for a specific instance of an object in the attachment list</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::detach</code> to remove a specific instance from the attachment list</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface</code> to match the trait <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait</code> and add it to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code> as a base class for various file reference implementations</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceCollection</code> as a collection for <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code></li> </ul>"},{"location":"releases/changelog-dataset-base/#changed","title":"Changed","text":"<ul> <li>Implement possible usage of interface FQCNs as parameter in the methods <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::hasAttached</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::getAttachment</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::detachByType</code></li> <li>Set <code>array-key</code> type on iterating over collections that implement the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface</code> to <code>int</code> as they only accept iterables keyed by <code>int</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\BooleanCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\DateCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\DateTimeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\FloatCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\IntegerCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\StringCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TaggedBooleanCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TaggedDateCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TaggedDateTimeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TaggedFloatCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TaggedIntegerCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TaggedStringCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TaggedCollection\\TagItem</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableBooleanCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableDateCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableDateTimeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableFloatCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableIntegerCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableStringCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableBoolean</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableDate</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableDateTime</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableFloat</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableInteger</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\TranslatableString</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentCollection</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Date</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Dependency</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\DependencyCollection</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection</code> to ensure correct usage of implementation. Decoration by their interfaces or base classes is still possible</li> </ul>"},{"location":"releases/changelog-dataset-base/#deprecated_1","title":"Deprecated","text":"<ul> <li>Copy and deprecate <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::unattach</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::detachByType</code> for correct usage of English language and distinguish from <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::detach</code></li> </ul>"},{"location":"releases/changelog-dataset-base/#085-2021-12-28","title":"[0.8.5] - 2021-12-28","text":""},{"location":"releases/changelog-dataset-base/#fixed","title":"Fixed","text":"<ul> <li>Change composer dependency <code>bentools/iterable-functions: &gt;=1 &lt;2</code> to <code>bentools/iterable-functions: &gt;=1.4 &lt;2</code> to ensure availability of <code>iterable_map</code></li> </ul>"},{"location":"releases/changelog-dataset-base/#084-2021-12-16","title":"[0.8.4] - 2021-12-16","text":""},{"location":"releases/changelog-dataset-base/#removed","title":"Removed","text":"<ul> <li>Remove the code for unit tests, configuration for style checks as well as the Makefile</li> </ul>"},{"location":"releases/changelog-dataset-base/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-dataset-base/#changed_1","title":"Changed","text":"<ul> <li>Change composer dependency <code>bentools/iterable-functions: &gt;=1</code> to <code>bentools/iterable-functions: &gt;=1 &lt;2</code></li> <li>Change method name of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ForeignKeyAwareInterface::getForeignDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ForeignKeyAwareInterface::getForeignEntityType</code></li> </ul>"},{"location":"releases/changelog-dataset-base/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-dataset-base/#changed_2","title":"Changed","text":"<ul> <li>Amend typehint for <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::push</code> to improve static code analysis.</li> </ul>"},{"location":"releases/changelog-dataset-base/#fixed_1","title":"Fixed","text":"<ul> <li>Change signature <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection::__construct</code> to allow iterables instead of array like other collections</li> </ul>"},{"location":"releases/changelog-dataset-base/#060-2021-07-26","title":"[0.6.0] - 2021-07-26","text":""},{"location":"releases/changelog-dataset-base/#added_3","title":"Added","text":"<ul> <li>New method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::column</code> to improve common cases from <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::map</code> usage</li> </ul>"},{"location":"releases/changelog-dataset-base/#changed_3","title":"Changed","text":"<ul> <li>Amend <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::map</code> typehint for callables to improve static code analysis</li> </ul>"},{"location":"releases/changelog-dataset-base/#050-2021-07-11","title":"[0.5.0] - 2021-07-11","text":""},{"location":"releases/changelog-dataset-base/#added_4","title":"Added","text":"<ul> <li>New composer dependency <code>opis/closure: ^3.6</code> to allow serialization of closures</li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection</code> to have a dataset entity collection that ensures to contain a single type only to improve common case <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::filter</code></li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\AbstractTranslatableScalarCollection</code> to allow translations of any collections</li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableBooleanCollection</code> to allow translations of type <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\BooleanCollection</code></li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableDateCollection</code> to allow translations of type <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\DateCollection</code></li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableDateTimeCollection</code> to allow translations of type <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\DateTimeCollection</code></li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableFloatCollection</code> to allow translations of type <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\FloatCollection</code></li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableIntegerCollection</code> to allow translations of type <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\IntegerCollection</code></li> <li>New class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\ScalarCollection\\TranslatableStringCollection</code> to allow translations of type <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\StringCollection</code></li> <li>New method in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DeferralAwareInterface::copyDeferrals</code> to copy deferrals from one deferral aware to another one</li> <li>New default implementation of method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DeferralAwareInterface::copyDeferrals</code> in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\DeferralAwareTrait</code></li> </ul>"},{"location":"releases/changelog-dataset-base/#changed_4","title":"Changed","text":"<ul> <li>Rename <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\GenericTranslatable</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\AbstractTranslatable</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DeferralAwareInterface</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract</code></li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/","title":"Dataset Ecommerce Changelog","text":""},{"location":"releases/changelog-dataset-ecommerce/#0920-2023-03-24","title":"[0.9.2.0] - 2023-03-24","text":""},{"location":"releases/changelog-dataset-ecommerce/#added","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentState::STATE_PARTIALLY_SHIPPED</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentState::STATE_PARTIALLY_RETURNED</code></li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#0910-2022-09-21","title":"[0.9.1.0] - 2022-09-21","text":""},{"location":"releases/changelog-dataset-ecommerce/#added_1","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentState</code> with the states unknown, open, cancelled, returned and shipped</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\Shipment</code> entity with <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentCollection</code> to group shipment related information like address, tracking code, state and method</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentAwareInterface</code> to describe entities related to shipments</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentAwareTrait</code> as supporting implementation for every entity implementing <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentAwareInterface</code></li> <li>Make <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Shipping</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Product</code> aware of their related shipments by implementing <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentAwareInterface</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::aggregateShipments</code> to collect shipment information from all line items</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Transaction</code> entity with <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\TransactionCollection</code> to hold payment transaction related data with optional relation to line items to allow payments without context</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Credit</code> entity based on <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Transaction</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Payment</code> entity based on <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Transaction</code></li> <li>Add property <code>manufacturerNumber</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product</code> to store manufacturer numbers</li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#changed","title":"Changed","text":"<ul> <li>Extract <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Transaction</code> entity from <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Refund</code> to represent any type of payment</li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#deprecated","title":"Deprecated","text":"<ul> <li>Add deprecation warnings to usage of <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::$deliveryTrackingCode</code> in <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getDeliveryTrackingCode</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::setDeliveryTrackingCode</code>. Use <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::aggregateShipments</code> with <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\Shipment</code> and implementations of <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Shipment\\ShipmentAwareInterface</code> instead</li> <li>Add deprecation warnings to usage of the payment related properties <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::$paymentState</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::$paymentTransactionCode</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::$paymentMethod</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::$refund</code> in <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getPaymentState</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::setPaymentState</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getPaymentTransactionCode</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::setPaymentTransactionCode</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getPaymentMethod</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::setPaymentMethod</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::isRefunded</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getRefund</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::setRefund</code>. Use <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getTransactions</code> with implementations of <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Transaction</code> instead</li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-dataset-ecommerce/#added_2","title":"Added","text":"<ul> <li>Add property medias to <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product</code> as <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\MediaCollection</code></li> <li>Use <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code> in <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media</code> to normalize file usage in media transfer</li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#removed","title":"Removed","text":"<ul> <li>Replace <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media::getNormalizedStream</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media::setNormalizedStream</code> with <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media::getFile</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media::setFile</code>. To migrate stop job dispatching processes and process all jobs to prevent deserialization issue</li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#083-2022-02-16","title":"[0.8.3] - 2022-02-16","text":""},{"location":"releases/changelog-dataset-ecommerce/#added_3","title":"Added","text":"<ul> <li>Add property to <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Refund</code> to flag refund as partial or full refund</li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#fixed","title":"Fixed","text":"<ul> <li>Add missing import of parent class for <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Refund</code></li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#082-2022-02-15","title":"[0.8.2] - 2022-02-15","text":""},{"location":"releases/changelog-dataset-ecommerce/#added_4","title":"Added","text":"<ul> <li>Add new entity <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Refund</code> to hold refund information</li> <li>Add new property for refunds to <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order</code>. New methods: <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::isRefunded</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::getRefund</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\Order::setRefund</code></li> </ul>"},{"location":"releases/changelog-dataset-ecommerce/#081-2022-01-08","title":"[0.8.1] - 2022-01-08","text":""},{"location":"releases/changelog-dataset-ecommerce/#added_5","title":"Added","text":"<ul> <li>Add new property for percentage information to discount line-item. New methods: <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Discount::isAbsolute</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Discount::getPercentage</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Discount::setPercentage</code></li> <li>Add new property for relation to affected line-items to discount line-item. New methods: <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Discount::getRelatedLineItems</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Order\\LineItem\\Discount::setRelatedLineItems</code></li> </ul>"},{"location":"releases/changelog-package-http/","title":"Package HTTP Changelog","text":""},{"location":"releases/changelog-package-http/#110-2023-09-02","title":"[1.1.0] - 2023-09-02","text":""},{"location":"releases/changelog-package-http/#added","title":"Added","text":"<ul> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleModifierInterface</code> to build components, that will be used to modify recorded HTTP request cycles</li> <li>Add methods <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleCollector::withAddedModifier</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleCollector::withoutModifiers</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleCollector::getModifiers</code> to manage <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleModifierInterface</code> that will be applied when collecting request cycles</li> <li>Add request cycle modifier class <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\HeaderValueReplacingModifier</code> to replace header values using RegEx patterns</li> <li>Add request cycle modifier class <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\RequestUrlModifier</code> to replace request URL parts using RegEx patterns</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\AbstractBodyModifier</code> to build modifiers depending on the body's mimetype</li> <li>Add request cycle modifier class <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\JsonBodyFormattingModifier</code> to format request and response bodies that are of mimetype <code>application/json</code></li> <li>Add request cycle modifier class <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\XmlBodyFormattingModifier</code> to format request and response bodies that are of mimetype <code>application/xml</code></li> <li>Add composer suggestion to allow <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\XmlBodyFormattingModifier</code> to work</li> </ul>"},{"location":"releases/changelog-package-http/#changed","title":"Changed","text":"<ul> <li>Prevent request URL modification in <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\HttpRequestCycleProfiler</code>, when collector has modifiers assigned</li> </ul>"},{"location":"releases/changelog-package-http/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecate expected request URL modification in <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\HttpRequestCycleProfiler</code>. Expect to always add <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Modifier\\RequestUrlModifier</code> to collectors</li> </ul>"},{"location":"releases/changelog-package-http/#100-2023-06-10","title":"[1.0.0] - 2023-06-10","text":""},{"location":"releases/changelog-package-http/#added_1","title":"Added","text":"<ul> <li>Add composer dependency <code>heptacom/heptaconnect-portal-base: ^0.9.5</code> as <code>\\Heptacom\\HeptaConnect\\Package\\Http\\HttpPackage</code> is a package and HTTP middleware <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface</code> is used</li> <li>Add composer dependencies <code>psr/http-client: ^1.0</code>, <code>psr/http-factory: ^1.0</code> and <code>psr/http-message: ^1.0 || ^2.0</code> as PSR-7 based HTTP messages are used</li> <li>Add composer dependencies <code>psr/event-dispatcher: ^1.0</code>, <code>symfony/event-dispatcher: ^5.0 || ^6.0</code> and <code>symfony/event-dispatcher-contracts: ^2.0 || ^3.0</code> as events are dispatched</li> <li>Add composer dependency <code>symfony/dependency-injection: ^5.0 || ^6.0</code> as compiler passes are used</li> <li>Add composer dependency <code>symfony/options-resolver: ^5.1 || ^6.0</code> as unstructured data is validated using the Symfony options resolver</li> <li>Introduce outbound HTTP cache feature using <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\HttpCache</code> based on <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\Contract\\HttpCacheInterface</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\Psr7MessageSerializer</code> described by <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\Contract\\Psr7MessageSerializerInterface</code> to serialize and deserialize PSR-7 messages for storing them in a cache</li> <li>Add event <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\Contract\\Event\\HttpCacheActiveEvent</code> to influence, whether a request cycle is cached</li> <li>Add event <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\Contract\\Event\\HttpCacheKeyEvent</code> to influence under which cache key a request is cached</li> <li>Add service tag <code>heptaconnect.http.client.middleware</code> to <code>Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpCache\\Contract\\HttpCacheInterface</code> to ensure it is chained in outgoing HTTP communication</li> <li>Introduce HTTP request cycle profiling using <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\HttpRequestCycleProfiler</code> based on <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleProfilerInterface</code> to control, which outgoing request cycles shall be measured and how the measurements will be processed</li> <li>Add struct <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycleCollector</code> to store <code>\\Heptacom\\HeptaConnect\\Package\\Http\\Components\\HttpRequestCycleProfiling\\Contract\\HttpRequestCycle</code> for each request in a request cycle measurement</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Package\\Http\\DependencyInjection\\EventSubscriberTagCompilerPass</code> as class and into the container building to register any <code>\\Symfony\\Component\\EventDispatcher\\EventSubscriberInterface</code> as active subscriber</li> <li>Add service <code>Symfony\\Component\\EventDispatcher\\EventDispatcherInterface</code> for class <code>\\Symfony\\Component\\EventDispatcher\\EventDispatcher</code> with aliases <code>event_dispatcher</code>, <code>Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface</code> and <code>Psr\\EventDispatcher\\EventDispatcherInterface</code></li> </ul>"},{"location":"releases/changelog-package-shopware-6/","title":"Package Shopware 6 Changelog","text":""},{"location":"releases/changelog-package-web-frontend/","title":"Package Web Frontend Changelog","text":""},{"location":"releases/changelog-package-web-frontend/#102-2024-01-05","title":"[1.0.2] - 2024-01-05","text":""},{"location":"releases/changelog-package-web-frontend/#fixed","title":"Fixed","text":"<ul> <li>Fix path generation for cookies in <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\SessionManager::alterResponse</code></li> </ul>"},{"location":"releases/changelog-package-web-frontend/#101-2023-11-22","title":"[1.0.1] - 2023-11-22","text":""},{"location":"releases/changelog-package-web-frontend/#fixed_1","title":"Fixed","text":"<ul> <li>Fix login when no session was started yet</li> </ul>"},{"location":"releases/changelog-package-web-frontend/#100-2023-07-10","title":"[1.0.0] - 2023-07-10","text":""},{"location":"releases/changelog-package-web-frontend/#added","title":"Added","text":"<ul> <li>Require <code>php: &gt;=8.0</code></li> <li>Add composer dependency <code>ext-filter: *</code> to validate user input in PHP ini settings</li> <li>Add composer dependency <code>symfony/dependency-injection: ^5.0 || ^6.0</code> and <code>symfony/config: ^5.0 || ^6.0</code> as compiler passes, services.xml files and extensions are used</li> <li>Add composer dependency <code>heptacom/heptaconnect-portal-base: ^0.9.6</code> as <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\WebFrontendPackage</code> is a package and different flow components are provided</li> <li>Add HEPTAconnect package class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\WebFrontendPackage</code></li> <li>Add composer dependency <code>symfony/error-handler: ^5.0 || ^6.0</code> to provide human readable error pages</li> <li>Add composer dependencies <code>psr/http-factory: ^1.0</code>, <code>psr/http-message: ^1.0 || ^2.0</code>, <code>psr/http-server-handler: ^1.0</code> and <code>psr/http-server-middleware: ^1.0</code> as PSR-7 server requests are processed and responded</li> <li>Add HTTP middleware service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\ErrorHandler\\HttpErrorHandlerMiddleware</code> with positive priority to catch exception as early as possible and render them as HTML</li> <li>Add composer dependency <code>heptacom/heptaconnect-dataset-base: ^0.9</code> to use collections and attachable structures</li> <li>Add collection service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Notification\\NotificationBag</code> holding <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Notification\\Notification</code> for rendering use</li> <li>Add composer dependency <code>ext-mbstring: *</code> to work with multibyte strings</li> <li>Add composer dependencies <code>twig/twig: ^3.0</code> and <code>twig/string-extra: ^3.0</code> to make use of the Twig templating engine</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\Contract\\TemplateFinderInterface</code> implemented by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\TemplateFinder</code> to find the next matching template to render in the next step</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\TokenParserDecorator</code> to reuse existing token parser under a different name</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\ExtendsTokenParser</code> as theme-aware implementation for Twig tag <code>extends</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\IncludeTokenParser</code> and <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\InheritedInclude</code> as theme-aware implementation for Twig tag <code>include</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Hierarchy\\NodeExtension</code> as Twig extension to provide theme-awareness to Twig</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Contract\\ThemeInterface</code> to identify themes and collect them in collection service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Contract\\ThemeCollection</code></li> <li>Add trait <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Utility\\ThemePackageTrait</code> to implement <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Contract\\ThemeInterface</code> for any <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code> without any further code</li> <li>Add compiler pass <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\TemplateTagCompilerPass</code> to collect themes and bring them in order</li> <li>Add compiler pass <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\TwigExtensionTagCompilerPass</code> to collect all Twig extensions</li> <li>Add compiler pass <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\RegisterSuggestedTwigExtensionsCompilerPass</code> to use the Twig Intl extension, when installed</li> <li>Add HTTP middleware service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\AssetMiddleware</code> to serve any given path to an asset optimized for web browser caching</li> <li>Add Twig test <code>instanceof</code> with <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Extension\\InstanceOfExtension</code> to allow for variable checks to be a certain type</li> <li>Add Twig test <code>numeric</code> with <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Extension\\IsNumericExtension</code></li> <li>Add Twig filter <code>urldecode</code> with <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Extension\\UrlDecodeExtension</code> as counterpart to <code>urlencode</code></li> <li>Add composer dependency <code>bentools/iterable-functions: &gt;=1.4 &lt;2</code> to simplify working with iterables</li> <li>Add factory service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Contract\\TwigEnvironmentFactoryInterface</code> implemented by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\TwigEnvironmentFactory</code> to build common Twig environment instances</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\AbstractFeature</code> for Symfony extensions, that are used to group code into features</li> <li>Add compiler pass <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\ProvideContainerParameterForTwigEnvironmentCompilerPass</code> to pass feature configurations into the Twig template</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\Debug\\DebugTwigEnvironmentFactory</code> decorating <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Contract\\TwigEnvironmentFactoryInterface</code> to enable debugging features</li> <li>Add flow component <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\Debug\\DebugThemeStatusReporter</code> to debug theme functionalities</li> <li>Add feature class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\DebugFeature</code> to control template debugging</li> <li>Add Symfony extension <code>web_frontend_template_debug</code> configuration <code>enabled</code> to enable template debugging</li> <li>Add Symfony extension <code>web_frontend_template_debug</code> configuration <code>html_error_renderer</code> to fully render exceptions</li> <li>Add Twig cache implementation <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\Cache\\TwigCache</code>, that works different with temporary files</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\Cache\\CachePath</code> to handle Twig cache access</li> <li>Add flow component <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\Cache\\CacheClearCommand</code> to clear Twig cache</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\Cache\\CachedTwigEnvironmentFactory</code> decorating <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Contract\\TwigEnvironmentFactoryInterface</code> to enable caching features</li> <li>Add feature class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\Feature\\CacheFeature</code> to control template caching</li> <li>Add Symfony extension <code>web_frontend_template_cache</code> configuration <code>enabled</code> to enable template caching</li> <li>Add theme <code>WebFrontendPackage</code> by class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\BootstrapTheme\\BootstrapTheme</code></li> <li>Add editor theme component in <code>@WebFrontendPackage/ui/_base/component/editor.html.twig</code>, <code>@WebFrontendPackage/ui/_base/js/editor.js</code> and <code>@WebFrontendPackage/ui/_base/css/editor.css</code> to have simplified code editor</li> <li>Add notification theme component in <code>@WebFrontendPackage/ui/_base/component/notifications.html.twig</code> and <code>@WebFrontendPackage/ui/_base/js/notifications.js</code> to display notifications with Bootstrap toasts</li> <li>Add sidebar theme component in <code>@WebFrontendPackage/ui/_base/component/sidebar.html.twig</code>, <code>@WebFrontendPackage/ui/_base/js/sidebar.js</code> and <code>@WebFrontendPackage/ui/_base/css/sidebar.css</code> divided into <code>@WebFrontendPackage/ui/component/sidebar/header.html.twig</code> and <code>@WebFrontendPackage/ui/component/sidebar/scrollable-content.html.twig</code> of <code>@WebFrontendPackage/ui/component/sidebar/item.html.twig</code> for sidebar menu items</li> <li>Add dark mode appearance in <code>@WebFrontendPackage/ui/_base/js/appearance.js</code></li> <li>Add left-sidebar page layout in <code>@WebFrontendPackage/ui/_base/layout.html.twig</code></li> <li>Add HEPTAconnect icon asset in <code>src/Components/BootstrapTheme/Resources/public/icon/heptaconnect-logo.png</code></li> <li>Add feature class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\BootstrapThemeFeature</code> to control the Bootstrap 5 theme</li> <li>Add Symfony extension <code>web_frontend_bootstrap_theme</code> configuration <code>enabled</code> to enable the Bootstrap 5 theme</li> <li>Add composer dependency <code>psr/simple-cache\": \"^1.0</code> to use cache storages for sessions</li> <li>Add session storage class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\Session</code> described by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\Contract\\SessionInterface</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\SessionManager</code> described by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\Contract\\SessionManagerInterface</code> to store sessions and access them from requests</li> <li>Add HTTP middleware service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\SessionMiddleware</code> with a lower priority than <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Template\\AssetMiddleware</code> to ensure assets are not slowed by attaching and storing sessions for every request</li> <li>Add feature class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\SessionFeature</code> to control the session handling</li> <li>Add Symfony extension <code>web_frontend_session</code> configuration <code>enabled</code> to enable cookie-driven session management</li> <li>Add Symfony extension <code>web_frontend_session</code> configuration <code>session_lifetime</code> to defines for how long a session should be stored</li> <li>Add Symfony extension <code>web_frontend_session</code> configuration <code>cookie_name</code> to set the name of the cookie used for storing the session in a request and response</li> <li>Add Symfony extension <code>web_frontend_session</code> configuration <code>cache_key_prefix</code> to set the prefix of the cache storage used for the sessions</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\AbstractPage</code> to identify page structure classes</li> <li>Add compiler pass <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\RemovePagesCompilerPass</code> to remove any services, that might accidentally be picked up as service, but are a page structure object</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\WebPageTwigEnvironmentFactoryInterface</code> implemented by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\WebPageTwigEnvironmentFactory</code> to generate Twig environments to render HTML pages</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\WebPageRendererInterface</code> implemented by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\WebPageRenderer</code> to render any <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\AbstractPage</code> in a request</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\UiHandlerContract</code> for HTTP handlers, that work with <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\AbstractPage</code></li> <li>Add compiler pass <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\DependencyInjection\\ControllerPreparationCompilerPass</code> to automatically tag services of <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\Contract\\UiHandlerContract</code></li> <li>Add fallback page <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\DefaultPage\\DefaultPage</code> with template <code>@WebFrontendPackage/ui/page/index/index.html.twig</code> handled by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Page\\DefaultPage\\DefaultUiHandler</code> to always have page to show</li> <li>Add feature class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\PageFeature</code> to control page handling</li> <li>Add Symfony extension <code>web_frontend_page</code> configuration <code>enabled</code> to enable page rendering service</li> <li>Add Symfony extension <code>web_frontend_page</code> configuration <code>default_page_enabled</code> to enables the fallback page</li> <li>Add Symfony extension <code>web_frontend_page</code> configuration <code>default_page_path</code> to set the fallback page path</li> <li>Add HTTP handler <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\LoginHandler</code> to render and and perform a login</li> <li>Add HTTP handler <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\LogoutHandler</code> to perform a logout</li> <li>Add status reporter <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\AccessLoginCommand</code> to create root access login links</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\Contract\\AccessProtectionServiceInterface</code> implemented by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\AccessProtectionService</code> to generate root login links</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\Contract\\AuthorizationBackendInterface</code> implemented by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\AuthorizationBackend</code> to manage <code>htpasswd</code>-alike file as user directory</li> <li>Add HTTP middleware service <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\AccessProtectionMiddleware</code> with a lower priority than <code>Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\Session\\SessionMiddleware</code> to ensure sessions to access data are available to verify and assign login data</li> <li>Add lockscreen page <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\LockscreenPage</code> with template <code>@WebFrontendPackage/ui/page/lockscreen/index.html.twig</code> with custom style in <code>@WebFrontendPackage/ui/page/lockscreen/css/lockscreen.css</code> handled by <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtection\\LockscreenUiHandler</code></li> <li>Add feature class <code>\\Heptacom\\HeptaConnect\\Package\\WebFrontend\\Components\\AccessProtectionFeature</code> to control page access protection</li> <li>Add Symfony extension <code>web_frontend_access_protection</code> configuration <code>after_login_page_path</code> to set the path to the page, that will be redirected to after a login</li> <li>Add Symfony extension <code>web_frontend_access_protection</code> configuration <code>login_page_path</code> to set the path to the login form page</li> <li>Add Symfony extension <code>web_frontend_access_protection</code> configuration <code>login_path</code> to set the path to the login action</li> <li>Add Symfony extension <code>web_frontend_access_protection</code> configuration <code>logout_path</code> to set the path to the logout action</li> </ul>"},{"location":"releases/changelog-portal-base/","title":"Portal Base Changelog","text":""},{"location":"releases/changelog-portal-base/#0970-2024-02-10","title":"[0.9.7.0] - 2024-02-10","text":""},{"location":"releases/changelog-portal-base/#added","title":"Added","text":"<ul> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\EmitterBuilder::priority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\ExplorerBuilder::priority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\HttpHandlerBuilder::priority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\ReceiverBuilder::priority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\StatusReporterBuilder::priority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getPriority</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::setPriority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::getPriority</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::setPriority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\HttpHandlerToken::getPriority</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\HttpHandlerToken::setPriority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::getPriority</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::setPriority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\StatusReporterToken::getPriority</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\StatusReporterToken::setPriority</code> to sort flow component within the stack</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::setDefaultPriority</code> to set default position for flow components within the stack per source package</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::getDefaultFlowComponentPriority</code> to set default position for flow components within the stack per source package</li> </ul>"},{"location":"releases/changelog-portal-base/#changed","title":"Changed","text":"<ul> <li>Change <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract::iterate</code> to resolve nested iterables deferred instead of in the moment they are found to lower memory peaks during larger object inspection</li> </ul>"},{"location":"releases/changelog-portal-base/#0960-2023-07-10","title":"[0.9.6.0] - 2023-07-10","text":""},{"location":"releases/changelog-portal-base/#fixed","title":"Fixed","text":"<ul> <li>Fix emission check in implementation of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\EntityStatusContract::isMappedByEmitter</code></li> </ul>"},{"location":"releases/changelog-portal-base/#0950-2023-05-27","title":"[0.9.5.0] - 2023-05-27","text":""},{"location":"releases/changelog-portal-base/#added_1","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PackageCollection</code> as collection class for <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code></li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PackageCollection</code> to portal-container, containing the portal, all portal-extensions and all packages involved in building the container</li> <li>Add service <code>Psr\\Http\\Message\\ServerRequestFactoryInterface</code> to portal-container</li> <li>Add service <code>Psr\\Http\\Message\\UploadedFileFactoryInterface</code> to portal-container</li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpKernelInterface</code> to portal-container to execute a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerStackInterface</code> from inside a portal</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandleContextInterface::forward</code> to provide a guided usage of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpKernelInterface</code></li> <li>Add service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageMultiPartFormDataBuilderInterface</code> to build HTTP payloads for multipart messages</li> </ul>"},{"location":"releases/changelog-portal-base/#changed_1","title":"Changed","text":"<ul> <li>Allow handling of HTTP requests, even when no HTTP handler exists for the requested path. This means, middlewares for HTTP handlers will run for every request.</li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandleContextInterface::REQUEST_ATTRIBUTE_IS_STACK_EMPTY</code> to identify an attribute in <code>\\Psr\\Http\\Message\\ServerRequestInterface</code> objects. This attribute holds a value, that indicates whether the related <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerStackInterface</code> is empty.</li> </ul>"},{"location":"releases/changelog-portal-base/#fixed_1","title":"Fixed","text":"<ul> <li>Remove a step in building a portal-container that would remove all services that extend <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code></li> </ul>"},{"location":"releases/changelog-portal-base/#0940-2023-03-04","title":"[0.9.4.0] - 2023-03-04","text":""},{"location":"releases/changelog-portal-base/#added_2","title":"Added","text":"<ul> <li>Add composer dependency <code>symfony/config: ^4.4 || ^5.0</code> and <code>symfony/dependency-injection: ^4.4 || ^5.0</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code> as base class for additional packages, other than portals and portal extensions</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::buildContainer</code> allowing packages to influence the build-process of the portal-container</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::getAdditionalPackages</code> allowing packages to provide additional packages. These packages may also influence the build-process of the portal-container.</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::registerContainerFile</code> allowing packages to automatically register their service definition files (e. g. <code>Resources/config/services.xml</code>)</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Exception\\DelegatingLoaderLoadException</code> for when a service definition file cannot be loaded</li> <li>Add exception code <code>1674923696</code> for when a service definition file cannot be loaded</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\FlowComponent\\Contract\\FlowComponentStackIdentifierInterface</code> to identify flow component stack identifier and all their commonly shared features</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code> to hold the identifying components of an HTTP handler stack being the portal node key and served path</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\ServerRequestCycle</code> to hold a server request and response, that correspond to a single HTTP request/response cycle</li> <li>Add service of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageCurlShellFormatterContract</code> implementing <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract</code> to format HTTP messages described in PSR-7 into cURL shell commands</li> <li>Add service of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageRawHttpFormatterContract</code> implementing <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\Psr7MessageFormatterContract</code> as default provider to format HTTP messages described in PSR-7 into raw HTTP traffic, that can be used with TCP networking tools</li> </ul>"},{"location":"releases/changelog-portal-base/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecate and discourage usage of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DeferralAwareInterface</code> as it has not been a practical solution to defer closure execution in a different process</li> <li>Deprecate extending method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::__construct</code> as this method will become final in version 0.10</li> </ul>"},{"location":"releases/changelog-portal-base/#0930-2022-11-26","title":"[0.9.3.0] - 2022-11-26","text":""},{"location":"releases/changelog-portal-base/#added_3","title":"Added","text":"<ul> <li>Add service of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> to the portal node container to interact with filesystem abstraction</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Exception\\UnexpectedFormatOfUriException</code> to indicate usage unexpected parameters with <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code></li> </ul>"},{"location":"releases/changelog-portal-base/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecate service <code>League\\Flysystem\\FilesystemInterface</code> in the portal node container. Use <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\Filesystem\\Contract\\FilesystemInterface</code> in combination with native stream functions like <code>fopen</code>, <code>fread</code>, <code>fwrite</code>, <code>fclose</code>, <code>file_get_contents</code> and <code>file_put_contents</code> instead</li> </ul>"},{"location":"releases/changelog-portal-base/#0920-2022-10-16","title":"[0.9.2.0] - 2022-10-16","text":""},{"location":"releases/changelog-portal-base/#added_4","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientMiddlewareInterface</code>. Every service implementing this interface will automatically be tagged with <code>heptaconnect.http.client.middleware</code>. Middlewares will be executed for every outbound HTTP request via the <code>\\Psr\\Http\\Client\\ClientInterface</code>.</li> <li>Add composer dependency <code>psr/http-server-handler: ^1.0</code> and <code>psr/http-server-middleware: ^1.0</code> to support PSR-15 middlewares for HTTP handlers. Every service implementing <code>\\Psr\\Http\\Server\\MiddlewareInterface</code> will automatically be tagged with <code>heptaconnect.http.handler.middleware</code>. Middlewares will be executed for every inbound HTTP request via <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code>.</li> </ul>"},{"location":"releases/changelog-portal-base/#fixed_2","title":"Fixed","text":"<ul> <li>Add composer dependency on <code>psr/http-client: ^1.0</code></li> </ul>"},{"location":"releases/changelog-portal-base/#0910-2022-08-15","title":"[0.9.1.0] - 2022-08-15","text":""},{"location":"releases/changelog-portal-base/#added_5","title":"Added","text":"<ul> <li>Extract similarities of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract</code> into a new common base class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::getContainerExcludedClasses</code> to allow portals and portal extensions to add and remove automatically excluded classes from container auto-prototyping</li> </ul>"},{"location":"releases/changelog-portal-base/#deprecated_2","title":"Deprecated","text":"<ul> <li>Deprecate <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PathMethodsTrait</code> as content will be moved to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code> without replacement trait</li> </ul>"},{"location":"releases/changelog-portal-base/#fixed_3","title":"Fixed","text":"<ul> <li>Change order of stack handling and remove fallback value for the reported topic in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract::report</code></li> </ul>"},{"location":"releases/changelog-portal-base/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-portal-base/#added_6","title":"Added","text":"<ul> <li>Add structure to store code origin data in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\FlowComponent\\CodeOrigin</code></li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\FlowComponent\\Exception\\CodeOriginNotFound</code> to indicate issues when looking for code origins</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getRunMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getOptionsMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getGetMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getPostMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getPatchMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getPutMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler::getDeleteMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerCodeOriginFinderInterface</code> to find code origin of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::getRunMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::getBatchMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::getExtendMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterCodeOriginFinderInterface</code> to find code origin of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Explorer::getRunMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Explorer::getIsAllowedMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerCodeOriginFinderInterface</code> to find code origin of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Receiver::getRunMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Receiver::getBatchMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverCodeOriginFinderInterface</code> to find code origin of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\StatusReporter::getRunMethod</code> to expose configured callback for origin access reading</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterCodeOriginFinderInterface</code> to find code origin of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract</code></li> <li>Add method for portal extensions <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract::isActiveByDefault</code> to allow for default activity state configuration</li> <li>Add supporting filter method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionCollection::bySupport</code> to filter portal extensions by their supported portal class</li> <li>Add new service <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpClientContract</code> to container as an alternative to <code>Psr\\Http\\Client\\ClientInterface</code> with behaviour by configuration with e.g. <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Support\\DefaultRequestHeaders</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract</code> to create instances of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract</code> to resolve instances of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\File\\FileReferenceContract</code> to instances of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\ResolvedFileReferenceContract</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\ResolvedFileReferenceContract</code> to access file references in read operations</li> <li>Add new service <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceFactoryContract</code> to container to create file references from various sources</li> <li>Add new service <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\File\\FileReferenceResolverContract</code> to container to resolve file references for read operations</li> <li>Add methods <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface::withAlias</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\PortalNodeKeyInterface::withoutAlias</code> to flag a portal node key to prefer the display as alias or storage key</li> <li>Make <code>$this</code> available in closures for short-notation flow-components with <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent</code></li> </ul>"},{"location":"releases/changelog-portal-base/#changed_2","title":"Changed","text":"<ul> <li>Use container tags <code>heptaconnect.flow_component.status_reporter_source</code>, <code>heptaconnect.flow_component.emitter_source</code>, <code>heptaconnect.flow_component.explorer_source</code>, <code>heptaconnect.flow_component.receiver_source</code>, <code>heptaconnect.flow_component.web_http_handler_source</code> instead of <code>heptaconnect.flow_component.emitter</code>, <code>heptaconnect.flow_component.emitter_decorator</code>, <code>heptaconnect.flow_component.explorer</code>, <code>heptaconnect.flow_component.explorer_decorator</code>, <code>heptaconnect.flow_component.receiver</code>, <code>heptaconnect.flow_component.receiver_decorator</code> and <code>heptaconnect.flow_component.web_http_handler</code> to collect flow component services</li> <li>Short-noted flow components load on first flow component usage instead on container building</li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack::next</code></li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerStack::next</code></li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverStack::next</code></li> <li>Use instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code> in log context instead of its class in the message in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStack::next</code></li> <li>Add dependency to <code>\\Psr\\Log\\LoggerInterface</code> into <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\StatusReporterStack</code> to log instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\Contract\\StatusReporterContract::next</code></li> <li>Set <code>array-key</code> type to return of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection::bySupport</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection::bySupport</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection::bySupport</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\StatusReporterCollection::bySupportedTopic</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection::bySupport</code> to <code>int</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Explorer</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Receiver</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\StatusReporter</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerStack</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Profiling\\NullProfiler</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverStack</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\StatusReporterStack</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStack</code> to ensure correct usage of implementation. Decoration by their interfaces or base classes is still possible</li> </ul>"},{"location":"releases/changelog-portal-base/#removed","title":"Removed","text":"<ul> <li>Remove container service ids <code>Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection.decorator</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection.decorator</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\StatusReporterCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection.decorator</code>, <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection</code> and <code>Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection.decorator</code> due to refactoring of flow component stack building</li> <li>Remove contracts and exceptions <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Cronjob\\Contract\\CronjobServiceInterface</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Cronjob\\Contract\\CronjobRunInterface</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Cronjob\\Contract\\CronjobInterface</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Cronjob\\Contract\\CronjobHandlerContract</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Cronjob\\Contract\\CronjobContextInterface</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Cronjob\\Exception\\InvalidCronExpressionException</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\CronjobKeyInterface</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\CronjobRunKeyInterface</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove deprecated methods <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::canSet</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::canGet</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\TypedMappedDatasetEntityCollection</code></li> <li>Remove deprecated method <code>Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface::publish</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\MappingKeyInterface</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\MappingKeyCollection</code></li> <li>Move unused <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\RouteKeyInterface</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\RouteKeyCollection</code> to package <code>heptacom/heptaconnect-storage-base</code> as <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\RouteKeyInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\RouteKeyCollection</code></li> </ul>"},{"location":"releases/changelog-portal-base/#084-2021-12-16","title":"[0.8.4] - 2021-12-16","text":""},{"location":"releases/changelog-portal-base/#removed_1","title":"Removed","text":"<ul> <li>Remove the code for unit tests, configuration for style checks as well as the Makefile</li> </ul>"},{"location":"releases/changelog-portal-base/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-portal-base/#added_7","title":"Added","text":"<ul> <li>Add composer dependency on <code>ext-mbstring:*</code></li> <li>Add composer dependency on <code>psr/event-dispatcher:^1.0</code></li> <li>Add post-processing data bag class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Support\\PostProcessorDataBag</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiveContextInterface::getEventDispatcher</code> for reception event processing</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiveContextInterface::getPostProcessingBag</code> to access post-processing data bag</li> <li>Add exception code <code>1636887426</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream::copy</code> when source stream is invalid</li> <li>Add exception code <code>1636887427</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream::copy</code> when source stream can't be read from</li> <li>Add exception code <code>1636887428</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream::copy</code> when result stream can't be created</li> <li>Add exception code <code>1636887429</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream::copy</code> when interim stream can't be created</li> <li>Add new flow component <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandleContextInterface</code> for new flow component</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerStackInterface</code> and implementation <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStack</code> for new flow component</li> <li>Add log message code <code>1636735335</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract::handleNext</code> when execution of the next handler failed</li> <li>Add log message code <code>1636735336</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract::handleCurrent</code> when execution of the current handler failed</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::httpHandler</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::buildHttpHandlers</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\HttpHandlerToken</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\HttpHandlerBuilder</code> to allow short notation for new flow component <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code></li> <li>Add log message code <code>1636791700</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::buildHttpHandlers</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::buildReceivers</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::buildEmitters</code> when building flow components and having a configuration conflict</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerUrlProviderInterface</code> to resolve URLs for flow component <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code> paths</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Exception\\InvalidResultException</code> to group cases when short-noted closures are return incorrect values</li> <li>Add exception code <code>1637017868</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::batch</code> when short-noted batch method returns an invalid value in iteration</li> <li>Add exception code <code>1637017869</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::batch</code> when short-noted batch method returns invalid value</li> <li>Add exception code <code>1637017870</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::run</code> when short-noted run method returns invalid value</li> <li>Add exception code <code>1637017871</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Emitter::extend</code> when short-noted extend method returns invalid value</li> <li>Add exception code <code>1637034100</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Explorer::run</code> when short-noted run method returns an invalid value in iteration</li> <li>Add exception code <code>1637034101</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Explorer::run</code> when short-noted run method returns invalid value</li> <li>Add exception code <code>1637034102</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\Explorer::isAllowed</code> when short-noted isAllowed method returns invalid value</li> <li>Add exception code <code>1637440327</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\HttpHandler</code> when any short-noted method returns invalid value</li> <li>Add exception code <code>1637036888</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Component\\StatusReporter::run</code> when short-noted run method returns invalid value</li> </ul>"},{"location":"releases/changelog-portal-base/#changed_3","title":"Changed","text":"<ul> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Publication\\Contract\\PublisherInterface::publish</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface::markAsFailed</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection::filterByEntityType</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct::__construct</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection::bySupport</code> from <code>$entityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack::__construct</code> from <code>$entityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection::bySupport</code> from <code>$entityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection::bySupport</code> from <code>$entityClassName</code> to <code>$entityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingComponentStructContract::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingComponentStructContract::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection::getDatasetEntityClassNames</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection::getEntityTypes</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\RouteInterface::getEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\RouteInterface::getEntityType</code></li> <li>As <code>\\Closure</code> has a more defined interface for analyzing compared to <code>callable</code> and the expected use-case for short-noted flow components are anonymous functions, the return types changed from <code>callable</code> to <code>\\Closure</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getBatch</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getRun</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getExtend</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::getRun</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::getIsAllowed</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::getBatch</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::getRun</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\StatusReporterToken::getRun</code></li> <li>As <code>\\Closure</code> has a more defined interface for analyzing compared to <code>callable</code> and the expected use-case for short-noted flow components are anonymous functions, the parameter types changed from <code>callable</code> to <code>\\Closure</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\EmitterBuilder::batch</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\EmitterBuilder::run</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\EmitterBuilder::extend</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\ExplorerBuilder::run</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\ExplorerBuilder::isAllowed</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\ReceiverBuilder::batch</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\ReceiverBuilder::run</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Builder\\StatusReporterBuilder::run</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::explorer</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::emitter</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::receiver</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::statusReporter</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::setBatch</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::setRun</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::setExtend</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::setRun</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::setIsAllowed</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::setBatch</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::setRun</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\StatusReporterToken::setRun</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\ResolveArgumentsTrait::resolveArguments</code></li> <li>Add throwing of exception <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Exception\\StreamCopyException</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream::copy</code></li> </ul>"},{"location":"releases/changelog-portal-base/#removed_2","title":"Removed","text":"<ul> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\WebhookKeyInterface</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\WebhookKeyCollection</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Webhook\\Contract\\WebhookContextInterface</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Webhook\\Contract\\WebhookHandlerContract</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Webhook\\Contract\\WebhookInterface</code> in favour of new flow component <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Webhook\\Contract\\WebhookServiceInterface</code> in favour of new flow component <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\Contract\\HttpHandlerContract</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerUrlProviderInterface</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\RouteInterface</code></li> </ul>"},{"location":"releases/changelog-portal-base/#fixed_4","title":"Fixed","text":"<ul> <li>Change type hint from <code>string</code> to <code>class-string&lt;\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract&gt;</code> for parameters in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::explorer</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::emitter</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::receiver</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::__construct</code></li> <li>Change type hint from <code>string</code> to <code>class-string&lt;\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract&gt;</code> for return type in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getType</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::getType</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::getType</code></li> <li>Allow missing types in short-noted flow components that are resolved by name by changing <code>string $parameterType</code> to <code>?string $parameterType</code> in function arguments in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\ResolveArgumentsTrait</code> and their usages</li> <li>Fixe return type hint on <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverStackInterface::next</code> to return an iterable of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract</code> instead of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface</code> and therefore returns like <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract::receive</code></li> </ul>"},{"location":"releases/changelog-portal-base/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-portal-base/#added_8","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::delete</code> as replacement for <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::unset</code>. This method returns a boolean instead of throwing exceptions.</li> <li>Add composer dependency on <code>psr/simple-cache:^1.0</code></li> </ul>"},{"location":"releases/changelog-portal-base/#changed_4","title":"Changed","text":"<ul> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract::iterate</code> caches object iteration strategies to improve performance</li> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface</code> implements <code>\\Psr\\SimpleCache\\CacheInterface</code>.</li> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::set</code> no longer throws exceptions on failure but returns a boolean instead.</li> </ul>"},{"location":"releases/changelog-portal-base/#removed_3","title":"Removed","text":"<ul> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::unset</code> has been replaced by <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalStorageInterface::delete</code>.</li> </ul>"},{"location":"releases/changelog-portal-base/#fixed_5","title":"Fixed","text":"<ul> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::reset</code> now cleans up status reporter building instructions that got previously registered with <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::statusReporter</code></li> <li><code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Support\\Contract\\DeepObjectIteratorContract::iterate</code> drops usage of <code>\\spl_object_hash</code> to not break on garbage collection</li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/","title":"Portal Local Shopware Platform Changelog","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#0902-2022-06-01","title":"[0.9.0.2] - 2022-06-01","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#fixed","title":"Fixed","text":"<ul> <li>Fixed address splitting on customer creation in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Receiver\\CustomerReceiver::getAddress</code> to satisfy the shopware standard address representation regarding street and house number.</li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#0901-2022-04-23","title":"[0.9.0.1] - 2022-04-23","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#fixed_1","title":"Fixed","text":"<ul> <li>Fix portal node service container extension to work with both portal FQCNs <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\LocalShopwarePlatformPortal</code> and the deprecated <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Portal</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#0900-2022-04-05","title":"[0.9.0.0] - 2022-04-05","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#added","title":"Added","text":"<ul> <li>Interpret <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Product\\Product::getMedias</code> to receive medias on products</li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#changed","title":"Changed","text":"<ul> <li>Use <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media::getFile</code> for transferring instead of <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Media\\Media::getNormalizedStream</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecate <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Portal</code> as renamed to <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\LocalShopwarePlatformPortal</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#removed","title":"Removed","text":"<ul> <li>Remove support for <code>shopware/core: &gt;=6.2.1 &lt;6.4</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#fixed_2","title":"Fixed","text":"<ul> <li>Product medias unpacked by <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker</code> have position by appearance in the product entity</li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#082-2022-02-09","title":"[0.8.2] - 2022-02-09","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#fixed_3","title":"Fixed","text":"<ul> <li>Fix function call on null in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Emitter\\OrderEmitter</code>.</li> <li>Fix compatibility with <code>shopware/core:^6.4</code> by supporting <code>\\Shopware\\Core\\System\\Currency\\CurrencyEntity::setItemRounding</code> if it exists.</li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#081-2021-12-07","title":"[0.8.1] - 2021-12-07","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#fixed_4","title":"Fixed","text":"<ul> <li>Fetch VAT-ID from customer instead of address in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Packer\\CustomerPacker::pack</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#added_1","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\LocaleMatcher</code> to centralize translation handling of incoming locale matching</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> to centralize translations payload generation of any <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Translatable\\Contract\\TranslatableInterface</code></li> <li>Add log message code <code>1637342440</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\LocaleMatcher::match</code> when a locale code is tested against a Shopware language</li> <li>Add log message code <code>1637342441</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\LocaleMatcher::match</code> when a locale code could not be matched</li> <li>Add log message code <code>1637342442</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\LocaleMatcher::match</code> when a locale code could be matched to a unique Shopware language</li> <li>Add log message code <code>1637342443</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\LocaleMatcher::match</code> when a locale code could be matched against multiple other Shopware languages</li> <li>Add log message code <code>1637344184</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker::unpack</code> when a translated value is tried to be applied but the language code could not be mapped to a Shopware language</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\CategoryUnpacker</code> to unpack category data into Shopware API payload</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\CustomerGroupUnpacker</code> to unpack customer group data into Shopware API payload</li> <li>Use <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\MediaUnpacker</code> to support translations</li> <li>Use <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ManufacturerUnpacker</code> to support translations</li> <li>Use <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\PropertyValueUnpacker</code> to support translations</li> <li>Use <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\PropertyGroupUnpacker</code> to support translations</li> <li>Add <code>\\Shopware\\Core\\System\\Language\\LanguageLoaderInterface</code> to portal node container</li> <li>Add compatibility in code for <code>ramsey/uuid: ^4</code> and therefore changed composer requirement to <code>ramsey/uuid: ^3.5 || ^4</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#changed_1","title":"Changed","text":"<ul> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Receiver\\CategoryReceiver</code> into short notation</li> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Receiver\\CustomerGroupReceiver</code> into short notation</li> <li>Change default value for configuration for <code>dal_indexing_mode</code> from <code>none</code> to <code>queue</code></li> <li>Use <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\UnitUnpacker</code> instead of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\Translator</code></li> <li>Use <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker</code> instead of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\TranslationLocaleCache</code> directly</li> <li>Use <code>\\Shopware\\Core\\System\\Language\\LanguageLoaderInterface</code> in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\TranslationLocaleCache</code> instead of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalAccess</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\ExistingIdentifierCache</code> dependency from <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ManufacturerUnpacker</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#fixed_5","title":"Fixed","text":"<ul> <li>Use fallback translations values for default language for the keys name and description in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker::unpackTranslations</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#removed_1","title":"Removed","text":"<ul> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\Translator</code> in favour of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\TranslatableUnpacker</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\TranslationLocaleCache</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-portal-local-shopware-platform/#added_2","title":"Added","text":"<ul> <li>Add optional operation key <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::upsert</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::delete</code> for easier task recognition</li> <li>Add optional context parameter to <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::flush</code> allowing an override of the used modified context</li> <li>Extract locale code caching from <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\Translator</code> into new service <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\TranslationLocaleCache</code></li> <li>New protected method <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker::unpackTranslations</code> adds support for translated product content. By default <code>name</code> and <code>description</code> is supported</li> <li>Add product property assignments in return value of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker::unpack</code></li> <li>Add cleanup of previously imported product properties in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Receiver\\ProductReceiver</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#changed_2","title":"Changed","text":"<ul> <li>Improve memory usage and first call wall time of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\ExistingIdentifierCache::getProductMediaId</code> by dropping id cache warmup</li> <li>Throw <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\Exception\\DuplicateSyncOperationKeyPreventionException</code> with code <code>1632595313</code> when <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::upsert</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::delete</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::push</code> have a duplicate mismatch</li> <li>Change return value of <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\DalSyncer::flush</code> from <code>self</code> to <code>\\Shopware\\Core\\Framework\\Api\\Sync\\SyncResult</code> to access pure sync api result</li> <li><code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductPriceUnpacker::unpack</code> now expects a price collection and a product identifier to generate product price rules more efficiently</li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#removed_2","title":"Removed","text":"<ul> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Support\\Translator::getIngredientTranslation</code></li> <li>In favour of translations <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker::unpack</code> no longer adds <code>name</code> and <code>description</code> in the payload root</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductUnpacker::unpackPrices</code> due to complete extraction into <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\ProductPriceUnpacker::unpack</code></li> </ul>"},{"location":"releases/changelog-portal-local-shopware-platform/#fixed_6","title":"Fixed","text":"<ul> <li>Change payload key that references property groups in <code>\\Heptacom\\HeptaConnect\\Portal\\LocalShopwarePlatform\\Unpacker\\PropertyValueUnpacker::unpack</code> to fix reception of <code>\\Heptacom\\HeptaConnect\\Dataset\\Ecommerce\\Property\\PropertyValue</code></li> </ul>"},{"location":"releases/changelog-storage-base/","title":"Storage Base Changelog","text":""},{"location":"releases/changelog-storage-base/#0970-2024-02-10","title":"[0.9.7.0] - 2024-02-10","text":""},{"location":"releases/changelog-storage-base/#fixed","title":"Fixed","text":"<ul> <li>Fix deprecation notice <code>Creation of dynamic property</code> by explicitly declaring property <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::$portalNodeStorageSetAction</code></li> </ul>"},{"location":"releases/changelog-storage-base/#0950-2023-05-27","title":"[0.9.5.0] - 2023-05-27","text":""},{"location":"releases/changelog-storage-base/#fixed_1","title":"Fixed","text":"<ul> <li>Fix default sort assignment in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewCriteria</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewCriteria</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewCriteria</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Overview\\PortalNodeAliasOverviewCriteria</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewCriteria</code> by making <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewCriteria::$sort</code> protected again</li> <li>Fix syntax error in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreatePayload</code> affecting <code>php: ^7.4</code></li> </ul>"},{"location":"releases/changelog-storage-base/#0940-2023-03-04","title":"[0.9.4.0] - 2023-03-04","text":""},{"location":"releases/changelog-storage-base/#added","title":"Added","text":"<ul> <li>Add storage key interface <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\IdentityRedirectKeyInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\IdentityRedirectKeyCollection</code></li> <li>Add identity redirect create action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectCreateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreatePayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreatePayloadCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreateResult</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreateResultCollection</code></li> <li>Add methods <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getIdentityRedirectCreateAction</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::getIdentityRedirectCreateAction</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createIdentityRedirectCreateAction</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\Psr11StorageFacade::createIdentityRedirectCreateAction</code> to access the storage implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectCreateActionInterface</code></li> <li>Add identity redirect delete action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectDeleteActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Delete\\IdentityRedirectDeleteCriteria</code></li> <li>Add methods <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getIdentityRedirectDeleteAction</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::getIdentityRedirectDeleteAction</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createIdentityRedirectDeleteActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\Psr11StorageFacade::createIdentityRedirectDeleteActionInterface</code> to access the storage implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectDeleteActionInterface</code></li> <li>Add identity redirect overview action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectOverviewActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewResult</code></li> <li>Add methods <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getIdentityRedirectOverviewAction</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::getIdentityRedirectOverviewAction</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createIdentityRedirectOverviewActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\Psr11StorageFacade::createIdentityRedirectOverviewActionInterface</code> to access the storage implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectOverviewActionInterface</code></li> </ul>"},{"location":"releases/changelog-storage-base/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-storage-base/#added_1","title":"Added","text":"<ul> <li>Add job state transition to schedule jobs after they failed with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobScheduleActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Schedule\\JobSchedulePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Schedule\\JobScheduleResult</code></li> <li>Add job state transition to fail jobs after they run with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Fail\\JobFailPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Fail\\JobFailResult</code></li> <li>Add job state transition message to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Schedule\\JobSchedulePayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Fail\\JobFailPayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Finish\\JobFinishPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Start\\JobStartPayload</code></li> <li>Add portal node extension activation action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionActivateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivateResult</code></li> <li>Add portal node extension deactivation action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionDeactivateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivateResult</code></li> <li>Add portal node extension activity find action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionFindActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Find\\PortalExtensionFindResult</code></li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code> for bridges and new composer package <code>heptacom/heptaconnect-test-suite-storage</code> to have central point to access storage</li> <li>Add supporting base class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\Psr11StorageFacade</code> to implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code> based upon a service container</li> <li>Add supporting base class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade</code> to implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code> that ensures in the implementation that services are only factorized once</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\ReadException</code> for storage actions to express issues on reading</li> <li>Add route delete action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteDeleteActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Delete\\RouteDeleteCriteria</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\FileReference\\RequestGet\\FileReferenceGetRequestCriteria</code> as input for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferenceGetRequestActionInterface::getRequest</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\FileReference\\RequestGet\\FileReferenceGetRequestResult</code> as output for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferenceGetRequestActionInterface::getRequest</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\FileReference\\RequestPersist\\FileReferencePersistRequestPayload</code> as input for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferencePersistRequestActionInterface::persistRequest</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\FileReference\\RequestPersist\\FileReferencePersistRequestResult</code> as output for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferencePersistRequestActionInterface::persistRequest</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferenceGetRequestActionInterface</code> to read serialized requests from storage</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferencePersistRequestActionInterface</code>  to write serialized requests to storage</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\FileReferenceRequestKeyInterface</code> as storage key for stored request objects</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\FileReferenceRequestKeyCollection</code> as collection for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\FileReferenceRequestKeyInterface</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\AliasAwarePortalNodeStorageKey</code> as implementation to identify a portal node key that must be displayed as alias whenever possible</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasFindActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Find\\PortalNodeAliasFindCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Find\\PortalNodeAliasFindResult</code> to find portal node keys by alias</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasGetActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Get\\PortalNodeAliasGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Get\\PortalNodeAliasGetResult</code> to get aliases by portal node keys</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasOverviewActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Overview\\PortalNodeAliasOverviewCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Overview\\PortalNodeAliasOverviewResult</code> to overview all defined portal node aliases</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasSetActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Set\\PortalNodeAliasSetPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeAlias\\Set\\PortalNodeAliasSetPayloads</code> to set and unset portal node aliases</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\UpdateException</code> to identify errors on updates in the storage</li> </ul>"},{"location":"releases/changelog-storage-base/#changed","title":"Changed","text":"<ul> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::add</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract::add</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Repository\\JobAdd</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobCreateActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreatePayloads</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreatePayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreateResults</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreateResult</code> to allow batch writing and collected writing of jobs and their payload</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::get</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract::get</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobGetActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Get\\JobGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Get\\JobGetResult</code> to allow batch reading and collected reading of jobs and their payload</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::start</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Start\\JobStartPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Start\\JobStartResult</code> to allow batch state change</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::finish</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Finish\\JobFinishPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Finish\\JobFinishResult</code> to allow batch state change</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::remove</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract::remove</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobCreateActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreatePayloads</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreatePayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreateResults</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Create\\JobCreateResult</code> to allow batch deletion and collected deletion of jobs and their payloads</li> <li>Split up <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::cleanup</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract::cleanup</code> into storage actions <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobListFinishedActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobDeleteActionInterface</code> to separate searching and finding deletable jobs</li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeCreateActionInterface</code> to create portal nodes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayloads</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayload</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreateResults</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreateResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeDeleteActionInterface</code> to delete portal nodes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Delete\\PortalNodeDeleteCriteria</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeGetActionInterface</code> to get portal nodes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Get\\PortalNodeGetCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Get\\PortalNodeGetResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface</code> to get all portal nodes and return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Listing\\PortalNodeListResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeOverviewActionInterface</code> to an overview of portal nodes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListCriteria</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListCriteria</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewCriteria</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewCriteria</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindCriteria</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindCriteria</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetCriteria</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetCriteria</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreatePayloads</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayloads</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreatePayload</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayload</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateResults</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreateResults</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreateResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewCriteria</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewCriteria</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindResult</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindResult</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayloads</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayloads</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ListReceptionRouteListActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\ReceptionRouteListActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteOverviewActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteFindActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteGetActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Croute\\RouteCreateActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteCreateActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\RouteCapabilityOverviewActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFindActionInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetActionInterface</code> to a new namespace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSetActionInterface</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\ConfigurationStorageContract::getConfiguration</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGetActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeConfiguration\\Get\\PortalNodeConfigurationGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeConfiguration\\Get\\PortalNodeConfigurationGetResult</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\ConfigurationStorageContract::setConfiguration</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSetActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeConfiguration\\Set\\PortalNodeConfigurationSetPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeConfiguration\\Set\\PortalNodeConfigurationSetPayloads</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityMapperContract::mapEntities</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface::map</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Mapping</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Map\\IdentityMapPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Map\\IdentityMapResult</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract::persist</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersistPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Exception\\MappingConflictException</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface::persist</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Persist\\IdentityPersistPayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Persist\\IdentityPersistPayloadCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Persist\\IdentityPersistPayloadContract</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Persist\\IdentityPersistCreatePayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Persist\\IdentityPersistDeletePayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Persist\\IdentityPersistUpdatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Exception\\IdentityConflictException</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listByMappingNode</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listByPortalNodeAndType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::read</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::listByTypeAndPortalNodeAndExternalIds</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::read</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewResult</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\EntityReflectorContract::reflectEntities</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityReflectActionInterface::reflect</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Reflect\\IdentityReflectPayload</code> that allows for optimizations for different use-cases</li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayloads</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayloads</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreateResult</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreateResults</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreateResults</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindCriteria</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindCriteria</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindResult</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindResult</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetCriteria</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetCriteria</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetResult</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetResult</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListCriteria</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListCriteria</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListResult</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListResult</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewCriteria</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewCriteria</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewCriteria</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewCriteria</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewResult</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewResult</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindResult</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindResult</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayloads</code> to ensure correct usage of implementation. To still add custom data the <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\AttachmentAwareInterface</code> is implemented by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayloads</code></li> <li>Add final modifier to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PreviewPortalNodeKey</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct</code> to ensure correct usage of implementation. Decoration by their interfaces or base classes is still possible</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::clear</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageClearActionInterface::clear</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Clear\\PortalNodeStorageClearCriteria</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::deleteMultiple</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::unset</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageDeleteActionInterface::delete</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Delete\\PortalNodeStorageDeleteCriteria</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::getMultiple</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::getValue</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::getType</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::has</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageGetActionInterface::get</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Get\\PortalNodeStorageGetCriteria</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Get\\PortalNodeStorageGetResult</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\PortalNodeStorageItemContract</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::setMultiple</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::set</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageSetActionInterface::set</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Set\\PortalNodeStorageSetItem</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Set\\PortalNodeStorageSetItems</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Set\\PortalNodeStorageSetPayload</code> that allows for optimizations for different use-cases</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::list</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeStorage\\PortalNodeStorageListActionInterface::list</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Listing\\PortalNodeStorageListCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNodeStorage\\Listing\\PortalNodeStorageListResult</code> that allows for optimizations for different use-cases</li> <li>Rename <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\MappingExceptionKeyInterface</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\IdentityErrorKeyInterface</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingExceptionRepositoryContract::create</code> with storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityError\\Create\\IdentityErrorCreateResults</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityError\\Create\\IdentityErrorCreateResult</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityError\\Create\\IdentityErrorCreatePayloads</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityError\\Create\\IdentityErrorCreatePayload</code> to allow batch writing of identity errors</li> <li>Move interface <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\Contract\\RouteKeyInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\RouteKeyInterface</code></li> <li>Move class <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StorageKey\\RouteKeyCollection</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\RouteKeyCollection</code></li> </ul>"},{"location":"releases/changelog-storage-base/#removed","title":"Removed","text":"<ul> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\JobInterface</code></li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\JobPayloadKeyInterface</code></li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract</code></li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract</code></li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Repository\\JobAdd</code></li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract::read</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeGetActionInterface::get</code> that allows for optimizations for different use-cases</li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract::listAll</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface::list</code> that allows for optimizations for different use-cases</li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract::listByClass</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeOverviewActionInterface::overview</code> that allows for optimizations for different use-cases</li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract::create</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeCreateActionInterface::create</code> that allows for optimizations for different use-cases</li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\PortalNodeRepositoryContract::create</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeDeleteActionInterface::delete</code> that allows for optimizations for different use-cases</li> <li>Remove contracts and exceptions <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\CronjobRepositoryContract</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\CronjobRunRepositoryContract</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove unused contract method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listByNodes</code></li> <li>Remove unused contract method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listUnsavedExternalIds</code></li> <li>Remove unused contract method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::updateExternalId</code></li> <li>Remove unused contract method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::listByTypeAndPortalNodeAndExternalId</code></li> <li>Remove unused contract method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::create</code></li> <li>Move contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\ResourceLockStorageContract</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Parallelization\\Contract\\ResourceLockStorageContract</code> as it will be provided by integration and not storage</li> <li>Remove unused contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingExceptionRepositoryContract::listByMapping</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingExceptionRepositoryContract::listByMappingAndType</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingExceptionRepositoryContract::delete</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract</code></li> <li>Remove deprecated <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\StorageKeyGeneratorContract::generateKey</code></li> </ul>"},{"location":"releases/changelog-storage-base/#085-2021-12-28","title":"[0.8.5] - 2021-12-28","text":""},{"location":"releases/changelog-storage-base/#fixed_2","title":"Fixed","text":"<ul> <li>Change composer dependency <code>bentools/iterable-functions: &gt;=1 &lt;2</code> to <code>bentools/iterable-functions: &gt;=1.4 &lt;2</code> to ensure availability of <code>iterable_map</code></li> </ul>"},{"location":"releases/changelog-storage-base/#084-2021-12-16","title":"[0.8.4] - 2021-12-16","text":""},{"location":"releases/changelog-storage-base/#removed_1","title":"Removed","text":"<ul> <li>Remove the code for unit tests, configuration for style checks as well as the Makefile</li> </ul>"},{"location":"releases/changelog-storage-base/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-storage-base/#added_2","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::start</code> for tracking the start of job processing</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::finish</code> for tracking the stop of job processing</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::cleanup</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract::cleanup</code> for cleaning up executed jobs and their payloads</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code> for listing reception routes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListResult</code></li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Overview\\OverviewCriteriaContract</code> for overview criterias</li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code> for listing all routes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code> for checking the existence of a route by its components by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> for reading metadata of routes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateActionInterface</code> for creating routes by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreatePayloads</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreatePayload</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateResults</code> of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateResult</code></li> <li>With storage restructure explained in this ADR we add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewActionInterface</code> for listing available route capabilities by the given <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewCriteria</code> to return a <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewResult</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Enum\\RouteCapability</code> to hold constant values for route capabilities</li> <li>Add interface <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Create\\CreatePayloadInterface</code> to reference to create payloads more easily in exceptions</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\CreateException</code> for all cases when creation failed</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\InvalidCreatePayloadException</code> for all cases when creation failed due to invalid payload</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\InvalidOverviewCriteriaException</code> for cases when overview criteria are malformed</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindActionInterface</code> to get a configuration key for an HTTP handler by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria</code> into <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindResult</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetActionInterface</code> to set configuration keys for HTTP handlers by <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayloads</code> and its <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload</code></li> </ul>"},{"location":"releases/changelog-storage-base/#changed_1","title":"Changed","text":"<ul> <li>Change parameter name in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::listByTypeAndPortalNodeAndExternalId</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::listByTypeAndPortalNodeAndExternalIds</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::create</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::createList</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listUnsavedExternalIds</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listByPortalNodeAndType</code> from <code>$datasetEntityType</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\UnsharableOwnerException::__construct</code> from <code>$expectedDatasetEntityClassName</code> to <code>$expectedEntityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct::__construct</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\MappingNodeStructInterface::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\MappingNodeStructInterface::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\UnsharableOwnerException::getExpectedDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Exception\\UnsharableOwnerException::getExpectedEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStructgetDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct::getForeignDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct::getForeignEntityType</code></li> </ul>"},{"location":"releases/changelog-storage-base/#removed_2","title":"Removed","text":"<ul> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract::listBySourceAndEntityType</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface::list</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface::overview</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface::find</code> that allows for optimizations for different use-cases</li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract::read</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface::get</code> that allows for optimizations in the storage implementation</li> <li>With storage restructure explained in this ADR we remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\RouteRepositoryContract::create</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateActionInterface::create</code> that allows for optimizations in the storage implementation</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\WebhookRepositoryContract</code></li> </ul>"},{"location":"releases/changelog-storage-base/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-storage-base/#added_3","title":"Added","text":"<ul> <li>Add methods in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract</code> (<code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::clear</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::getMultiple</code> and  <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract::deleteMultiple</code>) to allow PSR simple cache compatibility</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Contract\\MappingPersisterContract</code>. It must be used with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersistPayload</code>. It can throw <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\MappingPersister\\Exception\\MappingConflictException</code>.</li> </ul>"},{"location":"releases/changelog-storage-base/#changed_2","title":"Changed","text":"<ul> <li>Change parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\TypedMappingCollection::__construct</code> to allow iterables to be consumed like its parent class</li> </ul>"},{"location":"releases/changelog-storage-base/#fixed_3","title":"Fixed","text":"<ul> <li>Require previously soft-required <code>bentools/iterable-functions: &gt;=1 &lt;2</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/","title":"Storage Shopware DAL Changelog","text":""},{"location":"releases/changelog-storage-shopware-dal/#0911-2023-03-07","title":"[0.9.1.1] - 2023-03-07","text":""},{"location":"releases/changelog-storage-shopware-dal/#added","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect::LOOKUP_IDENTITY_REDIRECTS_QUERY</code> as <code>315e9e8f-b1b7-4e39-a42b-4dbdf3d8b14c</code> to identify a query used for looking up identity redirects, that evaluate identities before mapping nodes are evaluated</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#fixed","title":"Fixed","text":"<ul> <li>Add lookup for identity redirects to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0910-2023-03-04","title":"[0.9.1.0] - 2023-03-04","text":""},{"location":"releases/changelog-storage-shopware-dal/#added_1","title":"Added","text":"<ul> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\IdentityRedirectStorageKey</code> implementing <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\IdentityRedirectKeyInterface</code> as storage key for identity redirects</li> <li>Add support for <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\IdentityRedirectStorageKey</code> into <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code></li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1673717600AddIdentityRedirectTable</code> to add storage for identity redirects</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate</code> implementing <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectCreateInterface</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getIdentityRedirectCreateAction</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Bridge\\StorageFacade::createIdentityRedirectCreateActionInterface</code> to return <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate</code></li> <li>Add exception code <code>1673722278</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate::create</code> when the payload refers to a source portal node with an invalid portal node</li> <li>Add exception code <code>1673722279</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate::create</code> when the payload refers to a target portal node with an invalid portal node</li> <li>Add exception code <code>1673722280</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate::create</code> when the payload refers to an unknown entity type</li> <li>Add exception code <code>1673722281</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate::create</code> when the key generator cannot generate a valid identity redirect key</li> <li>Add exception code <code>1673722282</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectCreate::create</code> when writing to the database fails</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectDelete</code> implementing <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectDeleteInterface</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getIdentityRedirectDeleteAction</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Bridge\\StorageFacade::createIdentityRedirectDeleteActionInterface</code> to return <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectDelete</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectDelete::LOOKUP_QUERY</code> as <code>26f18fa9-9246-45cf-b7f7-2fc80f61151d</code> to identify a query used for deleting identity redirects</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectDelete::DELETE_QUERY</code> as <code>ca54ecac-3b6b-4f54-882e-fea1f19336ba</code> to identify a query used for looking up identity redirects that can be deleted</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectOverview::OVERVIEW_QUERY</code> as <code>832dbfc9-4939-4301-ade4-aa73d961454f</code> to identify a query used for loading an overview page for identity redirects</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityRedirect\\IdentityRedirectOverviewActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectOverview</code> to list identity redirects</li> <li>Add exception code <code>1673729808</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectOverview::overview</code> when the payload refers to a identity redirect with an invalid identity redirect key</li> <li>Add exception code <code>1673729809</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectOverview::overview</code> when the payload refers to a source portal node with an invalid portal node key</li> <li>Add exception code <code>1673729810</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectOverview::overview</code> when the payload refers to a target portal node with an invalid portal node key</li> <li>Add exception code <code>1673729811</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityRedirect\\IdentityRedirectOverview::overview</code> when the criteria has an invalid sorting option</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#changed","title":"Changed","text":"<ul> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1677428200AddKeyIndexToPortalNodeStorageTable</code> to add index to <code>key</code> to table <code>heptaconnect_portal_node_storage</code> for improved portal node storage reads</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1677950300AddExternalIdIndexToJobTable</code> to add index to <code>external_id</code> to table <code>heptaconnect_job</code> for better database usage outside of business logic</li> <li>Raise composer dependency constraint for <code>heptacom/heptaconnect-dataset-base</code>, <code>heptacom/heptaconnect-portal-base</code> and <code>heptacom/heptaconnect-storage-base</code> from <code>^0.9.3</code> to <code>^0.9.4</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#fixed_1","title":"Fixed","text":"<ul> <li>Ensure query <code>900bdcb4-3a2a-4092-9eed-f5902e97b02f</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor</code> uses an ordering to ensure iteration on big data sets is ordered correctly and passes runtime tests</li> <li>Ensure query <code>f683453e-336f-4913-8bb9-aa0e34745f97</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor</code> uses an ordering to ensure iteration on big data sets is ordered correctly and passes runtime tests</li> <li>Ensure query <code>f6c5db7b-004d-40c8-b9cc-53707aab658b</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind</code> uses an ordering to ensure iteration on big data sets is ordered correctly and passes runtime tests</li> <li>Fix incorrect SQL statement when deleting entries in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0906-2023-02-14","title":"[0.9.0.6] - 2023-02-14","text":""},{"location":"releases/changelog-storage-shopware-dal/#changed_1","title":"Changed","text":"<ul> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1674420000AddJobTransactionIdIndex</code> to add index to <code>transaction_id</code> to table <code>heptaconnect_job</code> for improved job state changes</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#fixed_2","title":"Fixed","text":"<ul> <li>Prevent duplication of entries in the portal-storage when updating keys that are already expired.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0905-2022-11-19","title":"[0.9.0.5] - 2022-11-19","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_3","title":"Fixed","text":"<ul> <li>Fix error when creating mappings via <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect</code>. Insertion payload was not binary as expected.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0904-2022-10-03","title":"[0.9.0.4] - 2022-10-03","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_4","title":"Fixed","text":"<ul> <li>Pagination in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityOverview</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeOverview</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasOverview</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview</code> was one page in advance and therefore made page 1 only accessable when listing without pagination in criteria</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0903-2022-09-20","title":"[0.9.0.3] - 2022-09-20","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_5","title":"Fixed","text":"<ul> <li>Fix error when creating mappings via <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect</code>. The insert-query now uses the correct table-name.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0902-2022-07-12","title":"[0.9.0.2] - 2022-07-12","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_6","title":"Fixed","text":"<ul> <li>Fix error when deleting many jobs at once by chunking job deletion to 1000 jobs at a time in <code>Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobDelete::delete</code></li> <li>Fix issue in validation before mapping-node merging involving deleted mappings in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::validateMappingNodesCanBeMerged</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0901-2022-04-19","title":"[0.9.0.1] - 2022-04-19","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_7","title":"Fixed","text":"<ul> <li>Fix error related to foreign key checks in migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1639860447UpdateExistingJobData</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#0900-2022-04-02","title":"[0.9.0.0] - 2022-04-02","text":""},{"location":"releases/changelog-storage-shopware-dal/#added_2","title":"Added","text":"<ul> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\JobTypeAccessor</code></li> <li>Add state in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder</code> to make selects for update to trigger row locks</li> <li>Add constants for job states in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Enum\\JobStateEnum</code></li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1639246133CreateStateHistoryForJobs</code> to add job state history</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1639270114InsertJobStates</code> to add job states</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1639860447UpdateExistingJobData</code> to migrate state date into job history</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobCreateActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobCreate</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobDeleteActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobDelete</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFailActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFail</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobFinishActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFinish</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobGetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobGet</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobListFinishedActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFinishedList</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobScheduleActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobSchedule</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Job\\JobStartActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobStart</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeOverviewActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeOverview</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeListActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeList</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeGetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeGet</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeDeleteActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeDelete</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNode\\PortalNodeCreateActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeCreate</code></li> <li>Add exception code <code>1640048751</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeCreate::create</code> when the key generator cannot generate a valid portal node key</li> <li>Add exception code <code>1648345724</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeCreate::create</code> when the portal node alias is empty</li> <li>Add exception code <code>1648345725</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeCreate::create</code> when the portal node alias is already used</li> <li>Add exception code <code>1640405544</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeOverview::overview</code> when the criteria has an invalid sorting option</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1640360050CreatePortalExtensionConfigurationTable</code> to add table for portal extension activity state</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionSwitchActive</code> to simplify implementations of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionActivateActionInterface</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionDeactivateActionInterface</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionActivateActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionActivate</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionDeactivateActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionDeactivate</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalExtension\\PortalExtensionFindActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionFind</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGet</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSet</code></li> <li>Add exception code <code>1642863637</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSet::set</code> when the payload has an invalid portal node key</li> <li>Add exception code <code>1642863638</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSet::set</code> when the payload value is not JSON serializable</li> <li>Add exception code <code>1642863639</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSet::set</code> when writing to the database fails</li> <li>Add exception code <code>1642863472</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGet::get</code> when the configuration value is not a valid JSON</li> <li>Add exception code <code>1642863473</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGet::get</code> when the configuration value is not a JSON array or JSON object</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1642624782CreatePortalNodeConfigurationTable</code> to add table for portal node configuration and migrate from the previous storage</li> <li>Add exception code <code>1642937283</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1642624782CreatePortalNodeConfigurationTable::migrate</code> when the JSON value from the old storage cannot be parsed</li> <li>Add exception code <code>1642937284</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1642624782CreatePortalNodeConfigurationTable::migrate</code> when the JSON value from the old storage has an unexpected form</li> <li>Add exception code <code>1642937285</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1642624782CreatePortalNodeConfigurationTable::migrate</code> when the read JSON from the old storage cannot be transformed into JSON for the new storage</li> <li>Add exception code <code>1642940744</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor::getIdsForTypes</code> when writing to the database fails</li> <li>Add exception code <code>1642951892</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityMap::map</code> when writing to the database fails</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Contract\\Route\\Delete\\RouteDeleteActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteDelete</code> to delete routes</li> <li>Add exception code <code>1643144707</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when check for same external id and having different mapping nodes fails</li> <li>Add exception code <code>1643144708</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when check for same mapping node and having different external ids fails</li> <li>Add exception code <code>1643144709</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when instructed identity mapping cannot be performed as related identities conflict</li> <li>Add exception code <code>1643149115</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when the create-payload refers to a mapping node with an invalid mapping node key</li> <li>Add exception code <code>1643149116</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when the update-payload refers to a mapping node with an invalid mapping node key</li> <li>Add exception code <code>1643149117</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when the delete-payload refers to a mapping node with an invalid mapping node key</li> <li>Add exception code <code>1643149290</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when the update-payload refers to an entry that is not present in storage</li> <li>Add exception code <code>1643149291</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::persist</code> when the delete-payload refers to an entry that is not present in storage</li> <li>Add exception code <code>1643746495</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect::reflect</code> when writing to the database fails</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityOverviewActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityOverview</code> to list identities</li> <li>Add exception code <code>1643877525</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityOverview::overview</code> when the payload refers to a mapping node with an invalid mapping node key</li> <li>Add exception code <code>1643877526</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityOverview::overview</code> when the payload refers to a portal node with an invalid portal node key</li> <li>Add exception code <code>1643877527</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityOverview::overview</code> when the criteria has an invalid sorting option</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\IdentityError\\IdentityErrorCreateActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityError\\IdentityErrorCreate</code> to store identity errors</li> <li>Add exception code <code>1645308762</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityError\\IdentityErrorCreate::create</code> when the payload refers to a portal node with an invalid portal node key</li> <li>Add exception code <code>1645308763</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityError\\IdentityErrorCreate::create</code> when the referenced mapping node by components is not known</li> <li>Add exception code <code>1645308764</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityError\\IdentityErrorCreate::create</code> when writing to the database fails</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Bridge\\StorageFacade</code></li> <li>Add query identifier parameter into <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder::__construct</code> that is added on query execution</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::fetchRow</code> to fetch a row keyed by column names</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::fetchColumn</code> to fetch a row and return its' first value</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::fetchSingleRow</code> to fetch a row keyed by column names and verify it is exactly a single row</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::iterateSafelyPaginated</code> to always paginate over rows keyed by column names even when no max result is given with the given safe pagination size parameter</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder::fetchSingleRow</code> to forward itself to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::fetchSingleRow</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder::fetchSingleValue</code> to forward itself to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::fetchSingleValue</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder::iterateRows</code> to forward itself to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::iterate</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder::iterateColumn</code> to forward itself to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::iterateColumn</code></li> <li>Add exception code <code>1645901524</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::iterateSafelyPaginated</code> when an invalid safe fetch size is given</li> <li>Add exception code <code>1645901525</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::iterateSafelyPaginated</code> when the query will be paginated without order statement</li> <li>Add exception code <code>1645901522</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::fetchSingleRow</code> when more than 1 row can be fetched from a query that expects only a single row</li> <li>Add factory <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryFactory</code> with configurable fallback pagination size for every builder</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor::LOOKUP_QUERY</code> as <code>992a88ac-a232-4d99-b1cc-4165da81ba77</code> to identify a query used for looking up entity types</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\JobTypeAccessor::LOOKUP_QUERY</code> as <code>28ef8980-146b-416c-8338-f1e394ac8c5f</code> to identify a query used for looking up job types</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\RouteCapabilityAccessor::FETCH_QUERY</code> as <code>93fd2b30-ca58-4d60-b29e-d14115b5ea2b</code> to identify a query used for reading route capability data</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor::FETCH_QUERY</code> as <code>900bdcb4-3a2a-4092-9eed-f5902e97b02f</code> to identify a query used for reading web HTTP handler data</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor::FETCH_QUERY</code> as <code>f683453e-336f-4913-8bb9-aa0e34745f97</code> to identify a query used for reading web HTTP handler path data</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityMap::MAPPING_NODE_QUERY</code> as <code>0d104088-b0d4-4158-8f95-0bc8a6880cc8</code> to identify a query used for loading related mapping nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityMap::MAPPING_QUERY</code> as <code>3c3f73e2-a95c-4ff3-89c5-c5f166195c24</code> to identify a query used for loading related mappings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityOverview::OVERVIEW_QUERY</code> as <code>510bb5ac-4bcb-4ddf-927c-05971298bc55</code> to identify a query used for loading an overview page for identities</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::TYPE_LOOKUP_QUERY</code> as <code>4adbdc58-1ec7-45c0-9a5b-0ac983460505</code> to identify a query used for looking up related entity types</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::BUILD_DELETE_PAYLOAD_QUERY</code> as <code>db92d189-494e-4d0b-be0b-492e4ded99c1</code> to identify a query used for reading identities that have to be deleted</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::BUILD_UPDATE_PAYLOAD_QUERY</code> as <code>ddad865c-0608-42cd-89f1-148a44ed8f31</code> to identify a query used for reading identities that have be updated</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::VALIDATE_CONFLICTS_QUERY</code> as <code>38d26bce-b577-4def-9fe3-d055cb63495d</code> to identify a query used for identifying possible conflicts</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist::VALIDATE_MERGE_QUERY</code> as <code>d8bb9156-edcc-4b1b-8e7e-fae2e8932434</code> to identify a query used for identifying possible merges</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\IdentityError\\IdentityErrorCreate::LOOKUP_QUERY</code> as <code>95f2537a-eda2-4123-824d-72f6c871e8a8</code> to identify a query used for looking up related mapping nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobCreate::PAYLOAD_LOOKUP_QUERY</code> as <code>b2234327-93a0-4854-ac52-fba75f71da74</code> to identify a query used for looking up payload entries</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobDelete::DELETE_QUERY</code> as <code>f60b01fc-8f9a-4a37-a009-a00db9a64b11</code> to identify a query used for deleting jobs</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobDelete::LOOKUP_QUERY</code> as <code>c1c41a80-6aec-4499-a07a-26ee57b07594</code> to identify a query used for looking up jobs that can be deleted</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFinishedList::LIST_QUERY</code> as <code>008ced6c-7517-46f8-a8a0-8f3c31b50467</code> to identify a query used for listing finished jobs</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobGet::FETCH_QUERY</code> as <code>809ecd5e-291f-417c-9c76-003c7ead65e9</code> to identify a query used for reading job data</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionFind::LOOKUP_QUERY</code> as <code>82bb12c6-ed9c-4646-901a-4ff7e8e4e88c</code> to identify a query used for looking up portal extension configurations</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionSwitchActive::CLASS_NAME_LOOKUP_QUERY</code> as <code>a6bbbe3b-bf42-455d-824e-8c1aac4453b6</code> to identify a query used for looking up class name references</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionSwitchActive::ID_LOOKUP_QUERY</code> as <code>2fc478d7-4f03-4a3d-a335-d6daf4244c27</code> to identify a query used for looking up existing configuration ids</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionSwitchActive::SWITCH_QUERY</code> as <code>5444ccf3-cf11-4a5b-bf5f-8c268dce9c1a</code> to identify a query used for switching active states of portal extensions</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeDelete::DELETE_QUERY</code> as <code>219156bb-0598-49df-8205-6d10e8f92a61</code> to identify a query used for deleting portal nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeDelete::LOOKUP_QUERY</code> as <code>aafca974-b95e-46ea-a680-834a93d13140</code> to identify a query used for looking up portal nodes that can be deleted</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeGet::FETCH_QUERY</code> as <code>efbd19ba-bc8e-412c-afb2-8a21f35e21f9</code> to identify a query used for reading portal node data</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeList::LIST_QUERY</code> as <code>52e85ba9-3610-403b-be28-b8d138481ace</code> to identify a query used for listing up all portal nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\ReceptionRouteList::LIST_QUERY</code> as <code>a2dc9481-5738-448a-9c85-617fec45a00d</code> to identify a query used for listing up all routes that are configured for reception</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteDelete::LOOKUP_QUERY</code> as <code>b270142d-c897-4d1d-bddb-7641fbfb95a2</code> to identify a query used for looking up routes to delete</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteDelete::DELETE_QUERY</code> as <code>384f50ca-1e0a-464b-80fd-824fc83b87ca</code> to identify a query used for deleting routes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind::LOOKUP_QUERY</code> as <code>1f0d7c11-0d1c-4834-8b15-148d826d64e8</code> to identify a query used for looking up routes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteGet::FETCH_QUERY</code> as <code>24ab04cd-03f5-40c8-af25-715856281314</code> to identify a query used for reading route data</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::OVERVIEW_QUERY</code> as <code>6cb18ac6-6f5a-4d31-bed3-44849eb51f6f</code> to identify a query used for loading an overview page for routes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview::OVERVIEW_QUERY</code> as <code>329b4aa3-e576-4930-b89f-c63dca05c16e</code> to identify a query used for loading an overview page for route capabilities</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind::LOOKUP_QUERY</code> as <code>6c5db7b-004d-40c8-b9cc-53707aab658b</code> to identify a query used for looking up HTTP handler configurations</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeOverview::OVERVIEW_QUERY</code> as <code>478b14da-d0a8-44fd-bd1a-0a60ef948dd7</code> to identify a query used for loading an overview page for portal nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageDelete::DELETE_QUERY</code> as <code>40e42cd4-4ac3-4304-8cfc-9083d37e81cd</code> to identity query used for deleting portal node storage entries</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageDelete::DELETE_EXPIRED_QUERY</code> as <code>1972fcfd-5d64-4bce-a6b5-19cb6a8ad671</code> to identity query used for deleting expired portal node storage entries</li> <li>Add exception code <code>1646209690</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageDelete::delete</code> when writing to the database fails</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageClear::CLEAR_QUERY</code> as <code>1087e0dc-07fe-48d7-903c-9353167c3e89</code> to identity query used for deleting all portal node storage entries</li> <li>Add exception code <code>1646209691</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageClear::clear</code> when writing to the database fails</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageGet::FETCH_QUERY</code> as <code>679d6e76-bb9c-410d-ac22-17c64afcb7cc</code> to identity query used for reading portal node storage entries</li> <li>Add exception code <code>1646341933</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageSet::set</code> when writing to the database fails</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageSet::UPDATE_PREPARATION_QUERY</code> as <code>75fada39-34f0-4e03-b3b5-141da358181d</code> to identity query used for reading portal node storage entries to prepare update statements</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageList::FETCH_QUERY</code> as <code>7e532256-22d2-492e-8e76-ab1649ddc4e0</code> to identity query used for reading all portal node storage entries</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGet::FETCH_QUERY</code> as <code>be4a9934-2ab2-4c62-8a86-4600c96bc7be</code> to identify a query used for loading an overview page for portal nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect::LOOKUP_EXISTING_MAPPING_QUERY</code> as <code>64211df0-e928-4fc9-87c1-09a4c03cf98a</code> to identify a query used for looking up existing mappings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect::LOOKUP_EXISTING_MAPPING_NODE_QUERY</code> as <code>f6b0f467-0a73-4e1f-ad75-d669899df133</code> to identify a query used for looking up existing mapping nodes</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Id</code> as central utility for generation and converting UUIDs</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\DateTime</code> as central utility for converting dates from and into storage layer acceptable formats</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferenceGetRequestActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\FileReference\\FileReferenceGetRequestAction</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\FileReference\\FileReferenceGetRequestAction::FETCH_QUERY</code> as <code>25e53ac0-de53-4039-a790-253fb5803fec</code> to identity query used for fetching stored requests of file references</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\FileReference\\FileReferencePersistRequestActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\FileReference\\FileReferencePersistRequestAction</code></li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1645820922AddFileReferenceRequest</code> to create a table for stored requests of file references</li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\FileReferenceRequestStorageKey</code> as storage key for stored requests of file references</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFail::FIND_QUERY</code> as <code>9b00334a-cc0b-4017-a9dc-e2520a872064</code> to identity query used for reading job ids</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFail::UPDATE_QUERY</code> as <code>2d59f1a4-4baf-4cda-b762-16fb5beda452</code> to identity query used for updating job states</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFinish::FIND_QUERY</code> as <code>84e5495d-4733-4e8a-b775-aafba23daa8c</code> to identity query used for reading job ids</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobFinish::UPDATE_QUERY</code> as <code>393a0ae1-5f42-4a49-96a3-9a23c26e6bd2</code> to identity query used for updating job states</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobSchedule::FIND_QUERY</code> as <code>87c10b4f-3dcd-460d-ba04-b38acbad6cbe</code> to identity query used for reading job ids</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobSchedule::UPDATE_QUERY</code> as <code>72372e2f-6e02-470b-89d5-b65ee88024b5</code> to identity query used for updating job states</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobStart::FIND_QUERY</code> as <code>1bbfc5fe-756c-4171-b645-ad2a6c10f4e7</code> to identity query used for reading job ids</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Job\\JobStart::UPDATE_QUERY</code> as <code>0803daca-3ca7-44c4-a492-42cc51e46854</code> to identity query used for updating job states</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1643220550CreatePortalNodeAliasColumn</code> to add aliases to portal node and migrate them from <code>heptacom/heptaconnect-bridge-shopware-platform</code> if applicable</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalNodeAliasAccessor</code> to access portal node aliases in a cache manner</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalNodeAliasAccessor::ID_LOOKUP_QUERY</code> as <code>8f493191-2ba8-4c9f-b4ff-641fc1afdc56</code> to identify query used for looking up portal node ids by aliases</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalNodeAliasAccessor::ALIAS_LOOKUP_QUERY</code> as <code>81bd204c-97c0-4259-bf82-8b835f2f0237</code> to identify query used for looking up portal node aliases by ids</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasFindActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasFind</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasFind::FIND_QUERY</code> as <code>8ffc1022-c03b-4f3f-a2f6-5807710dbb6f</code> to identify query used for finding portal node ids by aliases</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasGetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasGet</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasGet::FETCH_QUERY</code> as <code>f3e31372-bc6b-444d-99ee-38b74f9cf9fc</code> to identify query used for finding portal node aliases by their ids</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasOverviewActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasOverview</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasOverview::OVERVIEW_QUERY</code> as <code>8467ced0-3575-410f-8155-e36e7e8f0e0b</code> to identify query used for loading an overview page for portal node aliases</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\PortalNodeAlias\\PortalNodeAliasSetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasSet</code></li> <li>Add exception code <code>1647941560</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasOverview::overview</code> when the criteria has an invalid sorting option</li> <li>Add exception code <code>1645446078</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasSet::set</code> when the payload has an invalid portal node key</li> <li>Add exception code <code>1645446809</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasSet::set</code> when the payload has an empty alias</li> <li>Add exception code <code>1645446810</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasSet::set</code> when the payload has an already used alias</li> <li>Add exception code <code>1645448849</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeAlias\\PortalNodeAliasSet::set</code> when writing to the database fails</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#changed_2","title":"Changed","text":"<ul> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\ReceptionRouteList</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\ReceptionRouteListActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteOverviewActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteFindActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteGet</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteGetActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\RouteCreateActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\RouteCapabilityOverviewActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFindActionInterface</code></li> <li>Change interface of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetActionInterface</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSetActionInterface</code></li> <li>Rename <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityMapper</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityMap</code> and implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityMapActionInterface</code></li> <li>Rename <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect</code> and implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityReflectActionInterface</code></li> <li>Rename <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\MappingPersister\\MappingPersister</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityPersist</code> and implement <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Identity\\IdentityPersistActionInterface</code></li> <li>Remove exception code <code>1637467903</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview::overview</code> expect exception code <code>1645901521</code> instead</li> <li>Remove exception code <code>1637467906</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind::find</code> expect exception code <code>1645901521</code> instead</li> <li>Move exception code <code>1637467900</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::doIterate</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::getExecuteStatement</code> that is used as central point for this exception to happen</li> <li>Remove exception code <code>1637467905</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::overview</code> expect exception code <code>1637467900</code> instead</li> <li>Remove exception code <code>1637542091</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind::find</code> expect exception code <code>1645901522</code> instead</li> <li>Remove exception code <code>1637467901</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\RouteCapabilityAccessor::getIdsForNames</code> expect exception code <code>1637467900</code> instead</li> <li>Remove exception code <code>1637467899</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor::getIdsForHandlers</code> expect exception code <code>1637467900</code> instead</li> <li>Remove exception code <code>1637467898</code> from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor::getIdsForPaths</code> expect exception code <code>1637467900</code> instead</li> <li>Change dependency in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\RouteCapabilityAccessor</code> from <code>\\Doctrine\\DBAL\\Connection</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryFactory</code></li> <li>Add dependency <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryFactory</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor</code></li> <li>Add dependency <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryFactory</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor</code></li> <li>Rename <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\MappingExceptionStorageKey</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\IdentityErrorStorageKey</code></li> <li>Add dependency <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalNodeAliasAccessor</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code> to support alias storage key serialization and deserialization</li> <li>Use <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\AliasAwarePortalNodeStorageKey</code> as alias aware implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\PortalNodeStorageKey</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#removed","title":"Removed","text":"<ul> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Job</code> as base contract has been removed</li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobPayloadRepository</code> as base contract has been removed</li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobRepository</code> as base contract has been removed</li> <li>Remove class <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\JobPayloadStorageKey</code> as base contract has been removed and its support in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepositoryContract::read</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeGet::get</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepositoryContract::listAll</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeList::list</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepositoryContract::listByClass</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeOverview::overview</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepositoryContract::create</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeCreate::create</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepositoryContract::create</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNode\\PortalNodeDelete::delete</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ConfigurationStorage::getConfiguration</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationGet::get</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ConfigurationStorage::setConfiguration</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeConfiguration\\PortalNodeConfigurationSet::set</code> that allows for optimizations for different use-cases</li> <li>Remove previously deprecated <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\CronjobStorageKey</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\CronjobRunStorageKey</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRepository</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRunRepository</code> as the feature of cronjobs in its current implementation is removed</li> <li>Remove previously deprecated <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunEntity</code> as the feature of cronjobs in its current implementation is removed</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1642885343RemoveCronjobAndCronjobRunTable</code> to remove the tables <code>heptaconnect_cronjob</code> and <code>heptaconnect_cronjob_run</code> as the feature of cronjobs in its current implementation is removed</li> <li>Replace dependencies in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor</code> from <code>\\Shopware\\Core\\Framework\\DataAbstractionLayer\\EntityRepositoryInterface</code> to <code>\\Doctrine\\DBAL\\Connection</code> to drop Shopware DAL usage</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listByNodes</code> from removed contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listByNodes</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listUnsavedExternalIds</code> from removed contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::listUnsavedExternalIds</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::updateExternalId</code> from removed contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract::updateExternalId</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalId</code> from removed contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::listByTypeAndPortalNodeAndExternalId</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::create</code> from removed contract <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingNodeRepositoryContract::create</code></li> <li>Remove deprecated <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteEntity</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteCollection</code></li> <li>Integrate <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ResourceLockStorage</code> into <code>heptacom/heptaconnect-core</code> as <code>\\Heptacom\\HeptaConnect\\Core\\Parallelization\\ResourceLockStorage</code></li> <li>Remove unused composer dependency <code>symfony/lock: &gt;=4</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::unset</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::deleteMultiple</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageDelete::delete</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::clear</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageClear::clear</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getValue</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::has</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getMultiple</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageGet::get</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::set</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageSet::set</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::list</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalNodeStorage\\PortalNodeStorageList::list</code> that allows for optimizations for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository</code> as base contract has been removed</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingExceptionRepository</code> as base contract has been removed</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository</code> as base contract has been removed</li> <li>Remove unused trait <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\EntityRepositoryChecksTrait</code> as all using implementations have been removed</li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\DalAccess</code></li> <li>Remove deprecated <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobPayloadCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobPayloadDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobPayloadEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobTypeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobTypeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Job\\JobTypeEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingErrorMessageCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingErrorMessageDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingErrorMessageEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingNodeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingNodeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingNodeEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeStorageCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeStorageDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\PortalNode\\PortalNodeStorageEntity</code></li> <li>Remove unused <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ContextFactory</code></li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator::generateKeys</code> as interface <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\StorageKeyGeneratorContract::generateKey</code> is removed</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\MappingStorageKey</code> as base contract has been removed</li> <li>Remove support for <code>doctrine/dbal: &gt;=2.1 &lt;2.11</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#085-2022-02-01","title":"[0.8.5] - 2022-02-01","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_8","title":"Fixed","text":"<ul> <li>Reset array keys after merging mapping nodes in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\MappingPersister\\MappingPersister</code> to avoid InvalidArgumentException <code>Expected input to be non associative array.</code> to get thrown by <code>\\Shopware\\Core\\Framework\\DataAbstractionLayer\\Write\\EntityWriter</code>.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#084-2022-01-22","title":"[0.8.4] - 2022-01-22","text":""},{"location":"releases/changelog-storage-shopware-dal/#added_3","title":"Added","text":"<ul> <li>The <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\MappingPersister\\MappingPersister</code> will now attempt to merge mapping-nodes when there are no conflicts. Now mappings can be integrated into an existing mapping-node during a reception.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#083-2022-01-05","title":"[0.8.3] - 2022-01-05","text":""},{"location":"releases/changelog-storage-shopware-dal/#changed_3","title":"Changed","text":"<ul> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1641403938AddChecksumIndexToJobPayloadTable</code> to add index to <code>checksum</code> to table <code>heptaconnect_job_payload</code> for improved listings and searches</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#082-2021-12-30","title":"[0.8.2] - 2021-12-30","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_9","title":"Fixed","text":"<ul> <li>Use target portal node key in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind</code> to query the target portal node instead of using the source portal node key</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#081-2021-11-22","title":"[0.8.1] - 2021-11-22","text":""},{"location":"releases/changelog-storage-shopware-dal/#fixed_10","title":"Fixed","text":"<ul> <li>Replace exception code <code>1637467902</code> with <code>1637542091</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind::find</code> when query execution could not return a ResultStatement</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#080-2021-11-22","title":"[0.8.0] - 2021-11-22","text":""},{"location":"releases/changelog-storage-shopware-dal/#added_4","title":"Added","text":"<ul> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1632763825RenameDatasetEntityTypeTable</code> to rename database table <code>heptaconnect_dataset_entity_type</code> to <code>heptaconnect_entity_type</code></li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1629643769AddJobStartAndFinishFields</code> to add <code>started_at</code> and <code>finished_at</code> datetime columns into table <code>heptaconnect_job</code> for job processing tracking</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobRepository::start</code> to implement new <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::start</code> for tracking the start of job processing</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobRepository::finish</code> to implement new <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::finish</code> for tracking the stop of job processing</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobRepository::cleanup</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobPayloadRepository::cleanup</code> to implement new <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobRepositoryContract::cleanup</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\JobPayloadRepositoryContract::cleanup</code> for cleaning up executed jobs and their payloads</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019143EntityTypeIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code> and <code>updated_at</code> to table <code>heptaconnect_entity_type</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019144JobIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code> and <code>updated_at</code> to table <code>heptaconnect_job</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019145JobIndexNewHappenedAtColumns</code> to add descending indices to <code>started_at</code> and <code>finished_at</code> to table <code>heptaconnect_job</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019146JobPayloadIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code> and <code>updated_at</code> to table <code>heptaconnect_job_payload</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019147JobTypeIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code> and <code>updated_at</code> to table <code>heptaconnect_job_type</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019148MappingIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code>, <code>updated_at</code> and <code>deleted_at</code> to table <code>heptaconnect_mapping</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019149MappingErrorMessageIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code> and <code>updated_at</code> to table <code>heptaconnect_mapping_error_message</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019150MappingNodeIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code>, <code>updated_at</code> and <code>deleted_at</code> to table <code>heptaconnect_mapping_node</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019151PortalNodeIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code>, <code>updated_at</code> and <code>deleted_at</code> to table <code>heptaconnect_portal_node</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019152PortalNodeStorageIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code>, <code>updated_at</code> and <code>deleted_at</code> to table <code>heptaconnect_portal_node_storage</code> for improved listings and searches</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635019153RouteIndexHappenedAtColumns</code> to add descending indices to <code>created_at</code>, <code>updated_at</code> and <code>deleted_at</code> to table <code>heptaconnect_route</code> for improved listings and searches</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Listing\\ReceptionRouteListActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\ReceptionRouteList</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Overview\\RouteOverviewActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Find\\RouteFindActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Get\\RouteGetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteGet</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\Route\\Create\\RouteCreateActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator</code> to simplify DBAL paginated iteration</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635512814OnDeleteCascadeFromMappingNodeToMapping</code> to cascade delete from <code>heptaconnect_mapping_node</code> to <code>heptaconnect_mapping</code></li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635713039CreateRouteCapabilityTable</code> to create database table <code>heptaconnect_route_capability</code> to store route capability types</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635713040SeedReceptionRouteCapability</code> to add the reception capability type</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635713041CreateRouteToRouteCapabilityTable</code> to create database table <code>heptaconnect_route_has_capability</code> to connect routes to their capabilities</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1635713042SeedReceptionCapabilityToRoute</code> to add every capability type to every route</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\RouteCapability\\Overview\\RouteCapabilityOverviewActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview</code></li> <li>Add custom <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryBuilder</code> based upon <code>\\Doctrine\\DBAL\\Query\\QueryBuilder</code> for parameterized pagination for easier SQL statement caching</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\RouteCapabilityAccessor</code> to read route capabilities efficiently for other internal operations</li> <li>Add exception code <code>1636505518</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::overview</code> when the criteria has an invalid sorting option</li> <li>Add exception code <code>1636505519</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview::overview</code> when the criteria has an invalid sorting option</li> <li>Add exception code <code>1636573803</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> when the payload refers to a source portal node with an invalid portal node</li> <li>Add exception code <code>1636573804</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> when the payload refers to a target portal node with an invalid portal node</li> <li>Add exception code <code>1636573805</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> when the payload refers to an unknown route capability</li> <li>Add exception code <code>1636573806</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> when the payload refers to an unknown entity type</li> <li>Add exception code <code>1636573807</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> when the key generator cannot generate a valid route key</li> <li>Add exception code <code>1636576240</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> when writing to the database fails</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1636817108CreateWebHttpHandlerPathTable</code> to create table <code>heptaconnect_web_http_handler_path</code> to hold indexed HTTP handler paths</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1636817109CreateWebHttpHandlerTable</code> to create table <code>heptaconnect_web_http_handler</code> to hold HTTP handlers based upon their portal nodes and paths</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1636817110CreateWebHttpHandlerConfigurationTable</code> to create table <code>heptaconnect_web_http_handler_configuration</code> to hold HTTP handler configurations</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor</code> to read and insert HTTP handler entries efficiently for other internal operations</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor</code> to read and insert HTTP handler paths entries efficiently for other internal operations</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathIdResolver</code> to centralize path id prediction</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet</code></li> <li>Add exception code <code>1636827821</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet::set</code> when the payload refers to an invalid portal node</li> <li>Add exception code <code>1636827822</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet::set</code> when the payload refers to an HTTP handler path that could not be looked up or created</li> <li>Add exception code <code>1636827823</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet::set</code> when the payload refers to an HTTP handler by path and portal node that could not be looked up or created</li> <li>Add exception code <code>1636827824</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationSet::set</code> when writing to the database fails</li> <li>Add exception code <code>1637467897</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor::getIdsForPaths</code> when <code>\\array_combine</code> returns false</li> <li>Add exception code <code>1636528918</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::overview</code> when the criteria has an invalid sorting option</li> <li>Add exception code <code>1637467898</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerPathAccessor::getIdsForPaths</code> when query execution could not return a Statement</li> <li>Add exception code <code>1637467899</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\WebHttpHandlerAccessor::getIdsForHandlers</code> when query execution could not return a Statement</li> <li>Add exception code <code>1637467900</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Support\\Query\\QueryIterator::doIterate</code> when query execution could not return a ResultStatement</li> <li>Add exception code <code>1637467901</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\RouteCapabilityAccessor::getIdsForNames</code> when query execution could not return a ResultStatement</li> <li>Add exception code <code>1637467902</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\WebHttpHandlerConfiguration\\WebHttpHandlerConfigurationFind::find</code> when query execution could not return a Statement</li> <li>Add exception code <code>1637467903</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\RouteCapability\\RouteCapabilityOverview::overview</code> when query execution could not return a ResultStatement</li> <li>Add exception code <code>1637467905</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::overview</code> when query execution could not return a ResultStatement</li> <li>Add exception code <code>1637467906</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind::find</code> when query execution could not return a ResultStatement</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#changed_4","title":"Changed","text":"<ul> <li>Change namespace from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\DatasetEntityType</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType</code> and rename folder appropriately</li> <li>Change class name from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\DatasetEntityTypeDefinition</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeDefinition</code></li> <li>Change class name from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\DatasetEntityTypeCollection</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeCollection</code></li> <li>Change class name from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\DatasetEntityTypeEntity</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\EntityType\\EntityTypeEntity</code></li> <li>Change class name from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\DatasetEntityTypeAccessor</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingNodeEntity::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingNodeEntity::getEntityType</code></li> <li>Change method name from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingEntity::getDatasetEntityClassName</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Mapping\\MappingEntity::getEntityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listByPortalNodeAndType</code> from <code>$datasetEntityType</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityTypeAccessor::getIdsForTypes</code> from <code>$datasetEntityClassNames</code> to <code>$entityTypes</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalId</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalIds</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::create</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::createList</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> <li>Change parameter name of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listUnsavedExternalIds</code> from <code>$datasetEntityClassName</code> to <code>$entityType</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#deprecated","title":"Deprecated","text":"<ul> <li>Mark <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteEntity</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Route\\RouteCollection</code> as deprecated as DAL usage is discouraged</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#removed_1","title":"Removed","text":"<ul> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\RouteRepository::listBySourceAndEntityType</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\ReceptionRouteList::list</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::overview</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteFind::find</code> that are optimized for different use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\RouteRepository::read</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteGet::get</code> that is optimized for known use-cases</li> <li>Remove implementation <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\RouteRepository::create</code> in favour of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteCreate::create</code> that is optimized for known use-cases</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookDefinition</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookEntity</code> in favour of a storage independent solution</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\WebhookRepository</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\WebhookStorageKey</code> in favour of a storage independent solution</li> <li>Remove support for <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\WebhookStorageKey</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKeyGenerator</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1636704625RemoveWebhookTable</code> to drop the <code>heptaconnect_webhook</code> table</li> <li>Remove support for <code>shopware/core: 6.2.*</code></li> <li>Remove configuration merging from <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ConfigurationStorage::setConfiguration</code> which is already done by the core package</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#fixed_11","title":"Fixed","text":"<ul> <li>Change <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingExceptionRepository::create</code> so it includes a check for the success of <code>\\json_encode</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#070-2021-09-25","title":"[0.7.0] - 2021-09-25","text":""},{"location":"releases/changelog-storage-shopware-dal/#added_5","title":"Added","text":"<ul> <li>Add support for composer dependency <code>ramsey/uuid: 4.*</code></li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\PortalStorageContract</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::clear</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getMultiple</code> and  <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::deleteMultiple</code> to allow PSR simple cache compatibility</li> <li>New service <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\MappingPersister</code> responsible for saving mappings after reception. Could improve usages of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Repository\\MappingRepositoryContract</code>.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#changed_5","title":"Changed","text":"<ul> <li>Improve performance of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityMapper::mapEntities</code></li> <li>Improve performance of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector::reflectEntities</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#fixed_12","title":"Fixed","text":"<ul> <li>Change string comparison on database layer from whitespace-unaware, case-insensitive to binary for jobs, job payloads, mappings, portal nodes, portal node storage, data entity class names so lookups are one-to-one which therefore affects behaviour <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobPayloadRepository::add</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobRepository::add</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalId</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalIds</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::create</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::createList</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listByPortalNodeAndType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listUnsavedExternalIds</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::updateExternalId</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepository::listByClass</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\PortalNodeRepository::create</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\RouteRepository::listBySourceAndEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\RouteRepository::create</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\DatasetEntityTypeAccessor::getIdsForTypes</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityMapper::mapEntities</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector::reflectEntities</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::set</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::unset</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getValue</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::has</code></li> <li>Disable HTML stripping from string columns in DAL for jobs, mappings and portal node storage so storing data will allow <code>&lt;&gt;</code> symbols which therefore affects behaviour <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\JobRepository::add</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalId</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingNodeRepository::listByTypeAndPortalNodeAndExternalIds</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listByPortalNodeAndType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::listUnsavedExternalIds</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\MappingRepository::updateExternalId</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityMapper::mapEntities</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector::reflectEntities</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::set</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::unset</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getValue</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::getType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\PortalStorage::has</code></li> <li><code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityMapper</code> now respects soft-deletions of mappings and mapping nodes.</li> <li><code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector</code> now respects soft-deletions of mappings and mapping nodes.</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#050-2021-07-11","title":"[0.5.0] - 2021-07-11","text":""},{"location":"releases/changelog-storage-shopware-dal/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecate cronjobs to allow for new implementation at different point in time and with it <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Cronjob\\CronjobRunEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRepository</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\CronjobRunRepository</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\CronjobStorageKey</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\CronjobRunStorageKey</code></li> <li>Deprecate webhooks to allow for new implementation at different point in time and with it <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookCollection</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookDefinition</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Content\\Webhook\\WebhookEntity</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Repository\\WebhookRepository</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\StorageKey\\WebhookStorageKey</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#fixed_13","title":"Fixed","text":"<ul> <li>Fix bug and improved performance on entity reflection in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector::reflectEntities</code> when empty entity collection has been passed in</li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#040-2021-07-03","title":"[0.4.0] - 2021-07-03","text":""},{"location":"releases/changelog-storage-shopware-dal/#added_6","title":"Added","text":"<ul> <li>Add support for preview portal node keys <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PreviewPortalNodeKey</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\ConfigurationStorage::getConfiguration</code></li> </ul>"},{"location":"releases/changelog-storage-shopware-dal/#changed_6","title":"Changed","text":"<ul> <li>Improve performance of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityMapper::mapEntities</code> by restructuring database queries</li> <li>Improve performance of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\EntityReflector::reflectEntities</code> by restructuring database queries</li> </ul>"},{"location":"releases/upcoming/","title":"Upcoming Changes","text":"<p>Here is an overview of all changes, that are about to be released. Missing content you've previously seen here? Then it has been released. Check out the documentation search or browse the other changelogs.</p>"},{"location":"releases/upcoming/#bridge-shopware-platform","title":"Bridge Shopware Platform","text":""},{"location":"releases/upcoming/#added","title":"Added","text":"<ul> <li>Add composer dependency <code>heptacom/heptaconnect-ui-admin-symfony: ^0.9</code> to provide CLI commands</li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\PrimaryKeyToEntityHydrator</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackProcessor</code> as <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmissionFlowEmittersFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionFlowEmittersFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackProcessor</code> as <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackProcessorInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmissionFlowEmittersFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\DirectEmissionFlowEmittersFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationFlowExplorersFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationFlowExplorersFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionFlowReceiversFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionFlowReceiversFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleFlowHttpHandlersFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleFlowHttpHandlersFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\EmittedEntitiesToReceiveJobsConverter</code> as <code>Heptacom\\HeptaConnect\\Core\\Job\\Transition\\Contract\\EmittedEntitiesToJobsConverterInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\ExploredPrimaryKeysToEmissionJobsConverter</code> as <code>Heptacom\\HeptaConnect\\Core\\Job\\Transition\\Contract\\ExploredPrimaryKeysToJobsConverterInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PackageQueryMatcher</code> as <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PackageQueryMatcherInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationProcessorService</code> as <code>Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\PortalNodeConfigurationProcessorServiceInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditableDataSerializer</code> as <code>Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\Contract\\AuditTrailDataSerializerInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrailFactory</code> as <code>Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\Contract\\AuditTrailFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeAliasResolver</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Support\\PortalNodeAliasResolverInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeExistenceSeparator</code> as <code>Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\Contract\\PortalNodeExistenceSeparatorInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Support\\StorageKeyAccessorInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\Context\\UiActionContextFactory</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\UiActionContextFactoryInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobRunUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Job\\JobRunUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobScheduleUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Job\\JobScheduleUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalEntityListUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Portal\\PortalEntityListUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeConfigurationGetUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeConfigurationGetUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeConfigurationRenderUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeConfigurationRenderUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeEntityListUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeEntityListUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionBrowseUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeExtensionBrowseUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStatusReportUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeStatusReportUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionActivateUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeExtensionActivateUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionDeactivateUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeExtensionDeactivateUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeAddUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeAddUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeRemoveUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeRemoveUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStorageGetUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeStorageGetUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteAddUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\RouteAddUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteAddUiDefault</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Route\\RouteAddUiDefaultProviderInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteBrowseUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Route\\RouteBrowseUiActionInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteRemoveUi</code> as <code>Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Route\\RouteRemoveUiActionInterface</code></li> <li>Add service container parameter <code>heptacom_heptaconnect.emission_flow.job_dispatch_batch_size</code> to influence batch size parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmissionFlowEmittersFactory</code></li> <li>Add service container parameter <code>heptacom_heptaconnect.direct_emission_flow.identity_batch_size</code> to influence batch size parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmissionFlowEmittersFactory</code></li> <li>Add service container parameter <code>heptacom_heptaconnect.exploration.job_batch_size</code> to influence batch size parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationFlowExplorersFactory</code></li> <li>Add service container parameter <code>heptacom_heptaconnect.exploration.identity_batch_size</code> to influence batch size parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationFlowExplorersFactory</code></li> <li>Add service container parameter <code>heptacom_heptaconnect.exploration.direct_emission_batch_size</code> to influence batch size parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationFlowExplorersFactory</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailBeginActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailEndActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogErrorActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogOutputActionInterface</code> provided by <code>Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\RequestDeserializer</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestDeserializerInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\RequestSerializer</code> as <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestSerializerInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\PortalNodeStorageItemPacker</code> as <code>Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\Contract\\PortalNodeStorageItemPackerInterface</code></li> <li>Add service definition based upon class <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\PortalNodeStorageItemUnpacker</code> as <code>Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\Contract\\PortalNodeStorageItemUnpackerInterface</code></li> <li>The base-url can now be controlled via an environment variable <code>APP_URL</code>. If set, the environment variable will take precedence over the value from the database.</li> </ul>"},{"location":"releases/upcoming/#changed","title":"Changed","text":"<ul> <li>Switch parameter in <code>Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationInstructionProcessor</code> from <code>Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\StorageKeyGeneratorContract</code> to <code>Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PackageQueryMatcherInterface</code></li> <li>Switch parameter in <code>Heptacom\\HeptaConnect\\Portal\\Base\\Flow\\DirectEmission\\DirectEmissionFlowContract</code> from <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> to <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\DirectEmissionFlowEmittersFactoryInterface</code> and <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code></li> <li>Switch parameter in <code>Heptacom\\HeptaConnect\\Core\\Emission\\EmitService</code> from <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> to <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionFlowEmittersFactoryInterface</code> and <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code></li> <li>Switch parameter in <code>Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreService</code> from <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> to <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationFlowExplorersFactoryInterface</code> and <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackProcessorInterface</code></li> <li>Switch parameter in <code>Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorageFactory</code> from <code>Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\NormalizationRegistryContract</code> to <code>Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\Contract\\PortalNodeStorageItemPackerInterface</code> and <code>Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\Contract\\PortalNodeStorageItemUnpackerInterface</code></li> <li>Rename service <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionActorInterface</code> to <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiverStackProcessorInterface</code> to match class and interface rename</li> <li>Rename service <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlingActorInterface</code> to <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerStackProcessorInterface</code> to match class and interface rename</li> <li>Add parameter of <code>Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionFlowReceiversFactoryInterface</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService</code></li> <li>Add parameter of <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleFlowHttpHandlersFactoryInterface</code> to service definition <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleServiceInterface</code></li> <li>Remove command <code>heptaconnect:job:run</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Job\\Run</code> in favour of <code>job:run</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:portal-node:extensions:list</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Extension\\ListExtensions</code> in favour of <code>portal:node:extension:browse</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:portal-node:status:report</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\ReportPortalNode</code> in favour of <code>portal:node:status:report</code> and <code>portal:node:healthy</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:portal-node:extensions:activate</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Extension\\ActivateExtension</code> in favour of <code>portal:node:extension:activate</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:portal-node:extensions:deactivate</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\Extension\\DeactivateExtension</code> in favour of <code>portal:node:extension:deactivate</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:portal-node:add</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\PortalNode\\AddPortalNode</code> in favour of <code>portal:node:add</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:router:add-route</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\AddRoute</code> in favour of <code>route:add</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove command <code>heptaconnect:router:remove-route</code> from <code>Heptacom\\HeptaConnect\\Bridge\\ShopwarePlatform\\Command\\Router\\RemoveRoute</code> in favour of <code>route:remove</code> shipped with composer dependency <code>heptacom/heptaconnect-ui-admin-symfony</code></li> <li>Remove <code>heptacom_heptaconnect.logger</code> dependency from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code></li> <li>Switch parameter in <code>Heptacom\\HeptaConnect\\Core\\Storage\\Contract\\RequestStorageContract</code> from <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestNormalizer</code> and <code>Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestDenormalizer</code> to <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestSerializerInterface</code> and <code>Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestDeserializerInterface</code></li> <li>Extract dependency <code>tagged: heptaconnect_core.portal_node_configuration.processor</code> from <code>Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\ConfigurationServiceInterface</code> into own service <code>Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\PortalNodeConfigurationProcessorServiceInterface</code></li> </ul>"},{"location":"releases/upcoming/#deprecated","title":"Deprecated","text":"<ul> <li>Service definition <code>Heptacom\\HeptaConnect\\Core\\Storage\\PrimaryKeyToEntityHydrator</code> is deprecated as the class itself is also deprecated and will be removed in future major version</li> </ul>"},{"location":"releases/upcoming/#removed","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> as <code>Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code> is preferred</li> <li>Remove service definition <code>Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor</code> as <code>Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackProcessorInterface</code> is preferred</li> </ul> <p>Read the already released Bridge Shopware Platform changelog</p>"},{"location":"releases/upcoming/#core","title":"Core","text":""},{"location":"releases/upcoming/#added_1","title":"Added","text":"<ul> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack</code> out of <code>heptaconnect/portal-base</code> into this package as <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStack</code></li> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerStack</code> out of <code>heptaconnect/portal-base</code> into this package as <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStack</code></li> <li>Add <code>$entityType</code> parameter to <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStack::__construct</code> to implement new <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerStackInterface::supports</code></li> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverStack</code> out of <code>heptaconnect/portal-base</code> into this package as <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStack</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\EmittedEntitiesToReceiveJobsConverter</code> and its interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\Contract\\EmittedEntitiesToJobsConverterInterface</code> to convert results of an emission into receive jobs</li> <li>Add log message code <code>1661091900</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\EmittedEntitiesToReceiveJobsConverter::convert</code> when conversion resulted in no jobs, which can be ok, but is important to know, when looking into failing transfer</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\ExploredPrimaryKeysToEmissionJobsConverter</code> and its interface <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\Contract\\ExploredPrimaryKeysToJobsConverterInterface</code> to convert results of an exploration into emission jobs</li> <li>Add log message code <code>1661091901</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Job\\Transition\\ExploredPrimaryKeysToEmissionJobsConverter::convert</code> when conversion resulted in no jobs, which can be ok, but is important to know, when looking into failing transfer</li> <li>Add log message code <code>1661818271</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\LockingReceiver</code> when unlocking of a lock failed</li> <li>Add log message code <code>1661818272</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\LockingReceiver</code> when even after retrying the reception could not be locked</li> <li>Add log message code <code>1662200022</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditableDataSerializer::serialize</code> when the auditable data object fails at exposing auditable data</li> <li>Add log message code <code>1662200023</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditableDataSerializer::serialize</code> when json_encode can not compose a JSON string</li> <li>Add log message code <code>1662200024</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditableDataSerializer::serialize</code> when auditable data throws an exception during serialization</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\PrimaryKeyToEntityHydrator</code> to create instances of entities with any primary key. This code is not useful for long and therefore does not receive an interface and is just an extraction refactoring of already existing code</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\ReceiveJobDispatchingEmitter</code> to dispatch receive jobs from any emission stack, where this emitter is pushed onto</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\AbstractBufferedResultProcessingExplorer</code> as base class for explorer, which capture stack processing and process the captured data in batches</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\AbstractBufferedResultProcessingEmitter</code> as base class for emitter, which capture stack processing and process the captured data in batches</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmissionFlowEmittersFactory</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionFlowEmittersFactoryInterface</code> to return emitters, that provide core functionality for the emission flow</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmissionFlowEmittersFactory</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\DirectEmissionFlowEmittersFactoryInterface</code> to return emitters, that provide core functionality for the direct emission flow</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationFlowExplorersFactory</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationFlowExplorersFactoryInterface</code> to return explorers, that provide core functionality for the exploration flow</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionFlowReceiversFactory</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionFlowReceiversFactoryInterface</code> to return receivers, that provide core functionality for the reception flow</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleFlowHttpHandlersFactory</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleFlowHttpHandlersFactoryInterface</code> to return HTTP handlers, that provide core functionality for the HTTP handle flow</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalNodeContainerFacade</code> and its contract <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalNodeContainerFacadeContract</code> to have a typed interface onto <code>\\Psr\\Container\\ContainerInterface</code></li> <li>Add exception code <code>1666461305</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalNodeContainerFacade::__construct</code> when the given container does not contain all necessary services, that explicitly are exposed by the facade</li> <li>Extract query matching from <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationInstructionProcessor</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PackageQueryMatcher</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PackageQueryMatcherInterface</code></li> <li>Add UI audit trail class to stateful log a UI actions behaviour described in <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\Contract\\AuditTrailInterface</code>, implemented in <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrail</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\NullAuditTrail</code> and factorized by <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrailFactory</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\Contract\\AuditTrailFactoryInterface</code></li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditableDataSerializer</code> described in <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\Contract\\AuditableDataSerializerInterface</code> to transform auditable data into a string for storing later</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeExistenceSeparator</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\Contract\\PortalNodeExistenceSeparatorInterface</code> with <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeExistenceSeparationResult</code> to split portal nodes into the groups: preview portal node keys, portal node keys found in the storage and those, which are missing</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\Context\\UiActionContext</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\UiActionContextInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\Context\\UiActionContextFactory</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\UiActionContextFactoryInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeAliasResolver</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Support\\PortalNodeAliasResolverInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Support\\StorageKeyAccessorInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobRunUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Job\\JobRunUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobScheduleUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Job\\JobScheduleUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalEntityListUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Portal\\PortalEntityListUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeEntityListUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeEntityListUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionBrowseUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeExtensionBrowseUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStatusReportUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeStatusReportUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionActivateUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeExtensionActivateUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionDeactivateUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeExtensionDeactivateUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStorageGetUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeStorageGetUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeAddUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeAddUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeRemoveUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeRemoveUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeConfigurationGetUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeConfigurationGetUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeConfigurationRenderUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\PortalNode\\PortalNodeConfigurationRenderUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteAddUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Route\\RouteAddUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteBrowseUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Route\\RouteBrowseUiActionInterface</code></li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteRemoveUi</code> for <code>\\Heptacom\\HeptaConnect\\Ui\\Admin\\Base\\Contract\\Action\\Route\\RouteRemoveUiActionInterface</code></li> <li>Add exception code <code>1655051115</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeAliasResolver::resolve</code> when resolving the give portal node alias has no result</li> <li>Add exception code <code>1650732001</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeExistenceSeparationResult::throwWhenKeysAreMissing</code> when a portal node key does not refer to a known portal node</li> <li>Add exception code <code>1650732002</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\PortalNodeExistenceSeparationResult::throwWhenPreviewKeysAreGiven</code> when a portal node key does not refer to a known portal node but a preview portal instead</li> <li>Add exception code <code>1660417907</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::deserialize</code> when the given storage key data is not compatible with the storage implementation</li> <li>Add exception code <code>1660417908</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::serialize</code> when the given storage key is not compatible with the storage implementation</li> <li>Add exception code <code>1660417909</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::exists</code> when the given storage key is not compatible with the storage implementation</li> <li>Add exception code <code>1660417910</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::exists</code> when the given storage key is not supported in existence checks</li> <li>Add exception code <code>1660417911</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::exists</code> when the given storage key existence check failed in the storage implementation</li> <li>Add exception code <code>1660417912</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::serialize</code> when serialization failed in the storage implementation</li> <li>Add exception code <code>1660417913</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Support\\StorageKeyAccessor::deserialize</code> when deserialization failed in the storage implementation</li> <li>Add exception code <code>1659721163</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobRunUi::run</code> when one of the given jobs are not found in the job storage</li> <li>Add exception code <code>1659721164</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobRunUi::run</code> when running the jobs fails at one point</li> <li>Add exception code <code>1677424700</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\JobScheduleUi::schedule</code> when one of the given jobs are not found in the job storage</li> <li>Add exception code <code>1663051795</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalEntityListUi::list</code> when reading entity support fails</li> <li>Add exception code <code>1650142326</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionActivateUi::activate</code> when the given query does not match any supporting portal extension</li> <li>Add exception code <code>1650142327</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionActivateUi::activate</code> when all matched portal extensions are already active on the portal node</li> <li>Add exception code <code>1650731999</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionDeactivateUi::deactivate</code> when the given query does not match any supporting portal extension</li> <li>Add exception code <code>1650732000</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeExtensionDeactivateUi::deactivate</code> when all matched portal extensions are already inactive on the portal node</li> <li>Add exception code <code>1673129100</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStorageGetUi::get</code> when looking up a portal node key failed in the storage implementation</li> <li>Add exception code <code>1673129102</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStorageGetUi::get</code> when a requested storage key is not a scalar value</li> <li>Add exception code <code>1673129103</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeStorageGetUi::get</code> when accessing data from the portal node storage failed</li> <li>Add exception code <code>1650718860</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeAddUi::add</code> when portal node alias validation fails due to a storage exception</li> <li>Add exception code <code>1650718861</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeAddUi::add</code> when the portal node alias is already taken</li> <li>Add exception code <code>1650718862</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeAddUi::add</code> when portal node creation fails due to a storage exception</li> <li>Add exception code <code>1650718863</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeAddUi::add</code> when portal node creation did not create a portal node</li> <li>Add exception code <code>1650758000</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeRemoveUi::remove</code> when reading known portal nodes from storage fails</li> <li>Add exception code <code>1650758002</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeRemoveUi::remove</code> when deleting portal nodes fails in storage</li> <li>Add exception code <code>1670832600</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeConfigurationGetUi::get</code> when reading portal nodes to validate their existence fails due to a storage exception</li> <li>Add exception code <code>1670832602</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\PortalNodeConfigurationGetUi::get</code> when reading portal node configuration fails due to a storage exception</li> <li>Add exception code <code>1654573095</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteAddUi::add</code> when one of the requested route payloads already exists</li> <li>Add exception code <code>1654573097</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteAddUi::add</code> when route creation did not create the expected routes</li> <li>Add exception code <code>1654573098</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteAddUi::add</code> when route creation fails due to a storage exception</li> <li>Add exception code <code>1670625000</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteBrowseUi::browse</code> when the given sorting direction is not supported</li> <li>Add exception code <code>1670625001</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteBrowseUi::browse</code> when the given field to sort by is not supported</li> <li>Add exception code <code>1659293800</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteRemoveUi::remove</code> when reading known routes from storage fails</li> <li>Add exception code <code>1659293801</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteRemoveUi::remove</code> when route that does not exist is tried to be deleted</li> <li>Add exception code <code>1659293802</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Action\\RouteRemoveUi::remove</code> when deleting routes fails in storage</li> <li>Add exception code <code>1663677420</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrailFactory::create</code> when starting an audit trail failed and a no-op trail is used instead</li> <li>Add exception code <code>1663677421</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrailFactory::create</code> when logging any output to an audit trail failed</li> <li>Add exception code <code>1663677422</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrailFactory::create</code> when logging any exception to an audit trail failed</li> <li>Add exception code <code>1663677423</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Ui\\Admin\\Audit\\AuditTrailFactory::create</code> when marking an audit trail as finished</li> <li>Extract deserialization logic of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestDenormalizer</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\RequestDeserializer</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestDeserializerInterface</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Exception\\RequestDeserializationException</code> to be explicitly used independent from <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\NormalizationRegistry</code></li> <li>Add exception code <code>1666451009</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\RequestDeserializer::deserialize</code> when the given request data is not valid JSON</li> <li>Extract serialization logic of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestNormalizer</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\RequestSerializer</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestSerializerInterface</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Exception\\RequestSerializationException</code> to be explicitly used independent from <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\NormalizationRegistry</code></li> <li>Add exception code <code>1666451010</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\RequestSerializer::serialize</code> when the given request cannot be serialized into JSON</li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerBuilder::PORTAL_CONFIGURATION_PARAMETER_PREFIX</code>, that is preceding a portal node configuration binding aliases</li> </ul>"},{"location":"releases/upcoming/#changed_1","title":"Changed","text":"<ul> <li>Argument of type <code>\\Psr\\Container\\ContainerInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\AbstractPortalNodeContext::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreContext::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContext::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveContext::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\StatusReporting\\StatusReportingContext::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleContext::__construct</code> is expected of type <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalNodeContainerFacadeContract</code> instead</li> <li>Return type of <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStackServiceContainerFactory::create</code> is now <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalNodeContainerFacadeContract</code> which inherits the previous return type</li> <li>Change <code>$entityType</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackBuilderFactoryInterface::createEmitterStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilder::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackBuilderFactory::createEmitterStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmitter::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface::performExploration</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorationActor::performExploration</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackBuilderFactoryInterface</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilder::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackBuilderFactory::createExplorerStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::setEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiverStackBuilderFactoryInterface::createReceiverStackBuilder</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilder::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackBuilderFactory::createReceiverStackBuilder</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Change <code>$dataTypes</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreService::explore</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreService::dispatchExploreJob</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExploreServiceInterface::explore</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExploreServiceInterface::dispatchExploreJob</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityTypeCollection</code> instead of an array of string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingNodeStruct::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Mapping\\MappingStruct::getEntityType</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable::getForeignEntityType</code> to be <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Update implementation <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\PrimaryKeyChangesAttachable</code> to match changes in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ForeignKeyAwareInterface</code></li> <li>Change <code>$class</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalFactoryContract::instantiatePortal</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalType</code> instead of a string for better type safe class strings</li> <li>Change <code>$class</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Contract\\PortalFactoryContract::instantiatePortalExtension</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionType</code> instead of a string for better type safe class strings</li> <li>Change <code>$emissionActor</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\DirectEmissionFlow\\DirectEmissionFlow::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code> and a <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\DirectEmissionFlowEmittersFactoryInterface</code> instead of a <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> to control the contents of the direct emission stack</li> <li>Change <code>$emissionActor</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitService::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code> and a <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionFlowEmittersFactoryInterface</code> instead of a <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> to control the contents of the emission stack</li> <li>Change <code>$explorationActor</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExploreService::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackProcessorInterface</code> and a <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationFlowExplorersFactoryInterface</code> instead of a <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> to control the contents of the exploration stack</li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> partially with stack processing service described in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmitterStackProcessorInterface</code>, that is implemented by <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStackProcessor</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\Contract\\EmissionActorInterface</code> partially with job dispatching from emitter stacks in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\ReceiveJobDispatchingEmitter</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> partially with stack processing service described in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorerStackProcessorInterface</code>, that is implemented by <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStackProcessor</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> partially with job dispatching from explorer stacks in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\EmissionJobDispatchingExplorer</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> partially with triggering emission stack processing for direct emission in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\DirectEmittingExplorer</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> partially with entities' identities existence ensuring explorer in <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\IdentityMappingExplorer</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\Contract\\ExplorationActorInterface</code> partially with entities' identities existence ensuring emitter for direct emission in <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\IdentityMappingEmitter</code></li> <li>Rename interface <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionActorInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceiverStackProcessorInterface</code> to match restructure of other flow components into same pattern</li> <li>Rename class <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceptionActor</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStackProcessor</code> to match restructure of other flow components into same pattern</li> <li>Rename interface <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlingActorInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerStackProcessorInterface</code> to match restructure of other flow components into same pattern</li> <li>Rename class <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlingActor</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackProcessor</code> to match restructure of other flow components into same pattern</li> <li>Add parameter of <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandleFlowHttpHandlersFactoryInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandleService</code> to extend HTTP handle flow by core HTTP handlers</li> <li>Add parameter of <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Contract\\ReceptionFlowReceiversFactoryInterface</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService</code> to extend reception flow by core receivers</li> <li>Extract reception locking and release from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiveService</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\LockingReceiver</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\Support\\LockAttachable</code></li> <li>Change composer dependency <code>composer/composer:&gt;=1.9</code> to <code>composer/composer:^2.2.6</code> to ensure <code>\\Composer\\Repository\\InstalledRepositoryInterface::getDevMode</code> exists and always support loading dev-packages</li> <li>Use <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestSerializerInterface</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\RequestDeserializerInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\RequestStorage</code> instead of <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestNormalizer</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\Psr7RequestDenormalizer</code> to allow for implementation change</li> <li>Add exception code <code>1647801830</code> in return callable from <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\PortalNodeConfigurationHelper::json</code> when the JSON file can not be read from the filesystem</li> <li>Add exception code <code>1637432096</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Storage\\Normalizer\\SerializableCompressNormalizer::normalize</code> when original normalized value is not a string</li> <li>Make classes final: <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfiguration</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Flow\\MessageQueueFlow\\MessageHandler</code></li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalNodeContextInterface::getLogger</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\AbstractPortalNodeContext::getLogger</code> by looking up the service in the container</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface</code> in <code>\\Heptacom\\HeptaConnect\\Core\\Component\\Composer\\PackageConfiguration</code></li> <li>Removed logger dependency from <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\PostProcessing\\MarkAsFailedPostProcessor</code></li> <li>Replace union type hints to real union types in <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config::replace</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config::merge</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Bridge\\PortalNode\\Configuration\\Config::set</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\AbstractBufferedResultProcessingExplorer::pushBuffer</code></li> <li>Split <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AddPortalConfigurationBindingsCompilerPass</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\AddConfigurationBindingsCompilerPass</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\ServiceContainerCompilerPass\\SetConfigurationAsParameterCompilerPass</code> to separate parameter assignment and generating name bindings</li> <li>Extract processing of portal node configuration processors from <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\ConfigurationService</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\PortalNodeConfigurationProcessorService</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Configuration\\Contract\\PortalNodeConfigurationProcessorServiceInterface</code></li> <li>Change composer dependency <code>symfony/dependency-injection: ^4.4 || ^5.0</code> to <code>symfony/dependency-injection: ^4.4.11 || ^5.0</code> to ensure auto wiring works with PHP 8 union types</li> <li>Extract packing and unpacking storage related structs from <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code> into <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\PortalNodeStorageItemPacker</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\Contract\\PortalNodeStorageItemPackerInterface</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\PortalNodeStorageItemUnpacker</code> described by <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\Contract\\PortalNodeStorageItemUnpackerInterface</code> and with it moving the dependency <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\NormalizationRegistryContract</code></li> <li>Move log message codes <code>1631562097</code>, <code>1631562285</code> and <code>1631562928</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\PortalNodeStorageItemPacker</code> without change in meaning</li> <li>Move log message codes <code>1651338621</code> and <code>1631565257</code> from <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\PortalStorage</code> to <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Storage\\PortalNodeStorageItemUnpacker</code> without change in meaning</li> <li>Make <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::__construct</code> final as packages are stateless</li> <li>Combine <code>portalNodeKey</code> and <code>path</code> parameter in <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\Contract\\HttpHandlerStackBuilderFactoryInterface::createHttpHandlerStackBuilder</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Web\\Http\\HttpHandlerStackBuilderFactory::createHttpHandlerStackBuilder</code> using <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code></li> </ul>"},{"location":"releases/upcoming/#removed_1","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> <li>Remove composer dependency <code>symfony/polyfill-php80</code> as minimum PHP version is raised to PHP 8.0</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Exception\\UnexpectedClassInheritanceOnInstantionException</code> and <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Exception\\ClassNotFoundOnInstantionException</code> as their condition origin will occur earlier related to either <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\InvalidClassNameException</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\InvalidSubtypeClassNameException</code> or <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\UnexpectedLeadingNamespaceSeparatorInClassNameException</code> will be thrown instead</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Exception\\DelegatingLoaderLoadException</code> as <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Exception\\DelegatingLoaderLoadException</code> will be thrown instead</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Core\\Portal\\Exception\\UnexpectedRequiredParameterInConstructorOnInstantionException</code> as <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract::__construct</code> is final and therefore has no unexpected parameters</li> </ul> <p>Read the already released Core changelog</p>"},{"location":"releases/upcoming/#dataset-base","title":"Dataset Base","text":""},{"location":"releases/upcoming/#added_2","title":"Added","text":"<ul> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\UnsafeClassString</code> based on class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code> with <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ClassStringReferenceCollection</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractClassStringReferenceCollection</code> to have a string references, that could be a class-string for better type safe class strings</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringContract</code> to have a type safe way to make class string references for better type safe class strings</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\SubtypeClassStringContract</code> to have a type safe way to make class string references that are of a subtype for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> with <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityTypeCollection</code> as a type safe subtype class reference to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DatasetEntityContract::class</code> as factory method to create an instance of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\InvalidClassNameException</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\InvalidSubtypeClassNameException</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\UnexpectedLeadingNamespaceSeparatorInClassNameException</code> to reference class-string issues for better type safe class strings</li> <li>Add exception code <code>1655559294</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringContract::__construct</code> when the given class string has a leading namespace separator</li> <li>Add exception code <code>1655559295</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringContract::__construct</code> when the given class string does not refer to an existing class or interface</li> <li>Add exception code <code>1655559296</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\SubtypeClassStringContract::__construct</code> when the given class string is not of the expected type</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::withoutItems</code> from implementation into the interface <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::withoutItems</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::chunk</code> from implementation into the interface <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::chunk</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::asArray</code> from implementation into the interface <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::asArray</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::reverse</code> from implementation into the interface <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::reverse</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::isEmpty</code> from implementation into the interface <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::isEmpty</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::contains</code> to check whether the given item is in the collection</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::containsByEqualsCheck</code> for any extending class to build alternative contains implementations based upon comparison</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::asUnique</code> to build a collection with items that are not identical to the other items in the collection</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::pushIgnoreInvalidItems</code> as alternative to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::push</code> to push items into collections, without exceptions on invalid items</li> <li>Add <code>\\InvalidArgumentException</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection</code> using the new method <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::validateItems</code> when items are added, that are not compliant with the collection's validation</li> <li>Add <code>\\InvalidArgumentException</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::offsetGet</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::offsetSet</code> when items are accessed with keys, that are not numeric</li> </ul>"},{"location":"releases/upcoming/#changed_2","title":"Changed","text":"<ul> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ForeignKeyAwareInterface::getForeignEntityType</code> from <code>class-string</code> to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> to improve type safety for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::filter</code> from <code>Generator</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::filterValid</code> from <code>Generator</code> to <code>iterable</code></li> <li>Replace type hints to real union types in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Date::add</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Date::sub</code>, <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Date::setTime</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Date::setTimestamp</code></li> <li>Add implementation reference to <code>\\Stringable</code> when <code>__toString</code> is already implemented in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code></li> <li>Change default value from <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::$attachments</code> a new instance to <code>null</code></li> <li>Change default value from <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\DependencyAwareTrait::$dependencies</code> a new instance to <code>null</code></li> <li>Add possible exception <code>\\InvalidArgumentException</code> to be thrown from <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\CollectionInterface::push</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AbstractCollection::__construct</code> when validating items, that are added to the collection items</li> </ul>"},{"location":"releases/upcoming/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecate <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection::getType</code> in favour of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection::getEntityType</code> to improve type safety for better type safe class strings</li> <li>Deprecate <code>$type</code> parameter in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\TypedDatasetEntityCollection::__construct</code> to be a string. Prefer an instance of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> for better type safe class strings</li> </ul>"},{"location":"releases/upcoming/#removed_2","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\DeferralAwareInterface</code> and <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\DeferralAwareTrait</code> as it has not been a practical solution to defer closure execution in a different process</li> <li>Remove composer dependency <code>opis/closure</code> as it is no longer needed with the removal of closure deferrals introduced in HEPTAconnect 0.5</li> </ul> <p>Read the already released Dataset Base changelog</p>"},{"location":"releases/upcoming/#dataset-ecommerce","title":"Dataset Ecommerce","text":""},{"location":"releases/upcoming/#removed_3","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> </ul> <p>Read the already released Dataset Base changelog</p>"},{"location":"releases/upcoming/#portal-base","title":"Portal Base","text":""},{"location":"releases/upcoming/#added_3","title":"Added","text":"<ul> <li>Wrap <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract::supports</code> in new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract::getSupportedEntityType</code> to provide an instance of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> for better type safe class strings</li> <li>Wrap <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract::supports</code> in new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract::getSupportedEntityType</code> to provide an instance of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> for better type safe class strings</li> <li>Wrap <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract::supports</code> in new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract::getSupportedEntityType</code> to provide an instance of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalType</code> with <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalTypeCollection</code> as a type safe subtype class reference to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\SupportedPortalType</code> as a type safe class reference to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract</code> for better type safe class strings</li> <li>Add exception code <code>1659729321</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\SupportedPortalType</code> when a class string is neither referencing a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract</code> nor <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract</code> itself</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalContract::class</code> as factory method to create an instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalType</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionType</code> with <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionTypeCollection</code> as a type safe subtype class reference to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract::class</code> as factory method to create an instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionType</code> for better type safe class strings</li> <li>Wrap <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract::supports</code> in new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract::getSupportedPortal</code> to provide an instance of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\SupportedPortalType</code> for better type safe class strings</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerStackInterface::supports</code> to get the entity type of the explorer stack</li> <li>Add <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalNodeContextInterface::getLogger</code> so every context can directly access the portal node focused logger</li> </ul>"},{"location":"releases/upcoming/#changed_3","title":"Changed","text":"<ul> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterStackInterface::supports</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack::supports</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface::getEntityType</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingComponentStructContract::getEntityType</code> to be <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Change <code>$type</code> parameter in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\TypedMappingComponentCollection::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Change <code>$entityType</code> parameter in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection::bySupport</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection::bySupport</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentStruct::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection::filterByEntityType</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection::bySupport</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Lowered visibility of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract::supports</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract::supports</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract::supports</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PortalExtensionContract::supports</code> to be protected instead of public</li> <li>Rename method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getType</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\EmitterToken::getEntityType</code> with new return type for better type safe class strings</li> <li>Rename method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::getType</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ExplorerToken::getEntityType</code> with new return type for better type safe class strings</li> <li>Rename method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::getType</code> to <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\Token\\ReceiverToken::getEntityType</code> with new return type for better type safe class strings</li> <li>Change <code>$portalClass</code> parameter in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionCollection::bySupport</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code> instead of a string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection::filterByPortalNodeKey</code> from <code>Generator</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappingComponentCollection::filterByEntityType</code> from <code>Generator</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterCollection::bySupport</code> from <code>iterable</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerCollection::bySupport</code> from <code>iterable</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverCollection::bySupport</code> from <code>iterable</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\StatusReporting\\StatusReporterCollection::bySupportedTopic</code> from <code>iterable</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerCollection::bySupport</code> from <code>iterable</code> to <code>static</code> to improve its code usage for fluent syntax and better accessibility of other collection methods</li> <li>Make class final: <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent</code></li> <li>Add implementation reference to <code>\\Stringable</code> when <code>__toString</code> is already implemented in <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\FlowComponent\\CodeOrigin</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Serialization\\Contract\\SerializableStream</code></li> </ul>"},{"location":"releases/upcoming/#deprecated_2","title":"Deprecated","text":"<ul> <li>Deprecate method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\TypedMappingComponentCollection::getType</code> in favour of new method <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\TypedMappingComponentCollection::getEntityType</code> for better type safe class strings</li> </ul>"},{"location":"releases/upcoming/#removed_4","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\EmitterStack</code> out of this package into the <code>heptaconnect/core</code> as <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitterStack</code></li> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\ExplorerStack</code> out of this package into the <code>heptaconnect/core</code> as <code>\\Heptacom\\HeptaConnect\\Core\\Exploration\\ExplorerStack</code></li> <li>Move <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\ReceiverStack</code> out of this package into the <code>heptaconnect/core</code> as <code>\\Heptacom\\HeptaConnect\\Core\\Reception\\ReceiverStack</code></li> <li>Remove <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\MappedDatasetEntityCollection::groupByPortalNode</code> as usage of <code>\\spl_object_hash</code> is discouraged and grouping can be solved in storage implementations more efficiently</li> <li>Move deprecated <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PathMethodsTrait</code> contents into <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\Contract\\PackageContract</code></li> <li>Remove composer dependency <code>opis/closure</code> as it is no longer needed with the removal of closure deferrals as it has not been a practical solution to defer closure execution in a different process</li> </ul>"},{"location":"releases/upcoming/#fixed","title":"Fixed","text":"<ul> <li>Flow components allowed class string, that not necessarily have to reference an entity class, as supported entity type. Therefore <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitContextInterface::markAsFailed</code>, <code>\\Heptacom\\HeptaConnect\\Core\\Emission\\EmitContext::markAsFailed</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::explorer</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::emitter</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Builder\\FlowComponent::receiver</code> and the new <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Emission\\Contract\\EmitterContract::getSupportedEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Exploration\\Contract\\ExplorerContract::getSupportedEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Reception\\Contract\\ReceiverContract::getSupportedEntityType</code> throw exception <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\InvalidSubtypeClassNameException</code> or <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Exception\\InvalidClassNameException</code> on invalid input</li> </ul> <p>Read the already released Portal Base changelog</p>"},{"location":"releases/upcoming/#portal-local-shopware-platform","title":"Portal Local Shopware Platform","text":"<p>Read the already released Portal Local Shopware Platform changelog</p>"},{"location":"releases/upcoming/#package-shopware-6","title":"Package Shopware 6","text":""},{"location":"releases/upcoming/#added_4","title":"Added","text":"<ul> <li>Add composer dependency <code>heptacom/heptaconnect-dataset-base: &gt;=0.9.4 &lt;0.10</code> and <code>symfony/dependency-injection: ^4.4 || ^5.0</code> to make use of HEPTAconnect tools</li> <li>Add composer dependency <code>psr/http-client: ^1.0</code>, <code>psr/http-factory: ^1.0</code> and <code>psr/http-message: ^1.0</code> as HTTP request and responses needs to be handled</li> <li>Add composer dependency <code>psr/container: &gt;=1 &lt;3</code> as a containers are used and an implementation is provided</li> <li>Add composer dependency <code>psr/simple-cache: @stable</code> and <code>psr/simple-cache-implementation</code> and as caching is used as temporary storage</li> <li>Add composer dependency <code>symfony/polyfill-php80: *</code> to use PHP 8.0 functions already with PHP 7.4 code</li> <li>Add composer dependency <code>ext-json: *</code> as JSON requests and responses needs to be sent and parsed</li> <li>Add composer dependency <code>ext-mbstring: *</code> as Unicode texts are processed</li> <li>Add aggregation structs <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\AggregationContract</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\AggregationCollection</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\AggregationResult</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\AggregationResultCollection</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\AggregationBucket</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\AggregationBucketCollection</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\AbstractFieldAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\AverageAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\CountAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\EntityAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\FilterAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\MaximumAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\MinimumAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\StatisticsAggregation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\SumAggregation</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\TermsAggregation</code> to represent all aggregation features</li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_MINUTE</code> to hold a value for histograms measured per minute suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_HOUR</code> to hold a value for histograms measured per hour suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_DAY</code> to hold a value for histograms measured per day suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_WEEK</code> to hold a value for histograms measured per week suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_MONTH</code> to hold a value for histograms measured per month suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_QUARTER</code> to hold a value for histograms measured per quarter year suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::INTERVAL_YEAR</code> to hold a value for histograms measured per year suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Aggregation\\HistogramAggregation::$interval</code></li> <li>Add sorting structs <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\SortingContract</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\CountSorting</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\FieldSorting</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\SortingCollection</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\SortingContract::ASCENDING</code> to hold a value for ascending sorting suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\SortingContract::$direction</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\SortingContract::DESCENDING</code> to hold a value for descending sorting suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\SortingContract::$direction</code></li> <li>Add filter structs <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\FilterContract</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\FilterCollection</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\AbstractFieldFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\AbstractNestedFilters</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\AbstractTextFieldValueFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\AndFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\ContainsFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\EqualsAnyFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\EqualsFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\MultiFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\NotFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\OrFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\PrefixFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\RangeFilter</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\SuffixFilter</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Filter\\XorFilter</code></li> <li>Add query filter structs <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\ScoreQuery</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\ScoreQueryCollection</code></li> <li>Add criteria struct <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria</code> to group all features of a entity querying criteria like aggregation, associations, filtering, exact id loading and scoring</li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria::TOTAL_COUNT_MODE_NONE</code> to hold a value for a criteria, where no count is expected in the result, suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria::$totalCountMode</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria::TOTAL_COUNT_MODE_NEXT_PAGES</code> to hold a value for a criteria, where a rough count for a next-check is expected in the result, suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria::$totalCountMode</code></li> <li>Add constant <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria::TOTAL_COUNT_MODE_EXACT</code> to hold a value for a criteria, where an exact count is expected in the result, suitable for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Criteria::$totalCountMode</code></li> <li>Add criteria formatter <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\CriteriaFormatter</code> described by <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\CriteriaFormatterInterface</code> to convert a criteria object into a scalar-only array</li> <li>Add exception code <code>1682167000</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\CriteriaFormatter::formatCriteria</code> when an unsupported aggregation is given</li> <li>Add exception code <code>1682167001</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\CriteriaFormatter::formatCriteria</code> when an unsupported sorting is given</li> <li>Add exception code <code>1682167002</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\CriteriaFormatter::formatCriteria</code> when an unsupported filter is given</li> <li>Add entity struct <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\Entity</code> and collection <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\EntitySearch\\Contract\\EntityCollection</code> to add supporting methods for lists and structs returned from the API</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\ApiConfigurationStorageInterface</code> to provide <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\ApiConfiguration</code>, that is used to identify and authenticate against a Shopware Admin API</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\MemoryApiConfigurationStorage</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\ApiConfigurationStorageInterface</code> to provide static API configuration</li> <li>Add utility <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Support\\JsonStreamUtility</code> to unify JSON handling</li> <li>Add utility <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Support\\LetterCase</code> to convert strings between different letter cases</li> <li>Add exception code <code>1680371700</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Support\\JsonStreamUtility::fromPayloadToStream</code> when non-JSON-specific encoding issues occur</li> <li>Add exception code <code>1680371701</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Support\\JsonStreamUtility::fromStreamToPayload</code> when the decoded JSON is not a PHP array</li> <li>Add base class for exceptions <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\AbstractRequestException</code> that need a reference to a request</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\MalformedResponse</code> to identify issues with expected formats of an HTTP response</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\JsonResponseValidationCollectionException</code> to group exceptions during JSON response validation</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Contract\\ErrorHandlerInterface</code> to detect errors in a Shopware request cycle</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseErrorHandler</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Contract\\ErrorHandlerInterface</code> to detect any errors in a JSON response using multiple <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Contract\\JsonResponseValidatorInterface</code> in <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Contract\\JsonResponseValidatorCollection</code></li> <li>Add exception code <code>1680482000</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseErrorHandler::throwException</code> when multiple exceptions are grouped and the inner exceptions are important to investigate</li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\ServerErrorValidator</code> to convert generic 500 response into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\UnknownError</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\CartMissingOrderRelationValidator</code> to convert a cart missing order relation error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\CartMissingOrderRelationException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\FieldIsBlankValidator</code> to convert a field is blank error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\FieldIsBlankException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\InvalidLimitQueryValidator</code> to convert an invalid limit query error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\InvalidLimitQueryException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\InvalidUuidValidator</code> to convert an invalid UUID error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\InvalidUuidException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\MediaDuplicatedFileNameValidator</code> to convert a duplicated media filename error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\MediaDuplicatedFileNameException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\MediaFileTypeNotSupportedValidator</code> to convert a file type for media not supported error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\MediaFileTypeNotSupportedException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\MethodNotAllowedValidator</code> to convert a method not allowed error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\MethodNotAllowedException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\NotFoundValidator</code> to convert a not found error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\NotFoundException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\ResourceNotFoundValidator</code> to convert a resource not found error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\ResourceNotFoundException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\ScopeNotFoundValidator</code> to convert a scope not found error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\ScopeNotFoundException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\UnmappedFieldValidator</code> to convert an unmapped field error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\UnmappedFieldException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseValidator\\WriteUnexpectedFieldValidator</code> to convert an unexpected field during write error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Exception\\WriteUnexpectedFieldException</code></li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Exception\\AuthenticationFailed</code> to identify issues on authenticating with the Shopware API</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\AuthenticationInterface</code> to recalculate and retrieve authentication information to communicate with Shopware 6 Admin API</li> <li>Add default implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication</code> for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\AuthenticationInterface</code> to request new authentication token and store the token in the portal node storage to share it with other PHP instances</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\AuthenticationMemoryCache</code> as decorator for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\AuthenticationInterface</code> to hold authentication information in-memory to reduce calls to any I/O dependant storage</li> <li>Add exception code <code>1680350600</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::getAuthorizationHeader</code> when the token data could not be read from the portal node storage</li> <li>Add exception code <code>1680350601</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::getAuthorizationHeader</code> when the token data is missing the token_type</li> <li>Add exception code <code>1680350602</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::getAuthorizationHeader</code> when the token data is missing the access_token</li> <li>Add exception code <code>1680350610</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::refresh</code> when the API configuration could not be loaded</li> <li>Add exception code <code>1680350611</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::refresh</code> when the token request could not be created</li> <li>Add exception code <code>1680350612</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::refresh</code> when the token request could not be sent</li> <li>Add exception code <code>1680350613</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::refresh</code> when the token request received a non-OK response</li> <li>Add exception code <code>1680350614</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::refresh</code> when the token response could not be parsed</li> <li>Add exception code <code>1680350615</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication::refresh</code> when the token data could not be stored in the portal node storage</li> <li>Add exception code <code>1680350620</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Authentication</code> when the grant_type in the API configuration is not supported</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\AuthenticatedHttpClient</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\AuthenticatedHttpClientInterface</code> to automatically authorize requests using the <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Authentication\\Contract\\AuthenticationStorageInterface</code></li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\PackageExpectation\\Contract\\ExpectedPackagesAwareInterface</code> and base implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\PackageExpectation\\Support\\ExpectedPackagesAwareTrait</code> to make structs aware of expected packages in Shopware, so it can be applied to requests</li> <li>Add exception code <code>1680447700</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\PackageExpectation\\Support\\ExpectedPackagesAwareTrait</code> when a package name is empty</li> <li>Add exception code <code>1680447701</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\PackageExpectation\\Support\\ExpectedPackagesAwareTrait</code> when a package name is not in the format vendor/package-name</li> <li>Add exception code <code>1680447702</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\PackageExpectation\\Support\\ExpectedPackagesAwareTrait</code> when a version constraint is empty</li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\AbstractActionClient</code> with extracted dependencies in <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Support\\ActionClientUtils</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\Support\\AbstractShopwareClientUtils</code> for services to work with Shopware action endpoints</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseErrorHandler.admin_api</code> of type <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseErrorHandler</code> to validate Admin API responses with validators collected in service <code>Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Contract\\JsonResponseValidatorCollection.admim_api</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\DocumentNumberAlreadyExistsValidator</code> to convert a number already exists error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\DocumentNumberAlreadyExistsException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\ExpectationFailedValidator</code> to convert generic 417 response into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\ExpectationFailedException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\ExtensionInstallValidator</code> to convert a generic extension install error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\ExtensionInstallException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\ExtensionNotFoundValidator</code> to convert an extension not found error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\ExtensionNotFoundException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\InvalidDocumentFileGeneratorTypeValidator</code> to convert a file type for document generator is invalid error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\InvalidDocumentFileGeneratorTypeException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\InvalidDocumentIdValidator</code> to convert an invalid document id error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\InvalidDocumentIdException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\InvalidTypeValidator</code> to convert an invalid type error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\InvalidTypeException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\PluginNoPluginFoundInZipValidator</code> to convert a no plugin found in zip file error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\PluginNoPluginFoundInZipException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\PluginNotActivatedValidator</code> to convert a plugin not activated error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\PluginNotActivatedException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\PluginNotFoundValidator</code> to convert a plugin not found error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\PluginNotFoundException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\PluginNotInstalledValidator</code> to convert a plugin not installed error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\PluginNotInstalledException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\StateMachineInvalidEntityIdValidator</code> to convert a write type intend error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\StateMachineInvalidEntityIdException</code></li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\JsonResponseValidator\\WriteTypeIntendErrorValidator</code> to convert a write type intend error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\ErrorHandling\\Exception\\WriteTypeIntendException</code></li> <li>Add service to read Shopware version as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\InfoVersionAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoVersion\\InfoVersionActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoVersion\\InfoVersionParams</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoVersion\\InfoVersionResult</code></li> <li>Add service to read Shopware entity schema as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\InfoEntitySchemaAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoEntitySchema\\InfoEntitySchemaActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoEntitySchema\\InfoEntitySchemaParams</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoEntitySchema\\InfoEntitySchemaResult</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoEntitySchema\\EntitySchema</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\InfoEntitySchema\\EntitySchemaCollection</code></li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncAction\\SyncPayloadInterceptorCollection</code> to hold all payload interceptors described by <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncAction\\SyncPayloadInterceptorInterface</code></li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncV1Action\\SyncPayloadInterceptorCollection</code> to hold all payload interceptors described by <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncV1Action\\SyncPayloadInterceptorInterface</code></li> <li>Add service to sync entities for Shopware 6.5+ as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SyncAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Sync\\SyncActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Sync\\SyncPayload</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Sync\\SyncOperation</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Sync\\SyncOperationCollection</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Sync\\SyncResult</code> with support for sync payload interceptors described by <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncAction\\SyncPayloadInterceptorInterface</code></li> <li>Add service to sync entities up to Shopware 6.4 as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SyncV1Action</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SyncV1\\SyncActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SyncV1\\SyncPayload</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SyncV1\\SyncResult</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SyncV1\\SyncOperationResult</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SyncV1\\SyncOperationResultCollection</code> with support for sync payload interceptors described by <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncV1Action\\SyncPayloadInterceptorInterface</code></li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Exception\\SyncResultException</code> to combine exceptions with sync results</li> <li>Add exception code <code>1692604930</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\MediaUpload::uploadMedia</code> when a strategy is given, that is not supported</li> <li>Add exception code <code>1680479000</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SyncAction::sync</code> when an errors are in the sync result</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Exception\\SyncV1ResultException</code> to combine exceptions with sync results of the legacy sync API</li> <li>Add exception code <code>1680479000</code> to <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SyncV1Action::sync</code> when an errors are in the sync result</li> <li>Add service to send any Admin API authenticated request as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\GenericAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Generic\\GenericActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Generic\\GenericPayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\Generic\\GenericResult</code></li> <li>Add service to read Shopware system configuration as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SystemConfigGetAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigGet\\SystemConfigGetActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigGet\\SystemConfigGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigGet\\SystemConfigGetResult</code></li> <li>Add service to write Shopware system configuration for a sales channel as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SystemConfigPostAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigPost\\SystemConfigPostActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigPost\\SystemConfigPostPayload</code></li> <li>Add service to write Shopware system configuration for multiple sales channel as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\SystemConfigBatchAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigBatch\\SystemConfigBatchActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\SystemConfigBatch\\SystemConfigBatchPayload</code></li> <li>Add service to search Shopware store information as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\StorePluginSearchAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\StorePluginSearch\\StorePluginSearchActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\StorePluginSearch\\StorePluginSearchParams</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\StorePluginSearch\\StorePluginSearchResult</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\StorePluginSearch\\StorePlugin</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\StorePluginSearch\\StorePluginCollection</code></li> <li>Add service to search Shopware store information as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\PriceCalculateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\PriceCalculate\\PriceCalculateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\PriceCalculate\\PriceCalculatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\PriceCalculate\\PriceCalculateResult</code></li> <li>Add service to activate an extension as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionActivateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionActivate\\ExtensionActivateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionActivate\\ExtensionActivatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\AbstractExtensionPayload</code></li> <li>Add service to deactivate an extension as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionDeactivateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionDeactivate\\ExtensionDeactivateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionDeactivate\\ExtensionDeactivatePayload</code></li> <li>Add service to install an extension as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionInstallAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionInstall\\ExtensionInstallActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionInstall\\ExtensionInstallPayload</code></li> <li>Add service to refresh extension listing as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionRefreshAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionRefresh\\ExtensionRefreshActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionRefresh\\ExtensionRefreshParams</code></li> <li>Add service to remove an extension as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionRemoveAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionRemove\\ExtensionRemoveActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionRemove\\ExtensionRemovePayload</code></li> <li>Add service to uninstall an extension as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionUninstallAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionUninstall\\ExtensionUninstallActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionUninstall\\ExtensionUninstallPayload</code></li> <li>Add service to updates an extension as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionUpdateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionUpdate\\ExtensionUpdateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionUpdate\\ExtensionUpdatePayload</code></li> <li>Add service to upload extension as ZIP file as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\ExtensionUploadAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionUpload\\ExtensionUploadActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\ExtensionUpload\\ExtensionUploadPayload</code></li> <li>Add service to transition an entity state as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\EntityStateTransitionAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\EntityStateTransition\\EntityStateTransitionActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\EntityStateTransition\\EntityStateTransitionPayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\EntityStateTransition\\EntityStateTransitionResult</code></li> <li>Add service to generate order documents as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\OrderDocumentCreateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\OrderDocumentCreateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\OrderDocumentCreatePayload</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\DocumentPayload</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\DocumentPayloadCollection</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\OrderDocumentCreateResult</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\OrderDocument</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentCreate\\OrderDocumentCollection</code></li> <li>Add service to get an order document as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\OrderDocumentGetAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentGet\\OrderDocumentGetActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentGet\\OrderDocumentGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\OrderDocumentGet\\OrderDocumentGetResult</code></li> <li>Add service to upload medias as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\MediaUploadAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\MediaUpload\\MediaUploadActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\MediaUpload\\AbstractMediaUploadPayload</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\MediaUpload\\MediaUploadByStreamPayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Action\\Contract\\MediaUpload\\MediaUploadByUrlPayload</code></li> <li>Add service to read single entities as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\EntityGetAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityGet\\EntityGetActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityGet\\EntityGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityGet\\EntityGetResult</code></li> <li>Add service to create single entities as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\EntityCreateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityCreate\\EntityCreateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityCreate\\EntityCreatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityCreate\\EntityCreateResult</code></li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Exception\\EntityReferenceLocationFormatInvalidException</code> to identity an unexpected response location header e.g. after creating an entity</li> <li>Add service to update single entities as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\EntityUpdateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityUpdate\\EntityUpdateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityUpdate\\EntityUpdatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityUpdate\\EntityUpdateResult</code></li> <li>Add service to delete single entities as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\EntityDeleteAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityDelete\\EntityDeleteActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityDelete\\EntityDeleteCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntityDelete\\EntityDeleteResult</code></li> <li>Add service to search entities as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\EntitySearchAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntitySearch\\EntitySearchActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntitySearch\\EntitySearchCriteria</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\AbstractEntitySearchCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntitySearch\\EntitySearchResult</code></li> <li>Add service to search entity ids as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\EntitySearchIdAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntitySearchId\\EntitySearchIdActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntitySearchId\\EntitySearchIdCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Entity\\Contract\\EntitySearchId\\EntitySearchIdResult</code></li> <li>Add base classes <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\Support\\Action\\Generic\\AbstractGenericClient</code>, <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\Support\\Action\\Generic\\AbstractGenericPayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\Support\\Action\\Generic\\AbstractGenericResult</code> to build generic API clients</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Utility\\DependencyInjection\\AdminApiSyncPayloadInterceptorRegistrationCompilerPass</code> to automatically tag all <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncAction\\SyncPayloadInterceptorInterface</code> with the tag <code>heptaconnect.package.shopware6.admin_api.sync_payload_interceptor</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Contract\\SyncV1Action\\SyncPayloadInterceptorInterface</code> with the tag <code>heptaconnect.package.shopware6.admin_api.sync_v1_payload_interceptor</code> respectively</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Utility\\DependencyInjection\\SyntheticServiceContainer</code> to provide a PSR-11 container, when one is needed with previously instantiated service objects</li> <li>Add exception <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Utility\\DependencyInjection\\Exception\\ServiceNotFoundException</code> for scenarios, when a requested service is not found</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Utility\\DependencyInjection\\BaseFactory</code> to provide a central point of factorizing shared dependencies. It can be used together with a container built with a HEPTAconnect portal</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Utility\\EntityClient</code> to have a single dependency for common entity actions</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Utility\\ExtensionClient</code> to have a single dependency for common extension actions</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Utility\\GenericClient</code> to have a generic API client for any request</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\AdminApi\\Utility\\DependencyInjection\\AdminApiFactory</code> to provide a central point of factorizing shared dependencies for Admin API classes</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Authentication</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Contract\\AuthenticationInterface</code> to provide authentication information to communicate with Shopware 6 Store API</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\AuthenticationMemoryCache</code> as decorator for <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Contract\\AuthenticationInterface</code> to hold authentication information in-memory to reduce calls to any I/O dependant storage</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Contract\\ApiConfigurationStorageInterface</code> to provide <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\ApiConfiguration</code>, that is used to identify and authenticate against a Shopware Store API</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\MemoryApiConfigurationStorage</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Contract\\ApiConfigurationStorageInterface</code> to provide static API configuration</li> <li>Add implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\AuthenticatedHttpClient</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Contract\\AuthenticatedHttpClientInterface</code> to automatically authorize requests using the <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Authentication\\Contract\\AuthenticationStorageInterface</code></li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextTokenAwareInterface</code> and base implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Support\\ContextTokenAwareTrait</code> to make structs aware of optional context tokens, so it can be applied to requests</li> <li>Add contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextTokenRequiredInterface</code> and base implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Support\\ContextTokenRequiredTrait</code> to make structs aware of required context tokens, so it can be applied to requests</li> <li>Add service <code>Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseErrorHandler.store_api</code> of type <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\JsonResponseErrorHandler</code> to validate Store API responses with validators collected in service <code>Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\ErrorHandling\\Contract\\JsonResponseValidatorCollection.store_api</code></li> <li>Add base class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\AbstractActionClient</code> with extracted dependencies in <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Support\\ActionClientUtils</code> for services to work with Shopware action endpoints</li> <li>Add JSON response validator <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\ErrorHandling\\JsonResponseValidator\\CustomerNotLoggedInValidator</code> to convert a customer not logged in error into <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\ErrorHandling\\Exception\\CustomerNotLoggedInValidator</code></li> <li>Add service to send any Store API authenticated request as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\GenericAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\Generic\\GenericActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\Generic\\GenericPayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\Generic\\GenericResult</code></li> <li>Add service to get a Store API context as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\ContextGetAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextGet\\ContextGetActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextGet\\ContextGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextGet\\ContextGetResult</code></li> <li>Add service to update a Store API context as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\ContextUpdateAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextUpdate\\ContextUpdateActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextUpdate\\ContextUpdatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\ContextUpdate\\ContextUpdateResult</code></li> <li>Add service to read countries as implementation <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\CountryGetAction</code> for contract <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\CountryGet\\CountryGetActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\CountryGet\\CountryGetCriteria</code> and <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Action\\Contract\\CountryGet\\CountryGetResult</code></li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Utility\\GenericClient</code> to have a generic API client for any request</li> <li>Add utility class <code>\\Heptacom\\HeptaConnect\\Package\\Shopware6\\Http\\StoreApi\\Utility\\DependencyInjection\\StoreApiFactory</code> to provide a central point of factorizing shared dependencies for Store API classes</li> </ul> <p>Read the already released Package Shopware 6 changelog</p>"},{"location":"releases/upcoming/#storage-base","title":"Storage Base","text":""},{"location":"releases/upcoming/#added_5","title":"Added","text":"<ul> <li>Extract common fields from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivatePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivatePayload</code> into <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Contract\\PortalExtensionActiveChangePayloadContract</code></li> <li>Extract common fields from <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Fail\\JobFailPayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Finish\\JobFinishPayload</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Schedule\\JobSchedulePayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Start\\JobStartPayload</code> into <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Job\\Contract\\JobStateChangePayloadContract</code></li> <li>Add class <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\UiAuditTrailKeyInterface</code> with its collection <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\UiAuditTrailKeyCollection</code> as storage key for UI action audit trails</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailBeginActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\UiAuditTrail\\UiAuditTrailBegin\\UiAuditTrailBeginPayload</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\UiAuditTrail\\UiAuditTrailBegin\\UiAuditTrailBeginResult</code> to create an audit trail for UI actions</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogOutputActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\UiAuditTrail\\UiAuditTrailLogOutput\\UiAuditTrailLogOutputPayload</code> to attach output to the audit trail</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogErrorActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\UiAuditTrail\\UiAuditTrailLogError\\UiAuditTrailLogErrorPayload</code> and its collection <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\UiAuditTrail\\UiAuditTrailLogError\\UiAuditTrailLogErrorPayloadCollection</code> to attach an error message to the audit trail</li> <li>Add storage action <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailEndActionInterface</code> with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\UiAuditTrail\\UiAuditTrailEnd\\UiAuditTrailEndPayload</code> to marks the audit trail as finished</li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getUiAuditTrailBeginAction</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createUiAuditTrailBeginAction</code> to get an instance of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailBeginActionInterface</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getUiAuditTrailLogOutputAction</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createUiAuditTrailLogOutputAction</code> to get an instance of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogOutputActionInterface</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getUiAuditTrailLogErrorAction</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createUiAuditTrailLogErrorAction</code> to get an instance of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogErrorActionInterface</code></li> <li>Add method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Contract\\StorageFacadeInterface::getUiAuditTrailEndAction</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Bridge\\Support\\AbstractSingletonStorageFacade::createUiAuditTrailEndAction</code> to get an instance of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailEndActionInterface</code></li> <li>Add filter for source portal node, target portal node, entity type and capability to <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewCriteria</code> to limit the overview to certain results</li> </ul>"},{"location":"releases/upcoming/#changed_4","title":"Changed","text":"<ul> <li>Change <code>$entityType</code> parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayload::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayload::setEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Mapping::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Change <code>$entityType</code> parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindCriteria::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindCriteria::setEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetResult::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListCriteria::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListCriteria::setEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreatePayload::setEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreatePayload::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewResult::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewResult::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code> instead of a string for better type safe class strings</li> <li>Update implementation <code>Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct</code> to match changes in <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ForeignKeyAwareInterface</code> and <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Mapping\\Contract\\MappingInterface</code></li> <li>Change <code>$entityTypeFilter</code> parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewCriteria::setEntityTypeFilter</code> to be an array of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of an array of string for better type safe class strings</li> <li>Change <code>$entityTypeFilter</code> parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewCriteria::setEntityTypeFilter</code> to be <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ClassStringReferenceCollection</code> instead of a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\StringCollection</code> for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Create\\RouteCreatePayload::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\MappingNodeStructInterface::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Create\\IdentityRedirectCreatePayload::getEntityType</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Mapping::getEntityType</code> to be <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of a string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Find\\RouteFindCriteria::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Get\\RouteGetResult::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Listing\\ReceptionRouteListCriteria::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult::getEntityType</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewResult::getEntityType</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewResult::getEntityType</code> to be <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code> instead of a string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Identity\\Overview\\IdentityOverviewCriteria::getEntityTypeFilter</code> to be an array of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\EntityType</code> instead of an array of string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\IdentityRedirect\\Overview\\IdentityRedirectOverviewCriteria::setEntityTypeFilter</code> to be an <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ClassStringReferenceCollection</code> instead of <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\StringCollection</code> for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayload::getPortalClass</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PreviewPortalNodeKey::getPortalType</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalType</code> instead of a string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivatePayload::getExtensions</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivateResult::getPassedActivations</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivateResult::getFailedActivations</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivateResult::getPassedDeactivations</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivateResult::getFailedDeactivations</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionTypeCollection</code> instead of an array of string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Get\\PortalNodeGetResult::getPortalClass</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewResult::getPortalClass</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult::getSourcePortalClass</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult::getTargetPortalClass</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code> instead of a string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewCriteria::getClassNameFilter</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\ClassStringReferenceCollection</code> instead of an array of string for better type safe class strings</li> <li>Change string parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivatePayload::addExtension</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivatePayload::removeExtension</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivatePayload::addExtension</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Deactivate\\PortalExtensionDeactivatePayload::removeExtension</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionType</code> instead of a string for better type safe class strings</li> <li>Change array of string parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Activate\\PortalExtensionActivateResult::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionTypeCollection</code> instead of a string for better type safe class strings</li> <li>Change string parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayload::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Create\\PortalNodeCreatePayload::setPortalClass</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PreviewPortalNodeKey::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalType</code> instead of a string for better type safe class strings</li> <li>Change string parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Get\\PortalNodeGetResult::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewResult::__construct</code>, <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalExtension\\Find\\PortalExtensionFindResult::add</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult::__construct</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\ClassStringReferenceContract</code> instead of a string for better type safe class strings</li> <li>Change array of string parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\PortalNode\\Overview\\PortalNodeOverviewCriteria::setClassNameFilter</code> to be a <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\ClassStringReferenceCollection</code> instead of a string for better type safe class strings</li> <li>Implement <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\Contract\\AttachmentAwareInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\PrimaryKeySharingMappingStruct</code></li> <li>Change type of capabilities on <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\Route\\Overview\\RouteOverviewResult</code> from untyped array to <code>\\Heptacom\\HeptaConnect\\Dataset\\Base\\ScalarCollection\\StringCollection</code></li> <li>Combine <code>portalNodeKey</code> and <code>path</code> parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::__construct</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::__construct</code> using <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::getPortalNodeKey</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::getPath</code> methods with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::getStackIdentifier</code> using <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::setPortalNodeKey</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::setPath</code> methods with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Find\\WebHttpHandlerConfigurationFindCriteria::setStackIdentifier</code> using <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::getPortalNodeKey</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::getPath</code> methods with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::getStackIdentifier</code> using <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code></li> <li>Replace <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::setPortalNodeKey</code> and <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::setPath</code> methods with <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Action\\WebHttpHandlerConfiguration\\Set\\WebHttpHandlerConfigurationSetPayload::setStackIdentifier</code> using <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Web\\Http\\HttpHandlerStackIdentifier</code></li> </ul>"},{"location":"releases/upcoming/#deprecated_3","title":"Deprecated","text":"<ul> <li>Deprecate method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\TypedMappingCollection::getType</code> in favour of new method <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\TypedMappingCollection::getEntityType</code> for better type safe class strings</li> </ul>"},{"location":"releases/upcoming/#removed_5","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> <li>Remove deprecated <code>Heptacom\\HeptaConnect\\Dataset\\Base\\Support\\AttachmentAwareTrait::unattach</code></li> </ul> <p>Read the already released Storage Base changelog</p>"},{"location":"releases/upcoming/#storage-shopware-dal","title":"Storage Shopware DAL","text":""},{"location":"releases/upcoming/#added_6","title":"Added","text":"<ul> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1663693294CreateUiAuditTrailTable</code> to add UI audit trail table</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1663693295CreateUiAuditTrailDataTable</code> to add UI audit trail data table</li> <li>Add migration <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Migration\\Migration1663693296CreateUiAuditTrailErrorTable</code> to add UI audit trail error table</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailBeginActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailBegin</code> to create UI audit trails</li> <li>Add exception code <code>1663694616</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailBegin::begin</code> when storing a UI audit trail to the database fails</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailEndActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailEnd</code> to mark UI audit trails as ended</li> <li>Add exception code <code>1663694617</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailEnd::end</code> when setting the UI audit trail as finished fails on database layer</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogErrorActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailLogError</code> to add errors to UI audit trails</li> <li>Add exception code <code>1663694619</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailLogError::logError</code> when storing exceptions to UI audit trails on the database fails</li> <li>Add implementation for <code>\\Heptacom\\HeptaConnect\\Storage\\Base\\Contract\\Action\\UiAuditTrail\\UiAuditTrailLogOutputActionInterface</code> in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailLogOutput</code> to add output to UI audit trails</li> <li>Add exception code <code>1663694618</code> to <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\UiAuditTrail\\UiAuditTrailLogOutput::logOutput</code> when storing output to UI audit trails on the database fails</li> <li>Add support for new filter for source portal node, target portal node, entity type and capability in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Route\\RouteOverview::overview</code></li> </ul>"},{"location":"releases/upcoming/#changed_5","title":"Changed","text":"<ul> <li>Change <code>$payloadExtensions</code> parameter in <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionSwitchActive::toggle</code> to be <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionTypeCollection</code> instead of an array of string for better type safe class strings</li> <li>Change return type of <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\PortalExtension\\PortalExtensionSwitchActive::toggle</code> to be a <code>\\Heptacom\\HeptaConnect\\Portal\\Base\\Portal\\PortalExtensionTypeCollection</code> instead of an array of string for better type safe class strings</li> </ul>"},{"location":"releases/upcoming/#removed_6","title":"Removed","text":"<ul> <li>Remove support for <code>php: 7.4</code> as it will not receive any updates anymore, it is unlikely to be used. By raising the minimum PHP version we also make use of features introduced by PHP 8.0, which mainly have no effect on public API</li> </ul>"},{"location":"releases/upcoming/#fixed_1","title":"Fixed","text":"<ul> <li>Fix error when creating mappings via <code>\\Heptacom\\HeptaConnect\\Storage\\ShopwareDal\\Action\\Identity\\IdentityReflect</code>. Insertion payload was not binary as expected.</li> </ul> <p>Read the already released Storage Shopware DAL changelog</p>"}]}